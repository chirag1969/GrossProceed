
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>REGULAR SEP-25 Performance Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" />
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
  <style>
    :root {
      color-scheme: light;
      --bg: #f4f6fb;
      --card-bg: #fff;
      --text: #1b1e28;
      --muted: #5f677b;
      --accent: #145afc;
      --sticky-header-offset: 72px;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .tab-nav {
      display: flex;
      gap: 1rem;
      margin: 1rem 2rem 0.75rem;
      border-bottom: 1px solid rgba(27, 30, 40, 0.1);
    }
    .tab-button {
      position: relative;
      padding: 0.65rem 1.5rem;
      border: none;
      background: none;
      font: inherit;
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: color 0.2s ease, border-color 0.2s ease;
    }
    .tab-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }
    .tab-button.active {
      color: var(--text);
      border-color: var(--accent);
    }
    .tab-panel {
      display: none;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }
    .tab-panel.active {
      display: flex;
      flex-direction: column;
    }
    .grid {
      display: grid;
      gap: 1rem;
      padding: 0 2rem 1.5rem;
      flex: 1 1 auto;
      min-height: 0;
      grid-auto-rows: minmax(0, 1fr);
    }
    .grid > * {
      min-width: 0;
    }
    .lo-grid {
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .lo-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow: hidden;
      flex: 1 1 auto;
      min-height: 0;
    }
    .lo-card__header {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .lo-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .lo-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .sub-tab-nav {
      display: inline-flex;
      gap: 0.75rem;
      background: rgba(20, 90, 252, 0.08);
      padding: 0.4rem;
      border-radius: 999px;
      width: fit-content;
    }
    .sub-tab-button {
      border: none;
      background: transparent;
      font: inherit;
      font-weight: 600;
      color: var(--muted);
      padding: 0.45rem 1.25rem;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .sub-tab-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .sub-tab-button.active {
      background: var(--card-bg);
      color: var(--text);
      box-shadow: 0 6px 16px rgba(20, 90, 252, 0.15);
    }
    .sub-tab-panel {
      display: none;
      flex: 1 1 auto;
      min-height: 0;
    }
    .sub-tab-panel.active {
      display: flex;
      flex-direction: column;
    }
    .lo-card {
      min-height: calc(100vh - var(--sticky-header-offset) - 2.75rem);
    }

    .lo-table-container {
      position: relative;
      border-radius: 0.75rem;
      overflow-x: auto;
      overflow-y: auto;
      border: 1px solid rgba(27, 30, 40, 0.08);
      box-shadow: inset 0 0 0 1px rgba(27, 30, 40, 0.03), 0 12px 30px rgba(15, 23, 42, 0.08);
      background: #fff;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      flex: 1 1 auto;
      min-height: 0;
      padding-bottom: 0;
      scroll-padding-bottom: 96px;
      display: block;
    }
    .lo-table {
      width: 100%;
      min-width: 720px;
      min-width: max(720px, 100%);
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .lo-table thead th {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      color: var(--muted);
      font-weight: 600;
      padding: 0.65rem 0.75rem;
      text-align: right;
      position: sticky;
      top: 0;
      z-index: 5;
    }
    .lo-table thead th:first-child {
      text-align: left;
      z-index: 7;
    }
    .lo-table tbody td {
      padding: 0.35rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.08);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .lo-table tbody td.cell-date {
      text-align: left;
      font-weight: 600;
      color: var(--text);
    }
    .lo-table thead th:first-child,
    .lo-table tbody td.cell-date,
    .lo-table tfoot th:first-child {
      position: sticky;
      left: 0;
      z-index: 4;
    }
    .lo-table thead th:first-child {
      z-index: 6;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
    }
    .lo-table tbody td.cell-date {
      background: inherit;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.06);
    }
    .lo-table tbody tr:nth-child(odd) td.cell-date {
      background: rgba(226, 231, 244, 0.25);
    }
    .lo-table tbody tr:hover td.cell-date {
      background: rgba(41, 71, 137, 0.12);
    }
    .lo-table tfoot th:first-child {
      z-index: 5;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
    }
    .lo-table tbody tr:nth-child(odd) td {
      background: rgba(226, 231, 244, 0.25);
    }
    .lo-table tfoot {
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      box-shadow: 0 -8px 16px rgba(15, 23, 42, 0.08);
      z-index: 2;
    }
    .lo-table tfoot th,
    .lo-table tfoot td {
      position: sticky;
      bottom: 0;
      background: inherit;
      color: var(--text);
      font-weight: 600;
      padding: 0.55rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.14);
      z-index: 3;
    }
    .lo-table tfoot th {
      text-align: left;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.78rem;
    }
    .lo-table tfoot td {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .lo-table tfoot::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: -16px;
      height: 16px;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(244, 246, 251, 0) 0%, rgba(244, 246, 251, 0.9) 100%);
    }
    .card {
      background: var(--card-bg);
      border-radius: 0.75rem;
      padding: 1.25rem;
      box-shadow: 0 8px 24px rgba(16, 24, 40, 0.06);
    }
    .table-card {
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      min-height: 0;
    }
    .regular-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      flex: 1 1 auto;
      min-height: calc(100vh - var(--sticky-header-offset) - 2.75rem);
    }
    .regular-card__header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      padding: 0;
    }
    .regular-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .regular-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .regular-table-container {
      border-radius: 0.85rem;
      border: 1px solid rgba(64, 80, 120, 0.18);
      box-shadow: 0 12px 30px rgba(21, 32, 56, 0.12);
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
      overflow: visible;
      display: flex;
      flex-direction: column;
    }
    .regular-table-container .dataTables_wrapper {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .regular-table-container .dataTables_scroll {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .regular-table-container .dataTables_scrollHead {
      flex: 0 0 auto;
    }
    .regular-table-container .dataTables_scrollBody {
      flex: 1 1 auto !important;
    }
    .regular-table-container .dataTables_scrollFoot {
      flex: 0 0 auto;
    }
    .regular-table-container table {
      margin-top: 0;
    }
    .kpi-title {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 0.35rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .kpi-value {
      font-size: 1.75rem;
      font-weight: 600;
    }
    canvas {
      width: 100% !important;
      height: auto !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border-right: 1px solid rgba(27, 30, 40, 0.12);
    }
    th:first-child,
    td:first-child {
      border-left: 1px solid rgba(27, 30, 40, 0.12);
    }
    th:last-child,
    td:last-child {
      border-right: 1px solid rgba(27, 30, 40, 0.12);
    }
    th {
      color: var(--muted);
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .table-container {
      position: relative;
      overflow: visible;
      padding: 0;
      flex: 1 1 auto;
      min-height: 0;
      max-width: 100%;
      display: flex;
      flex-direction: column;
    }
    #tab-regular .table-card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    #tab-regular .table-container {
      padding-right: 0;
      padding-bottom: 0;
    }
    #regular-table {
      border-collapse: separate;
      width: 100%;
    }
    #regular-table thead th,
    #regular-table tbody td {
      text-align: left;
      padding: 0.3rem 0.65rem;
      border-right: 1px solid rgba(15, 23, 42, 0.08);
      line-height: 1.15;
      box-sizing: border-box;
    }
    #regular-table thead th {
      white-space: normal;
    }
    #regular-table tbody td {
      white-space: nowrap;
    }
    #regular-table thead th:first-child,
    #regular-table tbody td:first-child {
      border-left: 1px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table thead th:last-child,
    #regular-table tbody td:last-child {
      border-right: 1px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table thead th {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #000;
      font-weight: 700;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      border-bottom: 2px solid rgba(70, 97, 145, 0.35);
    }
    #regular-table tbody td {
      font-size: 0.82rem;
      color: rgba(27, 30, 40, 0.9);
      font-weight: 500;
      background: #fff;
    }
    #regular-table tbody tr {
      border-bottom: 1px solid rgba(15, 23, 42, 0.06);
    }
    #regular-table tbody tr:nth-child(even) td {
      background: rgba(226, 231, 244, 0.35);
    }
    #regular-table tbody tr:hover td {
      background: rgba(41, 71, 137, 0.12);
    }
    #regular-table thead th.cell-numeric,
    #regular-table tbody td.cell-numeric {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    #regular-table tbody td.cell-qty {
      font-weight: 600;
    }
    #regular-table thead th.is-filterable {
      cursor: pointer;
      position: relative;
    }
    #regular-table thead th.has-filter::after {
      content: '';
      position: absolute;
      top: 0.6rem;
      right: 0.5rem;
      width: 0.35rem;
      height: 0.35rem;
      border-radius: 50%;
      background: var(--accent);
    }
    #regular-table td.cell-multiline {
      white-space: normal !important;
      word-break: break-word;
      line-height: 1.35;
    }
    #regular-table th.cell-product,
    #regular-table td.cell-product {
      min-width: 24ch;
      max-width: 32ch;
      white-space: nowrap !important;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #regular-table_wrapper {
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scroll {
      border: none;
      border-radius: inherit;
      background: transparent;
      box-shadow: none;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scrollHead {
      position: relative;
      top: auto;
      z-index: 5;
      background: transparent;
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(21, 32, 56, 0.12);
      flex: 0 0 auto;
    }
    #regular-table_wrapper .dataTables_scrollHead table {
      border-collapse: separate;
      border-spacing: 0;
      width: 100% !important;
    }
    #regular-table_wrapper .dataTables_scrollBody {
      border-top: none;
      overflow-y: auto !important;
      overflow-x: auto !important;
      flex: 1 1 auto;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scrollBody table {
      border-collapse: separate;
      border-spacing: 0;
      background: #fff;
      width: 100% !important;
    }
    #regular-table_wrapper .dataTables_scrollFoot {
      position: sticky;
      bottom: 0;
      z-index: 12;
      background: linear-gradient(180deg, #f5f7ff 0%, #ebeffd 100%);
      box-shadow: 0 -10px 24px rgba(21, 32, 56, 0.1);
      flex: 0 0 auto;
    }
    #regular-table_wrapper .dataTables_scrollFoot th {
      position: sticky;
      bottom: 0;
      z-index: 13;
      padding: 0.6rem 0.7rem;
      font-size: 0.82rem;
      font-weight: 700;
      color: #1b1e28;
      text-transform: uppercase;
      background: transparent;
      border-top: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-label {
      text-align: left;
      color: #2d3748;
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total {
      text-align: right;
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-column {
      background: linear-gradient(180deg, #fff4d7 0%, #ffd897 100%);
      border-left: 2px solid rgba(15, 23, 42, 0.08);
      z-index: 14;
    }
    #regular-table_wrapper .dataTables_scrollHead th.cell-total-column,
    #regular-table_wrapper .dataTables_scrollBody td.cell-total-column,
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-column {
      position: sticky;
      right: 0;
      z-index: 4;
    }
    #regular-table_wrapper .dataTables_scrollHead th.cell-total-column {
      z-index: 7;
      background: linear-gradient(180deg, #fef5e6 0%, #fbdca3 100%);
      color: #5c3c00;
      border-left: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollBody td.cell-total-column {
      background: linear-gradient(180deg, #fffdf7 0%, #fff0d3 100%);
      font-weight: 600;
      border-left: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollBody tr:nth-child(even) td.cell-total-column {
      background: linear-gradient(180deg, #fff9ec 0%, #ffe7bf 100%);
    }
    #regular-table_wrapper .dataTables_scrollBody tr:hover td.cell-total-column {
      background: rgba(41, 71, 137, 0.18);
    }
    .regular-table__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.5rem;
      padding: 0.75rem 0.5rem 0;
      color: var(--muted);
      font-size: 0.85rem;
      flex-wrap: wrap;
    }
    .regular-table__footer .dataTables_info {
      padding-top: 0 !important;
    }
    .regular-table__footer .dataTables_paginate {
      margin: 0 !important;
    }
    #regular-table_wrapper .dataTables_paginate .paginate_button {
      border-radius: 999px;
    }
    table.dataTable thead .sorting,
    table.dataTable thead .sorting_asc,
    table.dataTable thead .sorting_desc,
    table.dataTable thead .sorting_asc_disabled,
    table.dataTable thead .sorting_desc_disabled {
      background-image: none !important;
    }
    table.dataTable thead > tr > th.sorting::before,
    table.dataTable thead > tr > th.sorting::after,
    table.dataTable thead > tr > th.sorting_asc::before,
    table.dataTable thead > tr > th.sorting_asc::after,
    table.dataTable thead > tr > th.sorting_desc::before,
    table.dataTable thead > tr > th.sorting_desc::after,
    table.dataTable thead > tr > th.sorting_asc_disabled::before,
    table.dataTable thead > tr > th.sorting_asc_disabled::after,
    table.dataTable thead > tr > th.sorting_desc_disabled::before,
    table.dataTable thead > tr > th.sorting_desc_disabled::after {
      display: none !important;
    }
    .header-menu {
      position: absolute;
      z-index: 20;
      min-width: 240px;
      max-width: 280px;
      background: var(--card-bg);
      border-radius: 0.75rem;
      box-shadow: 0 20px 35px rgba(15, 23, 42, 0.15);
      border: 1px solid rgba(27, 30, 40, 0.08);
      padding: 1rem;
      color: var(--text);
    }
    .header-menu.hidden {
      display: none;
    }
    .header-menu__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .header-menu__title {
      font-size: 0.95rem;
      margin: 0;
    }
    .header-menu__close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 1.25rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .header-menu__section {
      margin-bottom: 1rem;
    }
    .header-menu__buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .header-menu__button {
      flex: 1 1 auto;
      border: 1px solid rgba(27, 30, 40, 0.12);
      background: #f8f9fe;
      color: var(--text);
      border-radius: 999px;
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .header-menu__button:hover,
    .header-menu__button:focus-visible {
      border-color: var(--accent);
      background: rgba(20, 90, 252, 0.12);
      outline: none;
    }
    .header-menu__search {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid rgba(27, 30, 40, 0.12);
      padding: 0.45rem 0.6rem;
      font: inherit;
    }
    .header-menu__options {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid rgba(27, 30, 40, 0.1);
      border-radius: 0.65rem;
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .header-menu__options:empty {
      display: none;
      border: none;
      padding: 0;
    }
    .header-menu__empty-message {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .header-menu__option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: var(--text);
    }
    .header-menu__option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: var(--accent);
    }
    .header-menu__footer {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .header-menu__apply,
    .header-menu__clear {
      flex: 1;
      border-radius: 999px;
      padding: 0.45rem 0.75rem;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid transparent;
    }
    .header-menu__apply {
      background: var(--accent);
      color: #fff;
    }
    .header-menu__apply:hover,
    .header-menu__apply:focus-visible {
      background: #0f46c2;
      outline: none;
    }
    .header-menu__clear {
      background: rgba(20, 90, 252, 0.12);
      color: var(--accent);
      border-color: rgba(20, 90, 252, 0.3);
    }
    .header-menu__clear:hover,
    .header-menu__clear:focus-visible {
      background: rgba(20, 90, 252, 0.2);
      outline: none;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    @media (max-width: 1280px) {
      .lo-grid {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 900px) {
      .tab-nav {
        margin: 1rem 1rem 0.75rem;
      }
      .grid {
        padding: 0 1rem 1.5rem;
      }
      #regular-table_wrapper .dataTables_scrollHead {
        top: calc(var(--sticky-header-offset) - 24px);
      }
    }
  </style>
</head>
<body>
  <nav class="tab-nav" aria-label="Dashboard views">
    <button class="tab-button active" id="tab-lo-button" type="button" data-tab="lo" aria-controls="tab-lo" aria-selected="true">LO - Sales &amp; Spend</button>
    <button class="tab-button" id="tab-regular-button" type="button" data-tab="regular" aria-controls="tab-regular" aria-selected="false">Regular</button>
  </nav>
  <div class="tab-panel active" id="tab-lo" data-tab="lo" role="tabpanel" aria-labelledby="tab-lo-button" aria-hidden="false">
    <section class="grid lo-grid">
      <article class="card lo-card">
        <nav class="sub-tab-nav" aria-label="Listing owner metrics">
          <button class="sub-tab-button active" id="lo-sales-button" type="button" data-subtab="sales" aria-controls="lo-sales-panel" aria-selected="true">Sales</button>
          <button class="sub-tab-button" id="lo-spend-button" type="button" data-subtab="spend" aria-controls="lo-spend-panel" aria-selected="false">Spend</button>
        </nav>
        <div class="sub-tab-panel active" id="lo-sales-panel" data-subtab="sales" role="region" aria-labelledby="lo-sales-button">
          <div class="table-container lo-table-container">
            <table id="lo-sales-table" class="lo-table"></table>
          </div>
        </div>
        <div class="sub-tab-panel" id="lo-spend-panel" data-subtab="spend" role="region" aria-labelledby="lo-spend-button" aria-hidden="true">
          <div class="table-container lo-table-container">
            <table id="lo-spend-table" class="lo-table"></table>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-regular" data-tab="regular" role="tabpanel" aria-labelledby="tab-regular-button" aria-hidden="true">
    <section class="grid">
      <article class="card regular-card">
        <header class="regular-card__header">
          <h2 class="regular-card__title">Regular Performance</h2>
          <p class="regular-card__subtitle">Detailed order and spend metrics across all listings</p>
        </header>
        <div class="table-container regular-table-container">
          <table id="regular-table" class="display" style="width:100%"></table>
        </div>
      </article>
    </section>
  </div>
  <script>
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanels = document.querySelectorAll('.tab-panel');
    const subTabButtons = document.querySelectorAll('.sub-tab-button');
    const subTabPanels = document.querySelectorAll('.sub-tab-panel');

    let regularTable;
    let regularTableInitialised = false;
    let regularTableFooterValues = [];
    let regularTableNumericColumnSet = new Set();
    let datasetCache = null;
    let datasetPromise = null;
    let loTablesInitialised = false;
    let spendPivotCache = null;
    let spendPivotPromise = null;

    const NUMERIC_COLUMN_EXCLUSIONS = new Set(['ORDER NO', 'PLAIN ORDER NO', 'ORDER #', 'ORDER NO.', 'CHECKOUT']);
    const ZERO_DECIMAL_COLUMNS = new Set(['qty', 'order no', 'plain order no', 'order no.', 'order #']);
    const numberFormatter = new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const displayDateFormatter = new Intl.DateTimeFormat('en-US', { month: 'short', day: '2-digit' });
    const TOTAL_ROW_LABEL = 'Grand Total';

    let columnValueOptions = [];
    let columnFilters = {};
    let totalColumnIndex = -1;
    let headerMenuElement;
    let activeHeaderCell = null;
    let activeColumnIndex = null;
    const headerClickHandlers = new WeakMap();
    const HEADER_HEIGHT = 44;
    const ROW_HEIGHT = 34;
    const MIN_VISIBLE_ROWS = 5;
    const TABLE_BOTTOM_MARGIN = 18;
    const LO_TABLE_BOTTOM_MARGIN = 24;
    const MIN_LO_TABLE_HEIGHT = 320;
    const REGULAR_TABLE_PAGE_LENGTH = 200;
    const SHOW_REGULAR_TOTAL_ROW = true;

    function fetchDataset() {
      if (datasetCache) {
        return Promise.resolve(datasetCache);
      }
      if (datasetPromise) {
        return datasetPromise;
      }
      datasetPromise = fetch('regular_sep25_data.json')
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unable to load dataset');
          }
          return response.json();
        })
        .then((data) => {
          datasetCache = data;
          return data;
        })
        .catch((error) => {
          datasetPromise = null;
          throw error;
        });
      return datasetPromise;
    }

    function fetchSpendPivot() {
      if (spendPivotCache) {
        return Promise.resolve(spendPivotCache);
      }
      if (spendPivotPromise) {
        return spendPivotPromise;
      }
      spendPivotPromise = fetch('lo_spend_pivot.json')
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unable to load spend pivot');
          }
          return response.json();
        })
        .then((data) => {
          spendPivotCache = data;
          return data;
        })
        .catch((error) => {
          spendPivotPromise = null;
          throw error;
        });
      return spendPivotPromise;
    }

    function getStickyOffsetValue() {
      const rawValue = getComputedStyle(document.documentElement).getPropertyValue('--sticky-header-offset');
      const parsed = Number.parseFloat(rawValue);
      return Number.isFinite(parsed) ? parsed : 0;
    }

    function calculateScrollBodyHeight(rowCount, viewportTopOffset) {
      const baselineMinHeight = HEADER_HEIGHT + MIN_VISIBLE_ROWS * ROW_HEIGHT;
      const viewportHeight = Number.isFinite(window.innerHeight) ? window.innerHeight : baselineMinHeight;
      let availableViewport = viewportHeight;
      if (Number.isFinite(viewportTopOffset)) {
        availableViewport = viewportHeight - viewportTopOffset - TABLE_BOTTOM_MARGIN;
      } else {
        const stickyOffset = getStickyOffsetValue() + 64;
        availableViewport = viewportHeight - stickyOffset;
      }

      const usableViewport = Math.max(availableViewport, baselineMinHeight);
      const rowsToFillViewport = Math.max(
        MIN_VISIBLE_ROWS,
        Math.ceil(Math.max(0, usableViewport - HEADER_HEIGHT) / ROW_HEIGHT)
      );
      const effectiveRowCount = Math.max(rowCount, rowsToFillViewport);
      const desiredHeight = HEADER_HEIGHT + effectiveRowCount * ROW_HEIGHT;
      const heightWithinViewport = Math.min(desiredHeight, usableViewport);
      const minimumAllowedHeight = Math.min(baselineMinHeight, viewportHeight);
      const finalHeight = Math.max(heightWithinViewport, minimumAllowedHeight, HEADER_HEIGHT + MIN_VISIBLE_ROWS * ROW_HEIGHT);
      return Math.round(finalHeight);
    }

    function resizeLoTableContainers() {
      const containers = document.querySelectorAll('.lo-table-container');
      if (!containers.length) {
        return;
      }

      const viewportHeight = Number.isFinite(window.innerHeight) ? window.innerHeight : null;
      containers.forEach((container) => {
        if (!(container instanceof HTMLElement)) {
          return;
        }
        const rect = container.getBoundingClientRect();
        if (!rect) {
          return;
        }

        const topOffset = Number.isFinite(rect.top) ? rect.top : null;
        let availableHeight = viewportHeight;
        if (Number.isFinite(viewportHeight) && Number.isFinite(topOffset)) {
          availableHeight = viewportHeight - topOffset - LO_TABLE_BOTTOM_MARGIN;
        }

        if (!Number.isFinite(availableHeight)) {
          availableHeight = MIN_LO_TABLE_HEIGHT;
        }

        const finalHeight = Math.max(Math.floor(availableHeight), MIN_LO_TABLE_HEIGHT);
        container.style.height = `${finalHeight}px`;
        container.style.maxHeight = `${finalHeight}px`;
      });
    }

    function syncHeaderColumnWidths(table) {
      if (!table) {
        return;
      }
      const container = table.table().container();
      const scrollHead = container.querySelector('.dataTables_scrollHead');
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      const scrollFoot = container.querySelector('.dataTables_scrollFoot');
      const headerTable = scrollHead ? scrollHead.querySelector('table') : null;
      const bodyTable = scrollBody ? scrollBody.querySelector('table') : null;
      const footTables = [];
      if (scrollFoot) {
        const scrollFootTable = scrollFoot.querySelector('table');
        if (scrollFootTable) {
          footTables.push(scrollFootTable);
        }
      }
      const baseFoot = table.table().footer();
      if (baseFoot) {
        footTables.push(baseFoot);
      }
      if (!headerTable || !bodyTable) {
        return;
      }

      const columnIndexes = table.columns().indexes().toArray();
      columnIndexes.forEach((columnIndex) => {
        const column = table.column(columnIndex);
        const headerCell = column.header();
        if (!headerCell) {
          return;
        }

        const bodyCells = column.nodes().toArray();
        let maxWidth = 0;
        bodyCells.forEach((cell) => {
          if (!(cell instanceof HTMLElement)) {
            return;
          }
          const { width } = cell.getBoundingClientRect();
          if (width > maxWidth) {
            maxWidth = width;
          }
        });

        if (maxWidth <= 0) {
          const { width } = headerCell.getBoundingClientRect();
          maxWidth = width;
        }

        if (maxWidth > 0) {
          const widthPx = `${Math.ceil(maxWidth)}px`;
          headerCell.style.width = widthPx;
          headerCell.style.minWidth = widthPx;
          headerCell.style.maxWidth = widthPx;
          headerCell.style.boxSizing = 'border-box';
          bodyCells.forEach((cell) => {
            if (cell instanceof HTMLElement) {
              cell.style.width = widthPx;
              cell.style.minWidth = widthPx;
              cell.style.maxWidth = widthPx;
              cell.style.boxSizing = 'border-box';
            }
          });
          footTables.forEach((footTable) => {
            const footCells = footTable.querySelectorAll('th');
            const footCell = footCells[columnIndex];
            if (footCell instanceof HTMLElement) {
              footCell.style.width = widthPx;
              footCell.style.minWidth = widthPx;
              footCell.style.maxWidth = widthPx;
              footCell.style.boxSizing = 'border-box';
            }
          });
        }
      });

      const bodyWidth = bodyTable.getBoundingClientRect().width;
      if (bodyWidth > 0) {
        const widthPx = `${Math.ceil(bodyWidth)}px`;
        headerTable.style.width = widthPx;
        const scrollHeadInner = scrollHead.querySelector('.dataTables_scrollHeadInner');
        if (scrollHeadInner) {
          scrollHeadInner.style.width = widthPx;
        }
        if (scrollFoot) {
          const scrollFootInner = scrollFoot.querySelector('.dataTables_scrollFootInner');
          if (scrollFootInner) {
            scrollFootInner.style.width = widthPx;
          }
        }
        footTables.forEach((footTable) => {
          footTable.style.width = widthPx;
        });
      }
    }

    function adjustScrollBodyPadding(table) {
      if (!table) {
        return;
      }
      const container = table.table().container();
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      if (!scrollBody) {
        return;
      }
      const scrollFoot = container.querySelector('.dataTables_scrollFoot');
      let paddingBottom = 0;
      if (scrollFoot) {
        const footRect = scrollFoot.getBoundingClientRect();
        if (footRect && Number.isFinite(footRect.height)) {
          paddingBottom = Math.max(0, Math.ceil(footRect.height) - 6);
        }
      }
      scrollBody.style.paddingBottom = paddingBottom > 0 ? `${paddingBottom}px` : '0px';
    }

    function applyTableHeight(table) {
      if (!table) {
        return;
      }
      const rowCount = table.rows({ page: 'current' }).count();
      const container = table.table().container();
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      const scrollBodyRect = scrollBody ? scrollBody.getBoundingClientRect() : null;
      const viewportTopOffset = scrollBodyRect && Number.isFinite(scrollBodyRect.top) ? scrollBodyRect.top : null;
      const height = calculateScrollBodyHeight(rowCount, viewportTopOffset);
      if (scrollBody) {
        scrollBody.style.height = `${height}px`;
        scrollBody.style.maxHeight = `${height}px`;
      }
      const settings = table.settings()[0];
      if (settings && settings.oScroll) {
        settings.oScroll.sY = `${height}px`;
      }
      table.columns.adjust();
      requestAnimationFrame(() => {
        syncHeaderColumnWidths(table);
        adjustScrollBodyPadding(table);
      });
    }

    function applyFooterValuesToCells(cells, values, numericColumnSet) {
      if (!cells || !values || values.length === 0) {
        return;
      }
      values.forEach((value, index) => {
        const cell = cells[index];
        if (!cell) {
          return;
        }
        const displayValue = value ?? '';
        const isLabelCell = index === 0;
        const isNumeric = numericColumnSet.has(index);
        const isTotalColumn = totalColumnIndex >= 0 && index === totalColumnIndex;
        cell.textContent = displayValue;
        cell.classList.toggle('cell-total-label', isLabelCell);
        cell.classList.toggle('cell-total', !isLabelCell);
        cell.classList.toggle('cell-numeric', isNumeric && !isLabelCell);
        cell.classList.toggle('cell-total-column', isTotalColumn);
        if (isLabelCell) {
          cell.style.textAlign = 'left';
        } else if (isNumeric) {
          cell.style.textAlign = 'right';
        } else {
          cell.style.textAlign = 'left';
        }
      });
    }

    function ensureTableFooter(tableElement, columnCount, values = [], numericColumnSet = new Set()) {
      if (!tableElement) {
        return;
      }
      const existingFoot = tableElement.querySelector('tfoot');
      if (existingFoot) {
        tableElement.removeChild(existingFoot);
      }
      const tfoot = document.createElement('tfoot');
      const row = document.createElement('tr');
      for (let index = 0; index < columnCount; index += 1) {
        row.appendChild(document.createElement('th'));
      }
      tfoot.appendChild(row);
      tableElement.appendChild(tfoot);
      if (values.length === columnCount) {
        const cells = tfoot.querySelectorAll('th');
        applyFooterValuesToCells(cells, values, numericColumnSet);
      }
    }

    function renderFooterRow(table) {
      if (!table || !regularTableFooterValues.length) {
        return;
      }
      const container = table.table().container();
      const baseFooter = table.table().footer();
      const footerTables = [];
      if (baseFooter) {
        footerTables.push(baseFooter);
      }
      const scrollFoot = container.querySelector('.dataTables_scrollFoot table');
      if (scrollFoot) {
        footerTables.push(scrollFoot);
      }
      footerTables.forEach((footerTable) => {
        const cells = footerTable.querySelectorAll('th');
        applyFooterValuesToCells(cells, regularTableFooterValues, regularTableNumericColumnSet);
      });
      adjustScrollBodyPadding(table);
    }

    function refreshRegularTableLayout() {
      if (!regularTableInitialised || !regularTable) {
        return;
      }
      applyTableHeight(regularTable);
      if (regularTableFooterValues.length) {
        renderFooterRow(regularTable);
      }
    }

    function setActiveTab(targetTab) {
      tabButtons.forEach((button) => {
        const isActive = button.dataset.tab === targetTab;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', String(isActive));
      });
      tabPanels.forEach((panel) => {
        const isActive = panel.dataset.tab === targetTab;
        panel.classList.toggle('active', isActive);
        panel.setAttribute('aria-hidden', String(!isActive));
      });
      if (targetTab === 'regular') {
        loadRegularTable();
        refreshRegularTableLayout();
      } else {
        closeHeaderMenu();
        if (targetTab === 'lo') {
          if (!loTablesInitialised) {
            renderLoMessage('Loading dataâ€¦');
          }
          fetchDataset()
            .then((dataset) => {
              initializeLoTables(dataset);
            })
            .catch((error) => {
              renderLoMessage(error.message || 'Unable to load data');
            });
          requestAnimationFrame(() => resizeLoTableContainers());
        }
      }
    }

    tabButtons.forEach((button) => {
      button.addEventListener('click', () => setActiveTab(button.dataset.tab));
    });

    function setActiveSubTab(targetSubTab) {
      if (!subTabButtons.length) {
        return;
      }
      subTabButtons.forEach((button) => {
        const isActive = button.dataset.subtab === targetSubTab;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', String(isActive));
      });
      subTabPanels.forEach((panel) => {
        const isActive = panel.dataset.subtab === targetSubTab;
        panel.classList.toggle('active', isActive);
        panel.setAttribute('aria-hidden', String(!isActive));
      });
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    subTabButtons.forEach((button) => {
      button.addEventListener('click', () => setActiveSubTab(button.dataset.subtab));
    });

    if (subTabButtons.length > 0) {
      setActiveSubTab('sales');
    }

    function updateStickyOffset() {
      const headerEl = document.querySelector('header');
      const navEl = document.querySelector('.tab-nav');
      const headerHeight = headerEl ? headerEl.offsetHeight : 0;
      const navHeight = navEl ? navEl.offsetHeight : 0;
      const offset = headerHeight + navHeight + 24;
      document.documentElement.style.setProperty('--sticky-header-offset', `${offset}px`);
    }

    setActiveTab('lo');
    updateStickyOffset();
    window.addEventListener('resize', () => {
      updateStickyOffset();
      resizeLoTableContainers();
      if (regularTableInitialised && regularTable) {
        applyTableHeight(regularTable);
      }
    });

    function ensureHeaderMenu() {
      if (!headerMenuElement) {
        headerMenuElement = document.createElement('div');
        headerMenuElement.className = 'header-menu hidden';
        headerMenuElement.setAttribute('role', 'dialog');
        headerMenuElement.setAttribute('aria-modal', 'false');
        document.body.appendChild(headerMenuElement);

        document.addEventListener('click', (event) => {
          if (!headerMenuElement.classList.contains('hidden')) {
            const target = event.target;
            if (headerMenuElement && !headerMenuElement.contains(target) && !(target.closest('#regular-table thead'))) {
              closeHeaderMenu();
            }
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeHeaderMenu();
          }
        });

        window.addEventListener('resize', () => {
          if (!headerMenuElement.classList.contains('hidden') && activeHeaderCell) {
            positionHeaderMenu(activeHeaderCell);
          }
        });

        window.addEventListener('scroll', () => {
          if (!headerMenuElement.classList.contains('hidden') && activeHeaderCell) {
            positionHeaderMenu(activeHeaderCell);
          }
        }, { passive: true });
      }
    }

    function closeHeaderMenu() {
      if (headerMenuElement) {
        headerMenuElement.classList.add('hidden');
        headerMenuElement.innerHTML = '';
      }
      activeHeaderCell = null;
      activeColumnIndex = null;
    }

    function escapeRegex(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function optionLabel(value) {
      const normalized = value === null || value === undefined ? '' : String(value);
      return normalized === '' ? '(Blank)' : normalized;
    }

    function escapeHtml(value) {
      return String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    function applyColumnFilter(table, columnIndex, values, headerCell) {
      if (!table) return;
      if (values.length === 0) {
        table.column(columnIndex).search('', false, false).draw();
        delete columnFilters[columnIndex];
        if (headerCell) {
          headerCell.classList.remove('has-filter');
        }
        return;
      }
      const regex = `^(${values.map((value) => escapeRegex(value)).join('|')})$`;
      table.column(columnIndex).search(regex, true, false).draw();
      columnFilters[columnIndex] = values;
      if (headerCell) {
        headerCell.classList.add('has-filter');
      }
    }

    function positionHeaderMenu(headerCell) {
      if (!headerMenuElement) return;
      const rect = headerCell.getBoundingClientRect();
      const top = rect.bottom + window.scrollY + 8;
      const left = rect.left + window.scrollX;
      headerMenuElement.style.top = `${top}px`;
      headerMenuElement.style.left = `${left}px`;
    }

    function openHeaderMenu(headerCell, table) {
      ensureHeaderMenu();
      if (!headerMenuElement) return;

      activeHeaderCell = headerCell;
      const dataTableIndexAttr = headerCell.getAttribute('data-dt-column');
      if (dataTableIndexAttr !== null && dataTableIndexAttr !== '') {
        activeColumnIndex = Number(dataTableIndexAttr);
      } else if (headerCell.dataset.columnIndex) {
        activeColumnIndex = Number(headerCell.dataset.columnIndex);
      } else {
        activeColumnIndex = headerCell.cellIndex ?? 0;
      }
      const columnTitle = headerCell.textContent.trim();
      const options = columnValueOptions[activeColumnIndex] || [];
      const selectedValues = columnFilters[activeColumnIndex] ? [...columnFilters[activeColumnIndex]] : [];

      const optionsMarkup = options.map((value) => {
        const checked = selectedValues.includes(value) ? 'checked' : '';
        const rawLabel = optionLabel(value);
        const safeLabel = escapeHtml(rawLabel);
        const safeValueAttr = escapeHtml(value);
        const dataLabel = escapeHtml(rawLabel.toLowerCase());
        return `<label class="header-menu__option" data-label="${dataLabel}"><input type="checkbox" value="${safeValueAttr}" ${checked}>${safeLabel}</label>`;
      }).join('');
      const hasOptions = options.length > 0;

      headerMenuElement.innerHTML = `
        <div class="header-menu__header">
          <h3 class="header-menu__title">${columnTitle}</h3>
          <button type="button" class="header-menu__close" aria-label="Close menu">&times;</button>
        </div>
        <div class="header-menu__section">
          <div class="header-menu__buttons">
            <button type="button" class="header-menu__button" data-sort="asc">Sort ascending</button>
            <button type="button" class="header-menu__button" data-sort="desc">Sort descending</button>
          </div>
        </div>
        <div class="header-menu__section">
          <label for="header-menu-search" class="sr-only">Search values</label>
          <input id="header-menu-search" class="header-menu__search" type="search" placeholder="Search values" autocomplete="off">
        </div>
        <div class="header-menu__section">
          <div class="header-menu__options" role="group" aria-label="Filter values">
            ${hasOptions ? optionsMarkup : ''}
          </div>
          ${hasOptions ? '<div class="header-menu__empty-message" hidden>No matches found</div>' : '<p style="margin:0.5rem 0 0;color:var(--muted);font-size:0.85rem;">No values available</p>'}
        </div>
        <div class="header-menu__footer">
          <button type="button" class="header-menu__clear">Clear</button>
          <button type="button" class="header-menu__apply">Apply</button>
        </div>
      `;

      headerMenuElement.classList.remove('hidden');
      positionHeaderMenu(headerCell);

      const closeButton = headerMenuElement.querySelector('.header-menu__close');
      closeButton?.addEventListener('click', () => closeHeaderMenu());

      const sortButtons = headerMenuElement.querySelectorAll('[data-sort]');
      sortButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          const direction = event.currentTarget.getAttribute('data-sort');
          table.order([activeColumnIndex, direction]).draw();
          closeHeaderMenu();
        });
      });

      const optionsContainer = headerMenuElement.querySelector('.header-menu__options');
      const searchInput = headerMenuElement.querySelector('#header-menu-search');
      const emptyMessage = headerMenuElement.querySelector('.header-menu__empty-message');
      if (!hasOptions && searchInput) {
        searchInput.disabled = true;
        searchInput.placeholder = 'No values available';
      }
      searchInput?.addEventListener('input', (event) => {
        const query = event.currentTarget.value.trim().toLowerCase();
        const labels = optionsContainer ? optionsContainer.querySelectorAll('.header-menu__option') : [];
        let visibleCount = 0;
        labels.forEach((labelEl) => {
          const labelValue = labelEl.getAttribute('data-label') || '';
          const isVisible = labelValue.includes(query);
          labelEl.style.display = isVisible ? 'flex' : 'none';
          if (isVisible) {
            visibleCount += 1;
          }
        });
        if (emptyMessage) {
          emptyMessage.hidden = visibleCount !== 0;
        }
      });

      const applyButton = headerMenuElement.querySelector('.header-menu__apply');
      applyButton?.addEventListener('click', () => {
        const checkedInputs = optionsContainer ? Array.from(optionsContainer.querySelectorAll('input[type="checkbox"]')).filter((input) => input.checked) : [];
        const values = checkedInputs.map((input) => input.value);
        applyColumnFilter(table, activeColumnIndex, values, headerCell);
        closeHeaderMenu();
      });

      const clearButton = headerMenuElement.querySelector('.header-menu__clear');
      clearButton?.addEventListener('click', () => {
        if (optionsContainer) {
          optionsContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
        }
        applyColumnFilter(table, activeColumnIndex, [], headerCell);
        closeHeaderMenu();
      });
    }

    function buildColumnOptions(dataset) {
      const sets = dataset.columns.map(() => new Set());
      dataset.rows.forEach((row) => {
        row.forEach((value, index) => {
          const columnName = dataset.columns[index];
          const formatted = formatCellValue(value, columnName);
          sets[index].add(formatted);
        });
      });
      columnValueOptions = sets.map((set) => Array.from(set).sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })));
    }

    function wireHeaderEvents(table) {
      const container = table.table().container();
      const headerCells = Array.from(container.querySelectorAll('thead th'));

      headerCells.forEach((cell, index) => {
        if (!cell.dataset.columnIndex) {
          cell.dataset.columnIndex = String(index);
        }
        cell.classList.add('is-filterable');
        cell.classList.remove('is-static');
        cell.style.cursor = '';
        cell.removeAttribute('aria-disabled');
      });

      $(headerCells).off('click.DT keypress.DT');
      headerCells.forEach((cell, index) => {
        const existingHandler = headerClickHandlers.get(cell);
        if (existingHandler) {
          cell.removeEventListener('click', existingHandler);
          headerClickHandlers.delete(cell);
        }
        const isTotalColumn = totalColumnIndex >= 0 && index === totalColumnIndex;
        if (isTotalColumn) {
          return;
        }
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          openHeaderMenu(cell, table);
        };
        headerClickHandlers.set(cell, handler);
        cell.addEventListener('click', handler);
      });
    }

    function isPlaceholderValue(value) {
      if (value === null || value === undefined) {
        return true;
      }
      const normalized = typeof value === 'string' ? value.trim() : value;
      return normalized === '' || normalized === '-' || normalized === '--';
    }

    function parseNumericValue(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return value;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (isPlaceholderValue(trimmed)) {
          return null;
        }
        const numeric = Number(trimmed.replace(/,/g, ''));
        return Number.isNaN(numeric) ? null : numeric;
      }
      return null;
    }

    function parseExcelSerialToDate(value) {
      const numeric = parseNumericValue(value);
      if (numeric === null) {
        return null;
      }
      const serial = Math.floor(numeric);
      if (serial <= 0) {
        return null;
      }
      const fractional = numeric - serial;
      const adjustedSerial = serial > 59 ? serial - 1 : serial;
      const excelEpoch = Date.UTC(1899, 11, 30);
      const dayMilliseconds = 24 * 60 * 60 * 1000;
      const timestamp = excelEpoch + adjustedSerial * dayMilliseconds + Math.round(fractional * dayMilliseconds);
      const date = new Date(timestamp);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function formatExcelSerialDate(value) {
      const date = parseExcelSerialToDate(value);
      if (!date) {
        return null;
      }
      const day = String(date.getUTCDate()).padStart(2, '0');
      const month = String(date.getUTCMonth() + 1).padStart(2, '0');
      const year = date.getUTCFullYear();
      return `${day}-${month}-${year}`;
    }

    function detectNumericColumns(dataset) {
      return dataset.columns.reduce((accumulator, column, columnIndex) => {
        const normalizedColumn = column ? column.toUpperCase().trim() : '';
        if (NUMERIC_COLUMN_EXCLUSIONS.has(normalizedColumn)) {
          return accumulator;
        }
        let hasNumeric = false;
        const isNumericColumn = dataset.rows.every((row) => {
          const value = row[columnIndex];
          if (isPlaceholderValue(value)) {
            return true;
          }
          const numericValue = parseNumericValue(value);
          if (numericValue === null) {
            return false;
          }
          hasNumeric = true;
          return true;
        });
        if (isNumericColumn && hasNumeric) {
          accumulator.push(columnIndex);
        }
        return accumulator;
      }, []);
    }

    function formatCellValue(value, columnName) {
      if (isPlaceholderValue(value)) {
        return typeof value === 'string' ? value.trim() : '';
      }
      const normalizedColumn = columnName ? columnName.trim().toLowerCase() : '';
      if (normalizedColumn === 'checkout') {
        const formattedDate = formatExcelSerialDate(value);
        if (formattedDate) {
          return formattedDate;
        }
      }
      const numericValue = parseNumericValue(value);
      if (numericValue !== null) {
        const decimals = ZERO_DECIMAL_COLUMNS.has(normalizedColumn) ? 0 : 2;
        return numericValue.toFixed(decimals);
      }
      return typeof value === 'string' ? value : String(value ?? '');
    }

    function augmentDatasetWithTotals(dataset) {
      if (!dataset || !Array.isArray(dataset.columns) || !Array.isArray(dataset.rows)) {
        return {
          columns: [],
          rows: [],
          totalsRow: [],
          numericColumnIndices: [],
          totalColumnIndex: -1,
        };
      }

      const baseColumns = dataset.columns.slice();
      const numericColumnIndices = detectNumericColumns(dataset);
      const totalsByColumn = new Map();
      numericColumnIndices.forEach((index) => totalsByColumn.set(index, 0));

      const augmentedRows = dataset.rows.map((row) => {
        const newRow = row.slice();
        numericColumnIndices.forEach((columnIndex) => {
          const numericValue = parseNumericValue(row[columnIndex]);
          if (numericValue === null) {
            return;
          }
          totalsByColumn.set(columnIndex, (totalsByColumn.get(columnIndex) ?? 0) + numericValue);
        });
        return newRow;
      });

      const totalsRow = new Array(baseColumns.length).fill('');
      if (totalsRow.length > 0) {
        totalsRow[0] = TOTAL_ROW_LABEL;
      }

      numericColumnIndices.forEach((columnIndex) => {
        const total = totalsByColumn.get(columnIndex);
        if (typeof total === 'number' && Number.isFinite(total)) {
          totalsRow[columnIndex] = total;
        } else {
          totalsRow[columnIndex] = 0;
        }
      });

      return {
        columns: baseColumns,
        rows: augmentedRows,
        totalsRow,
        numericColumnIndices,
        totalColumnIndex: -1,
      };
    }

    function buildFormattedFooterValues(augmentedDataset) {
      if (!augmentedDataset || !Array.isArray(augmentedDataset.columns) || !Array.isArray(augmentedDataset.totalsRow)) {
        return [];
      }
      const numericColumns = new Set(augmentedDataset.numericColumnIndices || []);
      return augmentedDataset.totalsRow.map((value, index) => {
        if (index === 0) {
          const label = typeof value === 'string' && value.trim().length ? value : TOTAL_ROW_LABEL;
          return label;
        }
        if (numericColumns.has(index)) {
          return formatCellValue(value, augmentedDataset.columns[index]);
        }
        if (value === null || value === undefined) {
          return '';
        }
        return typeof value === 'string' ? value : String(value);
      });
    }

    function findColumnIndex(dataset, targetName) {
      if (!dataset || !Array.isArray(dataset.columns)) {
        return -1;
      }
      const normalizedTarget = targetName ? targetName.trim().toLowerCase() : '';
      return dataset.columns.findIndex((column) => (column || '').trim().toLowerCase() === normalizedTarget);
    }

    function formatTwoDecimal(value) {
      const numeric = Number.isFinite(value) ? value : 0;
      return numberFormatter.format(numeric);
    }

    function buildLoPivot(dataset, targetColumnName, options = {}) {
      const { normalizedOrder = null, displayNameOverrides = null } = options;
      const checkoutIndex = findColumnIndex(dataset, 'checkout');
      const ownerIndex = findColumnIndex(dataset, 'listing owner');
      const valueIndex = findColumnIndex(dataset, targetColumnName);
      if (checkoutIndex < 0 || ownerIndex < 0 || valueIndex < 0) {
        return { loList: [], rows: [], order: [], displayNames: new Map() };
      }

      const normalizedDisplayOverrides = displayNameOverrides instanceof Map
        ? displayNameOverrides
        : (displayNameOverrides && typeof displayNameOverrides === 'object'
          ? new Map(Object.entries(displayNameOverrides))
          : new Map());
      const listingOwners = new Map();
      const ownerTotals = new Map();
      const dateMap = new Map();

      dataset.rows.forEach((row) => {
        const date = parseExcelSerialToDate(row[checkoutIndex]);
        if (!date) {
          return;
        }
        const isoKey = date.toISOString().slice(0, 10);
        const ownerRaw = row[ownerIndex];
        let owner = '';
        if (typeof ownerRaw === 'string') {
          owner = ownerRaw.trim();
        } else if (ownerRaw === null || ownerRaw === undefined) {
          owner = '';
        } else {
          owner = String(ownerRaw).trim();
        }
        const ownerName = owner || 'Unassigned';
        const normalizedOwner = ownerName.toLocaleLowerCase();
        const displayName = normalizedDisplayOverrides.get(normalizedOwner) ?? ownerName;

        const rawValue = row[valueIndex];
        const numericValue = parseNumericValue(rawValue);
        const value = numericValue === null ? 0 : numericValue;

        if (!listingOwners.has(normalizedOwner)) {
          listingOwners.set(normalizedOwner, displayName);
        }
        ownerTotals.set(normalizedOwner, (ownerTotals.get(normalizedOwner) ?? 0) + value);
        if (!dateMap.has(isoKey)) {
          dateMap.set(isoKey, { date, values: new Map() });
        }
        const entry = dateMap.get(isoKey);
        entry.values.set(normalizedOwner, (entry.values.get(normalizedOwner) ?? 0) + value);
      });

      let ownerOrder;
      if (Array.isArray(normalizedOrder) && normalizedOrder.length) {
        const orderSet = new Set();
        ownerOrder = normalizedOrder.filter((key) => {
          if (!listingOwners.has(key) || orderSet.has(key)) {
            return false;
          }
          orderSet.add(key);
          return true;
        });
        const remainingOwners = Array.from(listingOwners.keys()).filter((key) => !orderSet.has(key));
        remainingOwners.sort((a, b) => {
          const totalDiff = (ownerTotals.get(b) ?? 0) - (ownerTotals.get(a) ?? 0);
          if (Math.abs(totalDiff) > Number.EPSILON) {
            return totalDiff;
          }
          return listingOwners.get(a).localeCompare(listingOwners.get(b), undefined, { sensitivity: 'base' });
        });
        ownerOrder = ownerOrder.concat(remainingOwners);
      } else {
        ownerOrder = Array.from(listingOwners.keys()).sort((a, b) => {
          const totalDiff = (ownerTotals.get(b) ?? 0) - (ownerTotals.get(a) ?? 0);
          if (Math.abs(totalDiff) > Number.EPSILON) {
            return totalDiff;
          }
          return listingOwners.get(a).localeCompare(listingOwners.get(b), undefined, { sensitivity: 'base' });
        });
      }

      const loList = ownerOrder.map((key) => listingOwners.get(key));
      const rows = Array.from(dateMap.values())
        .sort((a, b) => a.date - b.date)
        .map(({ date, values }) => {
          const displayDate = displayDateFormatter.format(date);
          const formattedValues = ownerOrder.map((ownerKey) => formatTwoDecimal(values.get(ownerKey) ?? 0));
          return { displayDate, formattedValues };
        });

      const totals = ownerOrder.map((ownerKey) => formatTwoDecimal(ownerTotals.get(ownerKey) ?? 0));

      return {
        loList,
        rows,
        totals,
        order: ownerOrder,
        displayNames: new Map(listingOwners),
      };
    }

    function renderLoTable(tableElement, pivotData) {
      if (!tableElement) {
        return;
      }
      const { loList, rows, totals } = pivotData;
      if (!loList.length || !rows.length) {
        const columnCount = Math.max(1, loList.length + 1);
        tableElement.innerHTML = `<tbody><tr><td class="cell-date" colspan="${columnCount}">No data available</td></tr></tbody>`;
        return;
      }

      let headerHtml = '<thead><tr><th scope="col" class="cell-date">Date</th>';
      loList.forEach((owner) => {
        headerHtml += `<th scope="col">${escapeHtml(owner)}</th>`;
      });
      headerHtml += '</tr></thead>';

      let bodyHtml = '<tbody>';
      rows.forEach(({ displayDate, formattedValues }) => {
        bodyHtml += `<tr><td class="cell-date">${escapeHtml(displayDate)}</td>`;
        formattedValues.forEach((value) => {
          bodyHtml += `<td>${value}</td>`;
        });
        bodyHtml += '</tr>';
      });
      bodyHtml += '</tbody>';

      let footerHtml = '';
      if (Array.isArray(totals) && totals.length === loList.length) {
        footerHtml = '<tfoot><tr>';
        footerHtml += '<th scope="row" class="cell-date">Total</th>';
        totals.forEach((value) => {
          footerHtml += `<td>${value}</td>`;
        });
        footerHtml += '</tr></tfoot>';
      }

      tableElement.innerHTML = `${headerHtml}${bodyHtml}${footerHtml}`;
    }

    function normalizeOwnerKey(label) {
      if (typeof label !== 'string') {
        return '';
      }
      return label.trim().toLocaleLowerCase();
    }

    function alignPivotToReference(pivotData, referencePivot) {
      if (!pivotData || !Array.isArray(pivotData.loList) || !Array.isArray(pivotData.rows)) {
        return { loList: [], rows: [], totals: [] };
      }
      const referenceLabels = Array.isArray(referencePivot?.loList) ? referencePivot.loList : [];
      const referenceKeys = referenceLabels.map((label) => normalizeOwnerKey(label));
      const pivotKeys = pivotData.loList.map((label) => normalizeOwnerKey(label));

      const labelMap = new Map();
      pivotKeys.forEach((key, index) => {
        if (!labelMap.has(key)) {
          labelMap.set(key, pivotData.loList[index] ?? '');
        }
      });

      const columnIndexMap = new Map();
      pivotKeys.forEach((key, index) => {
        if (!columnIndexMap.has(key)) {
          columnIndexMap.set(key, index);
        }
      });

      const orderedKeys = [];
      referenceKeys.forEach((key) => {
        if (columnIndexMap.has(key) && !orderedKeys.includes(key)) {
          orderedKeys.push(key);
        }
      });
      pivotKeys.forEach((key) => {
        if (!orderedKeys.includes(key)) {
          orderedKeys.push(key);
        }
      });

      const loList = orderedKeys.map((key) => labelMap.get(key) ?? '');
      const rows = pivotData.rows.map((row) => {
        const displayDate = typeof row.displayDate === 'string' ? row.displayDate : '';
        const formattedValuesSource = Array.isArray(row.formattedValues) ? row.formattedValues : [];
        const formattedValues = orderedKeys.map((key) => {
          const columnIndex = columnIndexMap.get(key);
          if (typeof columnIndex !== 'number') {
            return '0.00';
          }
          const value = formattedValuesSource[columnIndex];
          if (typeof value === 'string') {
            return value;
          }
          if (typeof value === 'number' && Number.isFinite(value)) {
            return value.toFixed(2);
          }
          return '0.00';
        });
        return { displayDate, formattedValues };
      });

      const totalsSource = Array.isArray(pivotData.totals) ? pivotData.totals : [];
      const totals = orderedKeys.map((key) => {
        const columnIndex = columnIndexMap.get(key);
        if (typeof columnIndex !== 'number') {
          return '0.00';
        }
        const value = totalsSource[columnIndex];
        if (typeof value === 'string') {
          return value;
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          return value.toFixed(2);
        }
        return '0.00';
      });

      return { loList, rows, totals };
    }

    function renderLoMessage(message) {
      const escaped = escapeHtml(message);
      const markup = `<tbody><tr><td class="cell-date" colspan="1">${escaped}</td></tr></tbody>`;
      const salesTable = document.getElementById('lo-sales-table');
      const spendTable = document.getElementById('lo-spend-table');
      if (salesTable) {
        salesTable.innerHTML = markup;
      }
      if (spendTable) {
        spendTable.innerHTML = markup;
      }
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    function initializeLoTables(dataset) {
      if (loTablesInitialised) {
        return;
      }
      const salesTable = document.getElementById('lo-sales-table');
      const spendTable = document.getElementById('lo-spend-table');
      const salesPivot = buildLoPivot(dataset, 'total revenue');
      renderLoTable(salesTable, salesPivot);
      requestAnimationFrame(() => resizeLoTableContainers());
      if (spendTable) {
        const loadingColumns = Math.max(1, (salesPivot?.loList?.length ?? 0) + 1);
        spendTable.innerHTML = `<tbody><tr><td class="cell-date" colspan="${loadingColumns}">Loadingâ€¦</td></tr></tbody>`;
      }
      fetchSpendPivot()
        .then((pivotData) => {
          const alignedPivot = alignPivotToReference(pivotData, salesPivot);
          renderLoTable(spendTable, alignedPivot);
          requestAnimationFrame(() => resizeLoTableContainers());
        })
        .catch((error) => {
          if (!spendTable) {
            return;
          }
          const baseColumnCount = Array.isArray(salesPivot?.loList) ? salesPivot.loList.length + 1 : 1;
          const message = escapeHtml(error.message || 'Unable to load spend pivot');
          spendTable.innerHTML = `<tbody><tr><td class="cell-date" colspan="${baseColumnCount}">${message}</td></tr></tbody>`;
          requestAnimationFrame(() => resizeLoTableContainers());
        });
      loTablesInitialised = true;
    }

    function loadRegularTable() {
      if (regularTableInitialised) {
        return;
      }
      fetchDataset()
        .then((dataset) => {
          updateStickyOffset();

          const augmentedDataset = augmentDatasetWithTotals(dataset);
          totalColumnIndex = augmentedDataset.totalColumnIndex;
          const columns = augmentedDataset.columns.map((title) => ({ title }));
          const formattedRows = augmentedDataset.rows.map((row) => row.map((value, index) => formatCellValue(value, augmentedDataset.columns[index])));
          const productColumnIndex = augmentedDataset.columns.indexOf('Product');
          const quantityColumnIndex = augmentedDataset.columns.findIndex((column) => column && column.trim().toLowerCase() === 'qty');
          const numericColumnIndices = augmentedDataset.numericColumnIndices;

          regularTableFooterValues = SHOW_REGULAR_TOTAL_ROW
            ? buildFormattedFooterValues(augmentedDataset)
            : [];
          regularTableNumericColumnSet = SHOW_REGULAR_TOTAL_ROW
            ? new Set(numericColumnIndices)
            : new Set();

          if (SHOW_REGULAR_TOTAL_ROW) {
            const tableElement = document.getElementById('regular-table');
            if (tableElement) {
              ensureTableFooter(
                tableElement,
                augmentedDataset.columns.length,
                regularTableFooterValues,
                regularTableNumericColumnSet
              );
            }
          }

          const columnClassMap = new Map();
          const addColumnClass = (columnIndex, className) => {
            if (columnIndex < 0) {
              return;
            }
            if (!columnClassMap.has(columnIndex)) {
              columnClassMap.set(columnIndex, new Set());
            }
            columnClassMap.get(columnIndex).add(className);
          };

          addColumnClass(productColumnIndex, 'cell-product');
          addColumnClass(quantityColumnIndex, 'cell-qty');
          numericColumnIndices.forEach((columnIndex) => addColumnClass(columnIndex, 'cell-numeric'));

          const columnDefs = Array.from(columnClassMap.entries()).map(([columnIndex, classSet]) => ({
            targets: Number(columnIndex),
            className: Array.from(classSet).join(' '),
          }));

          const initialRowCount = Math.min(augmentedDataset.rows.length, REGULAR_TABLE_PAGE_LENGTH);
          const initialScrollHeight = `${calculateScrollBodyHeight(initialRowCount)}px`;
          regularTable = $('#regular-table').DataTable({
            data: formattedRows,
            columns,
            columnDefs,
            scrollX: true,
            scrollY: initialScrollHeight,
            scrollCollapse: true,
            deferRender: true,
            autoWidth: true,
            order: [],
            paging: true,
            pageLength: REGULAR_TABLE_PAGE_LENGTH,
            lengthChange: false,
            info: true,
            dom: 't<"regular-table__footer"ip>'
          });

          buildColumnOptions(augmentedDataset);
          wireHeaderEvents(regularTable);
          applyTableHeight(regularTable);
          if (SHOW_REGULAR_TOTAL_ROW) {
            renderFooterRow(regularTable);
          }
          regularTable.on('draw.dt', () => {
            wireHeaderEvents(regularTable);
            applyTableHeight(regularTable);
            if (SHOW_REGULAR_TOTAL_ROW) {
              renderFooterRow(regularTable);
            }
          });

          regularTableInitialised = true;
          requestAnimationFrame(() => refreshRegularTableLayout());
        })
        .catch((error) => {
          const tableElement = document.getElementById('regular-table');
          if (tableElement) {
            tableElement.outerHTML = `<p style="color: var(--muted);">${error.message}</p>`;
          }
        });
    }

  </script>
</body>
</html>

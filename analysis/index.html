
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>REGULAR SEP-25 Performance Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.min.css" />
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <style>
    html {
      font-size: 13px;
    }
    :root {
      color-scheme: light;
      --bg: #f1f3f4;
      --card-bg: #ffffff;
      --text: #121625;
      --muted: #5f677b;
      --accent: #145afc;
      --accent-soft: rgba(20, 90, 252, 0.12);
      --shadow-soft: 0 24px 45px rgba(15, 23, 42, 0.12);
      --transition-snappy: 260ms;
      --transition-gentle: 340ms;
      --sticky-header-offset: 72px;
      --tab-bar-bg: #ffffff;
      --tab-border: #dfe1e5;
      --tab-active-bg: #ffffff;
      --tab-inactive-bg: rgba(95, 99, 104, 0.08);
      --tab-inactive-hover-bg: rgba(95, 99, 104, 0.14);
      --tab-text: #202124;
      --tab-text-muted: #5f6368;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      overflow-y: auto;
      -webkit-font-smoothing: antialiased;
    }
    .tab-nav {
      position: sticky;
      top: 0;
      z-index: 45;
      display: flex;
      align-items: flex-end;
      flex-wrap: nowrap;
      gap: 0.3rem;
      margin: 0 0 1.1rem;
      padding: 0 1.85rem;
      min-height: 3.25rem;
      border-radius: 0;
      background: var(--tab-bar-bg);
      box-shadow: inset 0 -1px 0 var(--tab-border);
      border: none;
      box-sizing: border-box;
      overflow-x: auto;
    }
    .tab-button {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: 2.75rem;
      padding: 0.45rem 1.6rem;
      border: 1px solid transparent;
      background: var(--tab-inactive-bg);
      font: inherit;
      color: var(--tab-text-muted);
      font-weight: 600;
      letter-spacing: 0.01em;
      cursor: pointer;
      border-radius: 999px;
      z-index: 1;
      transition:
        color var(--transition-snappy) ease,
        background var(--transition-snappy) ease,
        box-shadow var(--transition-snappy) ease,
        border-color var(--transition-snappy) ease,
        letter-spacing var(--transition-snappy) ease;
    }
    .tab-button:hover,
    .tab-button:focus-visible {
      color: var(--tab-text);
      background: var(--tab-inactive-hover-bg);
      border-color: rgba(95, 99, 104, 0.18);
      outline: none;
    }
    .tab-button.active {
      color: var(--tab-text);
      background: var(--tab-active-bg);
      border-color: var(--tab-border);
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.1);
      z-index: 2;
    }
    .tab-nav__indicator {
      display: none;
    }
    .tab-panel {
      position: relative;
      display: none;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }
    .tab-panel.active,
    .tab-panel.is-exiting {
      display: flex;
      flex-direction: column;
    }
    .tab-panel.active {
      animation: tab-panel-in var(--transition-gentle) ease forwards;
    }
    .tab-panel.is-exiting {
      animation: tab-panel-out calc(var(--transition-snappy) + 40ms) ease forwards;
      pointer-events: none;
    }
    .panel-loading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      background: linear-gradient(180deg, rgba(237, 241, 255, 0.86) 0%, rgba(237, 241, 255, 0.95) 100%);
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-snappy) ease;
      z-index: 40;
    }
    .panel-loading.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    .panel-loading__content {
      display: inline-flex;
      align-items: center;
      gap: 0.9rem;
      border-radius: 1rem;
      padding: 1rem 1.5rem;
      background: rgba(255, 255, 255, 0.88);
      box-shadow: 0 26px 55px rgba(15, 23, 42, 0.2);
      backdrop-filter: blur(14px);
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.01em;
    }
    .panel-loading__spinner {
      width: 1.65rem;
      height: 1.65rem;
      border-radius: 50%;
      border: 3px solid rgba(20, 90, 252, 0.22);
      border-top-color: var(--accent);
      animation: spin 0.9s linear infinite;
    }
    .panel-loading__message {
      margin: 0;
      font-size: 0.95rem;
    }
    .grid {
      display: grid;
      gap: 1rem;
      padding: 0 2rem 1.5rem;
      flex: 1 1 auto;
      min-height: 0;
      grid-auto-rows: minmax(0, 1fr);
    }
    .grid > * {
      min-width: 0;
    }
    .lo-grid {
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .lo-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow: hidden;
      flex: 1 1 auto;
      min-height: 0;
    }
    .lo-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 0.75rem;
    }
    .lo-card__heading {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      min-width: 0;
    }
    .lo-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .lo-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .sub-tab-nav {
      display: inline-flex;
      gap: 0.75rem;
      background: rgba(20, 90, 252, 0.08);
      padding: 0.4rem;
      border-radius: 999px;
      width: fit-content;
    }
    .sub-tab-button {
      border: none;
      background: transparent;
      font: inherit;
      font-weight: 600;
      color: var(--muted);
      padding: 0.45rem 1.25rem;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .sub-tab-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .sub-tab-button.active {
      background: var(--card-bg);
      color: var(--text);
      box-shadow: 0 6px 16px rgba(20, 90, 252, 0.15);
    }
    .sub-tab-panel {
      display: none;
      flex: 1 1 auto;
      min-height: 0;
    }
    .sub-tab-panel.active {
      display: flex;
      flex-direction: column;
    }
    .lo-card {
      min-height: calc(100vh - var(--sticky-header-offset) - 2.75rem);
    }

    .lo-table-container {
      position: relative;
      border-radius: 0.75rem;
      border: 1px solid rgba(27, 30, 40, 0.08);
      box-shadow: inset 0 0 0 1px rgba(27, 30, 40, 0.03), 0 12px 30px rgba(15, 23, 42, 0.08);
      background: #fff;
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      flex: 1 1 auto;
      min-height: 0;
      padding-bottom: 0;
      display: flex;
      overflow: hidden;
    }

    .lo-table-scroll {
      flex: 1 1 auto;
      min-height: 0;
      width: 100%;
      height: 100%;
      overflow-x: auto;
      overflow-y: auto;
      border-radius: inherit;
      scroll-padding-bottom: 96px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }
    .lo-table {
      width: 100%;
      min-width: 720px;
      min-width: max(720px, 100%);
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .lo-table thead th {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      color: var(--muted);
      font-weight: 600;
      padding: 0.65rem 0.75rem;
      text-align: right;
      position: sticky;
      top: 0;
      z-index: 5;
    }
    .lo-table thead th:first-child {
      text-align: left;
      z-index: 7;
    }
    .lo-table tbody td {
      padding: 0.35rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.08);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .lo-table tbody td.cell-date {
      text-align: left;
      font-weight: 600;
      color: var(--text);
    }
    .lo-table thead th:first-child,
    .lo-table tbody td.cell-date,
    .lo-table tfoot th:first-child {
      position: sticky;
      left: 0;
      z-index: 4;
    }
    .lo-table thead th:first-child {
      z-index: 6;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
    }
    .lo-table tbody td.cell-date {
      background: inherit;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.06);
    }
    .lo-table tbody tr:nth-child(odd) td.cell-date {
      background: rgba(226, 231, 244, 0.25);
    }
    .lo-table tbody tr:hover td.cell-date {
      background: rgba(41, 71, 137, 0.12);
    }
    .lo-table tfoot th:first-child {
      z-index: 5;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
    }
    .lo-table tbody tr:nth-child(odd) td {
      background: rgba(226, 231, 244, 0.25);
    }
    .lo-table tfoot {
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      box-shadow: 0 -8px 16px rgba(15, 23, 42, 0.08);
      z-index: 2;
    }
    .lo-table tfoot th,
    .lo-table tfoot td {
      position: sticky;
      bottom: 0;
      background: inherit;
      color: var(--text);
      font-weight: 600;
      padding: 0.55rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.14);
      z-index: 3;
    }
    .lo-table tfoot th {
      text-align: left;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.78rem;
    }
    .lo-table tfoot td {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .lo-table tfoot::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: -16px;
      height: 16px;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(244, 246, 251, 0) 0%, rgba(244, 246, 251, 0.9) 100%);
    }
    .card {
      position: relative;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.96) 0%, rgba(255, 255, 255, 0.88) 100%);
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: var(--shadow-soft);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(20, 90, 252, 0.08);
      overflow: hidden;
      transition:
        opacity var(--transition-gentle) ease,
        transform var(--transition-gentle) ease,
        box-shadow var(--transition-gentle) ease,
        background var(--transition-gentle) ease;
    }
    .card[data-animate='true'] {
      opacity: 0;
      transform: translateY(28px);
    }
    .card[data-animate='true'].is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    @media (hover: hover) {
      .card.is-visible:hover {
        transform: translateY(-4px);
        box-shadow: 0 32px 55px rgba(15, 23, 42, 0.18);
      }
    }
    .placeholder-card {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1 1 auto;
      justify-content: center;
      min-height: 240px;
    }
    .placeholder-card__title {
      margin: 0;
      font-size: 1.35rem;
      font-weight: 600;
      color: var(--text);
    }
    .placeholder-card__message {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
      max-width: 40ch;
    }
    .table-card {
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      min-height: 0;
    }
    .regular-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      flex: 1 1 auto;
      min-height: calc(100vh - var(--sticky-header-offset) - 2.75rem);
    }
    .regular-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      padding: 0;
      flex-wrap: wrap;
    }
    .regular-card__heading {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      min-width: 0;
    }
    .regular-card__controls {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-left: auto;
    }
    .filter-button {
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      border-radius: 999px;
      border: 1px solid rgba(20, 90, 252, 0.24);
      background: rgba(20, 90, 252, 0.12);
      color: var(--accent);
      font-weight: 600;
      font-size: 0.9rem;
      padding: 0.6rem 1.2rem;
      cursor: pointer;
      transition:
        background var(--transition-snappy) ease,
        border-color var(--transition-snappy) ease,
        color var(--transition-snappy) ease,
        box-shadow var(--transition-snappy) ease,
        transform var(--transition-snappy) ease;
    }
    .lo-card__filter-button--hidden {
      display: none !important;
    }
    .filter-button:hover,
    .filter-button:focus-visible {
      border-color: rgba(20, 90, 252, 0.45);
      background: rgba(20, 90, 252, 0.2);
      outline: none;
      box-shadow: 0 20px 38px rgba(20, 90, 252, 0.2);
      transform: translateY(-1px);
    }
    .filter-actions {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .filter-button[data-active="true"] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 24px 46px rgba(20, 90, 252, 0.32);
      transform: translateY(-1px);
    }
    .filter-button[aria-disabled="true"] {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }
    .filter-clear-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 2.25rem;
      height: 2.25rem;
      border-radius: 999px;
      border: none;
      background: rgba(27, 30, 40, 0.1);
      color: var(--muted);
      font-size: 1.25rem;
      line-height: 1;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }
    .filter-clear-button:hover,
    .filter-clear-button:focus-visible {
      background: rgba(27, 30, 40, 0.18);
      color: var(--text);
      box-shadow: 0 10px 22px rgba(27, 30, 40, 0.18);
      outline: none;
    }
    .filter-clear-button[hidden] {
      display: none !important;
    }
    .filter-clear-button:disabled {
      cursor: not-allowed;
      opacity: 0.45;
      box-shadow: none;
    }
    .regular-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .regular-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .regular-card__pagination {
      margin-left: auto;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.5rem;
      flex-wrap: wrap;
      min-height: 2.5rem;
    }
    .regular-card__pagination:empty {
      display: none;
    }
    .regular-card__pagination .dataTables_paginate {
      float: none;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }
    .regular-card__pagination .paginate_button {
      border-radius: 999px !important;
      padding: 0.35rem 0.85rem;
      border: 1px solid rgba(20, 90, 252, 0.25) !important;
      color: var(--accent) !important;
      background: #fff !important;
      font-weight: 600;
      transition: background 0.2s ease, border-color 0.2s ease;
    }
    .regular-card__pagination .paginate_button.current,
    .regular-card__pagination .paginate_button:hover,
    .regular-card__pagination .paginate_button:focus {
      background: rgba(20, 90, 252, 0.12) !important;
      border-color: rgba(20, 90, 252, 0.45) !important;
      outline: none;
    }
    .regular-card__pagination .paginate_button:focus-visible {
      box-shadow: 0 0 0 2px rgba(20, 90, 252, 0.35);
    }
    .regular-card__pagination .paginate_button.disabled,
    .regular-card__pagination .paginate_button.disabled:hover {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .regular-table-container {
      border-radius: 0.85rem;
      border: 1px solid rgba(64, 80, 120, 0.18);
      box-shadow: 0 12px 30px rgba(21, 32, 56, 0.12);
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
      overflow: visible;
      display: flex;
      flex-direction: column;
      padding-bottom: 1rem;
    }
    .regular-table-container .dataTables_wrapper {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .regular-table-container .dataTables_scroll {
      flex: 1 1 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    .regular-table-container .dataTables_scrollHead {
      flex: 0 0 auto;
    }
    .regular-table-container .dataTables_scrollBody {
      flex: 1 1 auto !important;
    }
    .regular-table-container .dataTables_scrollFoot {
      flex: 0 0 auto;
    }
    .regular-table-container table {
      margin-top: 0;
    }
    #tab-sku-summary .grid {
      grid-auto-rows: auto;
      align-content: flex-start;
    }
    .sku-card {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      flex: 1 1 auto;
      min-height: 0;
      max-height: clamp(24rem, calc(100vh - var(--sticky-header-offset) - 3.25rem), 60rem);
    }
    .sku-card__header {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      flex: 0 0 auto;
    }
    .sku-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .sku-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .sku-card__toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 0.1rem;
    }
    .sku-card__toolbar[data-active='false'] .sku-card__pagination {
      display: none;
    }
    .sku-card__pagination {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      margin-left: auto;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .sku-card__pagination[aria-hidden='true'] {
      display: none;
    }
    .sku-card__pagination-info {
      white-space: nowrap;
    }
    .sku-card__pagination-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.35rem 0.9rem;
      border-radius: 999px;
      border: 1px solid rgba(27, 30, 40, 0.12);
      background: #fff;
      color: var(--text);
      font: inherit;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease;
    }
    .sku-card__pagination-button:hover,
    .sku-card__pagination-button:focus {
      background: rgba(20, 90, 252, 0.12);
      border-color: rgba(20, 90, 252, 0.45);
      color: var(--accent);
    }
    .sku-card__pagination-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .sku-card__pagination-button[disabled] {
      opacity: 0.45;
      cursor: default;
      background: rgba(27, 30, 40, 0.06);
      border-color: rgba(27, 30, 40, 0.08);
      color: var(--muted);
    }
    .sku-card__pagination-button[disabled]:hover,
    .sku-card__pagination-button[disabled]:focus {
      background: rgba(27, 30, 40, 0.06);
      border-color: rgba(27, 30, 40, 0.08);
      color: var(--muted);
    }
    .new-product-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      flex: 1 1 auto;
      min-height: 0;
    }
    .new-product-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 1rem;
    }
    .new-product-card__heading {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      min-width: 0;
    }
    .new-product-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .new-product-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .new-product-grid {
      grid-template-columns: minmax(0, 1fr);
      gap: 1.25rem;
      grid-auto-rows: auto;
    }
    .new-product-table-container {
      border-radius: 0.85rem;
      border: 1px solid rgba(64, 80, 120, 0.18);
      box-shadow: 0 12px 30px rgba(21, 32, 56, 0.12);
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .new-product-table-wrapper {
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }
    .new-product-table-wrapper .dataTables_wrapper {
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    .new-product-table-wrapper .dataTables_scroll {
      flex: 1 1 auto;
      display: flex;
      flex-direction: column;
    }
    .new-product-table-wrapper .dataTables_scrollBody {
      flex: 1 1 auto !important;
    }
    .new-product-table {
      width: 100%;
      min-width: 720px;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .new-product-status {
      margin: 0 2rem 1rem;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .new-product-status[data-state='error'] {
      color: #c0392b;
    }
    .sku-table-container {
      border-radius: 0.85rem;
      border: 1px solid rgba(64, 80, 120, 0.18);
      box-shadow: 0 12px 30px rgba(21, 32, 56, 0.12);
      background: #fff;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .sku-table-scroll {
      flex: 1 1 auto;
      min-height: 0;
      overflow-x: auto;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    @media (max-width: 768px) {
      .sku-card {
        max-height: none;
      }
    }
    .sku-table {
      width: 100%;
      min-width: 720px;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    .sku-table thead th {
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 0.65rem 0.75rem;
      text-align: right;
      z-index: 3;
    }
    .sku-table thead th:first-child {
      text-align: left;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
      z-index: 4;
    }
    .sku-table tbody td,
    .sku-table tfoot td {
      padding: 0.45rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.08);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .sku-table tbody td:first-child {
      position: sticky;
      left: 0;
      text-align: left;
      font-weight: 600;
      color: var(--text);
      background: inherit;
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.06);
      z-index: 2;
    }
    .sku-table thead th:first-child,
    .sku-table tbody td:first-child,
    .sku-table tfoot th:first-child {
      background-clip: padding-box;
    }
    .sku-table tbody tr:nth-child(odd) td {
      background: rgba(226, 231, 244, 0.25);
    }
    .sku-table tbody tr:hover td {
      background: rgba(41, 71, 137, 0.12);
    }
    .sku-table tfoot {
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      box-shadow: 0 -8px 16px rgba(15, 23, 42, 0.08);
      z-index: 1;
    }
    .sku-table tfoot th,
    .sku-table tfoot td {
      padding: 0.55rem 0.75rem;
      border-top: 1px solid rgba(27, 30, 40, 0.14);
      font-weight: 600;
    }
    .sku-table tfoot th {
      position: sticky;
      left: 0;
      text-align: left;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      font-size: 0.78rem;
      color: var(--muted);
      box-shadow: 8px 0 12px rgba(15, 23, 42, 0.08);
      z-index: 2;
    }
    .sku-table th,
    .sku-table td {
      border-right: none;
      border-left: none;
    }
    .sku-table__message {
      text-align: left;
      padding: 1rem 0.75rem;
      font-weight: 600;
      color: var(--muted);
    }
    .dashboard-grid {
      padding: 0 2rem 1.5rem;
      gap: 1.25rem;
      grid-auto-rows: auto;
    }
    .dashboard-card {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .dashboard-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .dashboard-card__heading {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      min-width: 0;
      flex: 1 1 auto;
    }
    .dashboard-card__filter-button {
      margin-left: auto;
    }
    .dashboard-card__title {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    .dashboard-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .dashboard-table-container {
      border-radius: 0.85rem;
      border: 1px solid rgba(27, 30, 40, 0.1);
      background: #fff;
      box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
      overflow: hidden;
    }
    .dashboard-table-scroll {
      overflow-x: auto;
      overflow-y: hidden;
      max-width: 100%;
    }
    .dashboard-table {
      width: 100%;
      min-width: 960px;
      border-collapse: collapse;
      font-size: 0.85rem;
    }
    .dashboard-table thead th {
      position: sticky;
      top: 0;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 600;
      padding: 0.6rem 0.75rem;
      border-bottom: 2px solid rgba(27, 30, 40, 0.12);
      text-align: right;
      white-space: nowrap;
      z-index: 1;
    }
    .dashboard-table thead th:first-child {
      text-align: left;
    }
    .dashboard-table th,
    .dashboard-table td {
      border-left: none;
      border-right: none;
    }
    .dashboard-table tbody th,
    .dashboard-table tbody td,
    .dashboard-table tfoot th,
    .dashboard-table tfoot td {
      padding: 0.45rem 0.75rem;
      border-bottom: 1px solid rgba(27, 30, 40, 0.08);
      font-variant-numeric: tabular-nums;
    }
    .dashboard-table tbody th,
    .dashboard-table tfoot th {
      text-align: left;
      font-weight: 600;
      color: var(--text);
      white-space: nowrap;
    }
    .dashboard-table tbody td,
    .dashboard-table tfoot td {
      text-align: right;
      color: rgba(27, 30, 40, 0.92);
    }
    .dashboard-table tbody tr:nth-child(even) td,
    .dashboard-table tbody tr:nth-child(even) th {
      background: rgba(226, 231, 244, 0.35);
    }
    .dashboard-table tbody tr:hover td,
    .dashboard-table tbody tr:hover th {
      background: rgba(41, 71, 137, 0.12);
    }
    .dashboard-table__total {
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      font-weight: 700;
    }
    .dashboard-table__total th,
    .dashboard-table__total td {
      border-top: 2px solid rgba(27, 30, 40, 0.18);
    }
    .dashboard-table__value--error {
      color: #b42318;
      font-weight: 600;
    }
    .dashboard-table__message {
      text-align: center;
      padding: 1rem 0.75rem;
      color: var(--muted);
    }
    .kpi-title {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 0.35rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .kpi-value {
      font-size: 1.75rem;
      font-weight: 600;
    }
    canvas {
      width: 100% !important;
      height: auto !important;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
    }
    th, td {
      text-align: left;
      padding: 0.5rem 0.75rem;
      border-right: 1px solid rgba(27, 30, 40, 0.12);
    }
    th:first-child,
    td:first-child {
      border-left: 1px solid rgba(27, 30, 40, 0.12);
    }
    th:last-child,
    td:last-child {
      border-right: 1px solid rgba(27, 30, 40, 0.12);
    }
    th {
      color: var(--muted);
      font-size: 0.85rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .table-container {
      position: relative;
      overflow: visible;
      padding: 0;
      flex: 1 1 auto;
      min-height: 0;
      max-width: 100%;
      display: flex;
      flex-direction: column;
    }
    #tab-regular .table-card,
    #tab-main .table-card {
      background: transparent;
      box-shadow: none;
      padding: 0;
    }
    #tab-regular .table-container,
    #tab-main .table-container {
      padding-right: 0;
      padding-bottom: 0;
    }
    #regular-table,
    #main-table {
      border-collapse: separate;
      width: 100%;
    }
    #regular-table thead tr:last-child th,
    #regular-table tbody td,
    #main-table thead tr:last-child th,
    #main-table tbody td {
      text-align: left;
      padding: 0.3rem 0.65rem;
      border-right: 1px solid rgba(15, 23, 42, 0.08);
      line-height: 1.15;
      box-sizing: border-box;
    }
    #regular-table thead tr:last-child th,
    #main-table thead tr:last-child th {
      white-space: normal;
    }
    #regular-table tbody td,
    #main-table tbody td {
      white-space: nowrap;
    }
    #regular-table thead tr:last-child th:first-child,
    #regular-table tbody td:first-child,
    #main-table thead tr:last-child th:first-child,
    #main-table tbody td:first-child {
      border-left: 1px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table thead tr:last-child th:last-child,
    #regular-table tbody td:last-child,
    #main-table thead tr:last-child th:last-child,
    #main-table tbody td:last-child {
      border-right: 1px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table thead tr:last-child th,
    #main-table thead tr:last-child th {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #000;
      font-weight: 700;
      background: linear-gradient(180deg, #f6f8ff 0%, #e3e8f7 100%);
      border-bottom: 2px solid rgba(70, 97, 145, 0.35);
    }
    #regular-table tbody td,
    #main-table tbody td {
      font-size: 0.82rem;
      color: rgba(27, 30, 40, 0.9);
      font-weight: 500;
      background: #fff;
    }
    #regular-table tbody tr,
    #main-table tbody tr {
      border-bottom: 1px solid rgba(15, 23, 42, 0.06);
    }
    #regular-table tbody tr:nth-child(even) td,
    #main-table tbody tr:nth-child(even) td {
      background: rgba(226, 231, 244, 0.35);
    }
    #regular-table tbody tr:hover td,
    #main-table tbody tr:hover td {
      background: rgba(41, 71, 137, 0.12);
    }
    #main-table thead .table-preamble-row th {
      background: rgba(20, 90, 252, 0.06);
      border: 1px solid rgba(27, 30, 40, 0.12);
      color: var(--text);
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0;
      padding: 0.4rem 0.55rem;
      text-align: center;
      text-transform: none;
      white-space: nowrap;
    }
    #main-table thead .table-preamble-row th:first-child {
      text-align: left;
    }
    #main-table thead .table-preamble-row th.is-empty {
      background: rgba(27, 30, 40, 0.04);
      color: var(--muted);
      font-weight: 500;
    }
    #regular-table thead tr:last-child th.cell-numeric,
    #regular-table tbody td.cell-numeric,
    #main-table thead tr:last-child th.cell-numeric,
    #main-table tbody td.cell-numeric,
    .new-product-table thead th.cell-numeric,
    .new-product-table tbody td.cell-numeric {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    #regular-table tbody td.cell-qty,
    #main-table tbody td.cell-qty {
      font-weight: 600;
    }
    #regular-table thead tr:last-child th.is-filterable,
    #main-table thead tr:last-child th.is-filterable {
      cursor: pointer;
      position: relative;
    }
    #regular-table thead tr:last-child th.has-filter::after,
    #main-table thead tr:last-child th.has-filter::after {
      content: '';
      position: absolute;
      top: 0.6rem;
      right: 0.5rem;
      width: 0.35rem;
      height: 0.35rem;
      border-radius: 50%;
      background: var(--accent);
    }
    #regular-table td.cell-multiline,
    #main-table td.cell-multiline {
      white-space: normal !important;
      word-break: break-word;
      line-height: 1.35;
    }
    #regular-table th.cell-product,
    #regular-table td.cell-product,
    #main-table th.cell-product,
    #main-table td.cell-product {
      min-width: 24ch;
      max-width: 32ch;
      white-space: nowrap !important;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    #regular-table_wrapper,
    #main-table_wrapper {
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100%;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scroll,
    #main-table_wrapper .dataTables_scroll {
      border: none;
      border-radius: inherit;
      background: transparent;
      box-shadow: none;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      flex: 1 1 auto;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scrollHead,
    #main-table_wrapper .dataTables_scrollHead {
      position: relative;
      top: auto;
      z-index: 5;
      background: transparent;
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(21, 32, 56, 0.12);
      flex: 0 0 auto;
    }
    #regular-table_wrapper .dataTables_scrollHead table,
    #main-table_wrapper .dataTables_scrollHead table {
      border-collapse: separate;
      border-spacing: 0;
      width: 100% !important;
    }
    #regular-table_wrapper .dataTables_scrollBody,
    #main-table_wrapper .dataTables_scrollBody {
      border-top: none;
      overflow-y: auto !important;
      overflow-x: auto !important;
      flex: 1 1 auto;
      min-height: 0;
    }
    #regular-table_wrapper .dataTables_scrollBody table,
    #main-table_wrapper .dataTables_scrollBody table {
      border-collapse: separate;
      border-spacing: 0;
      background: #fff;
      width: 100% !important;
    }
    #regular-table_wrapper .dataTables_scrollFoot,
    #main-table_wrapper .dataTables_scrollFoot {
      position: sticky;
      bottom: 0;
      z-index: 12;
      background: linear-gradient(180deg, #f5f7ff 0%, #ebeffd 100%);
      box-shadow: 0 -10px 24px rgba(21, 32, 56, 0.1);
      flex: 0 0 auto;
    }
    #regular-table_wrapper .dataTables_scrollFoot th,
    #main-table_wrapper .dataTables_scrollFoot th {
      position: sticky;
      bottom: 0;
      z-index: 13;
      padding: 0.6rem 0.7rem;
      font-size: 0.82rem;
      font-weight: 700;
      color: #1b1e28;
      text-transform: uppercase;
      background: transparent;
      border-top: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-label,
    #main-table_wrapper .dataTables_scrollFoot th.cell-total-label {
      text-align: left;
      color: #2d3748;
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total,
    #main-table_wrapper .dataTables_scrollFoot th.cell-total {
      text-align: right;
    }
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-column,
    #main-table_wrapper .dataTables_scrollFoot th.cell-total-column {
      background: linear-gradient(180deg, #fff4d7 0%, #ffd897 100%);
      border-left: 2px solid rgba(15, 23, 42, 0.08);
      z-index: 14;
    }
    #regular-table_wrapper .dataTables_scrollHead th.cell-total-column,
    #regular-table_wrapper .dataTables_scrollBody td.cell-total-column,
    #regular-table_wrapper .dataTables_scrollFoot th.cell-total-column,
    #main-table_wrapper .dataTables_scrollHead th.cell-total-column,
    #main-table_wrapper .dataTables_scrollBody td.cell-total-column,
    #main-table_wrapper .dataTables_scrollFoot th.cell-total-column {
      position: sticky;
      right: 0;
      z-index: 4;
    }
    #regular-table_wrapper .dataTables_scrollHead th.cell-total-column,
    #main-table_wrapper .dataTables_scrollHead th.cell-total-column {
      z-index: 7;
      background: linear-gradient(180deg, #fef5e6 0%, #fbdca3 100%);
      color: #5c3c00;
      border-left: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollBody td.cell-total-column,
    #main-table_wrapper .dataTables_scrollBody td.cell-total-column {
      background: linear-gradient(180deg, #fffdf7 0%, #fff0d3 100%);
      font-weight: 600;
      border-left: 2px solid rgba(15, 23, 42, 0.08);
    }
    #regular-table_wrapper .dataTables_scrollBody tr:nth-child(even) td.cell-total-column,
    #main-table_wrapper .dataTables_scrollBody tr:nth-child(even) td.cell-total-column {
      background: linear-gradient(180deg, #fff9ec 0%, #ffe7bf 100%);
    }
    #regular-table_wrapper .dataTables_scrollBody tr:hover td.cell-total-column,
    #main-table_wrapper .dataTables_scrollBody tr:hover td.cell-total-column {
      background: rgba(41, 71, 137, 0.18);
    }
    .regular-table__footer,
    .main-table__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1.5rem;
      padding: 0.75rem 0.5rem 0;
      color: var(--muted);
      font-size: 0.85rem;
      flex-wrap: wrap;
    }
    .regular-table__footer:empty,
    .main-table__footer:empty {
      display: none;
    }
    .regular-table__footer .dataTables_paginate,
    .main-table__footer .dataTables_paginate {
      margin: 0 !important;
    }
    #regular-table_wrapper .dataTables_paginate .paginate_button,
    #main-table_wrapper .dataTables_paginate .paginate_button {
      border-radius: 999px;
    }
    table.dataTable thead .sorting,
    table.dataTable thead .sorting_asc,
    table.dataTable thead .sorting_desc,
    table.dataTable thead .sorting_asc_disabled,
    table.dataTable thead .sorting_desc_disabled {
      background-image: none !important;
    }
    table.dataTable thead > tr > th.sorting::before,
    table.dataTable thead > tr > th.sorting::after,
    table.dataTable thead > tr > th.sorting_asc::before,
    table.dataTable thead > tr > th.sorting_asc::after,
    table.dataTable thead > tr > th.sorting_desc::before,
    table.dataTable thead > tr > th.sorting_desc::after,
    table.dataTable thead > tr > th.sorting_asc_disabled::before,
    table.dataTable thead > tr > th.sorting_asc_disabled::after,
    table.dataTable thead > tr > th.sorting_desc_disabled::before,
    table.dataTable thead > tr > th.sorting_desc_disabled::after {
      display: none !important;
    }
    .header-menu {
      position: absolute;
      z-index: 20;
      min-width: 240px;
      max-width: 280px;
      background: var(--card-bg);
      border-radius: 0.75rem;
      box-shadow: 0 20px 35px rgba(15, 23, 42, 0.15);
      border: 1px solid rgba(27, 30, 40, 0.08);
      padding: 1rem;
      color: var(--text);
    }
    .header-menu.hidden {
      display: none;
    }
    .header-menu__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      margin-bottom: 0.75rem;
    }
    .header-menu__title {
      font-size: 0.95rem;
      margin: 0;
    }
    .header-menu__close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 1.25rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }
    .header-menu__section {
      margin-bottom: 1rem;
    }
    .header-menu__buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .header-menu__button {
      flex: 1 1 auto;
      border: 1px solid rgba(27, 30, 40, 0.12);
      background: #f8f9fe;
      color: var(--text);
      border-radius: 999px;
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .header-menu__button:hover,
    .header-menu__button:focus-visible {
      border-color: var(--accent);
      background: rgba(20, 90, 252, 0.12);
      outline: none;
    }
    .header-menu__search {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid rgba(27, 30, 40, 0.12);
      padding: 0.45rem 0.6rem;
      font: inherit;
    }
    .header-menu__options {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid rgba(27, 30, 40, 0.1);
      border-radius: 0.65rem;
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.4rem;
    }
    .header-menu__options:empty {
      display: none;
      border: none;
      padding: 0;
    }
    .header-menu__empty-message {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .header-menu__option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      color: var(--text);
      opacity: 0;
      transform: translateY(6px);
      transition:
        opacity var(--transition-snappy) ease,
        transform var(--transition-snappy) ease;
      transition-delay: calc(var(--stagger-index, 0) * 18ms);
    }
    .header-menu__option.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .header-menu__option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: var(--accent);
    }
    .header-menu__footer {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
    }
    .header-menu__apply,
    .header-menu__clear {
      flex: 1;
      border-radius: 999px;
      padding: 0.45rem 0.75rem;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid transparent;
    }
    .header-menu__apply {
      background: var(--accent);
      color: #fff;
    }
    .header-menu__apply:hover,
    .header-menu__apply:focus-visible {
      background: #0f46c2;
      outline: none;
    }
    .header-menu__clear {
      background: rgba(20, 90, 252, 0.12);
      color: var(--accent);
      border-color: rgba(20, 90, 252, 0.3);
    }
    .header-menu__clear:hover,
    .header-menu__clear:focus-visible {
      background: rgba(20, 90, 252, 0.2);
      outline: none;
    }
    .regular-filter,
    .main-filter {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
      opacity: 0;
      pointer-events: none;
      transition: opacity var(--transition-snappy) ease;
    }
    .regular-filter[hidden],
    .main-filter[hidden] {
      display: none !important;
    }
    .regular-filter.is-visible,
    .main-filter.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    .regular-filter.is-closing,
    .main-filter.is-closing {
      pointer-events: none;
    }
    .regular-filter__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.4);
      backdrop-filter: blur(4px);
      opacity: 0;
      transition: opacity var(--transition-snappy) ease;
    }
    .regular-filter.is-visible .regular-filter__backdrop,
    .main-filter.is-visible .regular-filter__backdrop {
      opacity: 1;
    }
    .regular-filter.is-closing .regular-filter__backdrop,
    .main-filter.is-closing .regular-filter__backdrop {
      opacity: 0;
    }
    .regular-filter__dialog {
      position: relative;
      z-index: 1;
      width: min(92vw, 420px);
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      background: var(--card-bg);
      border-radius: 0.85rem;
      box-shadow: 0 32px 60px rgba(15, 23, 42, 0.24);
      padding: 1.35rem;
      transform: translateY(16px) scale(0.97);
      opacity: 0;
      transition:
        transform var(--transition-gentle) ease,
        opacity var(--transition-gentle) ease;
    }
    .regular-filter.is-visible .regular-filter__dialog,
    .main-filter.is-visible .regular-filter__dialog {
      transform: translateY(0) scale(1);
      opacity: 1;
    }
    .regular-filter.is-closing .regular-filter__dialog,
    .main-filter.is-closing .regular-filter__dialog {
      transform: translateY(24px) scale(0.97);
      opacity: 0;
    }
    .regular-filter__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    .regular-filter__title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
    }
    .regular-filter__close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }
    .regular-filter__field {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }
    .regular-filter__field-options {
      display: inline-flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .regular-filter__field-button {
      border-radius: 999px;
      border: 1px solid rgba(27, 30, 40, 0.2);
      padding: 0.35rem 0.85rem;
      background: #fff;
      color: var(--muted);
      font: inherit;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .regular-filter__field-button:hover {
      border-color: rgba(20, 90, 252, 0.65);
      color: var(--text);
      box-shadow: 0 2px 6px rgba(20, 90, 252, 0.15);
    }
    .regular-filter__field-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .regular-filter__field-button[aria-pressed='true'] {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
      box-shadow: 0 4px 12px rgba(20, 90, 252, 0.35);
    }
    .regular-filter__field-button:disabled,
    .regular-filter__field-button[aria-disabled='true'] {
      opacity: 0.55;
      cursor: default;
      box-shadow: none;
    }
    .regular-filter__label {
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--muted);
    }
    .regular-filter__select,
    .regular-filter__search {
      border-radius: 0.65rem;
      border: 1px solid rgba(27, 30, 40, 0.15);
      padding: 0.55rem 0.7rem;
      font: inherit;
      background: #fff;
      color: var(--text);
    }
    .regular-filter__select:disabled,
    .regular-filter__search:disabled {
      background: rgba(244, 246, 251, 0.65);
      cursor: not-allowed;
    }
    .regular-filter__select-all {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text);
    }
    .regular-filter__select-all input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: var(--accent);
    }
    .regular-filter__options {
      flex: 1 1 auto;
      overflow-y: auto;
      border: 1px solid rgba(27, 30, 40, 0.12);
      border-radius: 0.75rem;
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
      min-height: 180px;
      background: rgba(244, 246, 251, 0.55);
    }
    .regular-filter__options:empty {
      padding: 0;
      border: none;
      min-height: 0;
    }
    .regular-filter__option {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      font-size: 0.88rem;
      color: var(--text);
      line-height: 1.3;
      opacity: 0;
      transform: translateY(8px);
      transition:
        opacity var(--transition-snappy) ease,
        transform var(--transition-snappy) ease;
      transition-delay: calc(var(--stagger-index, 0) * 24ms);
    }
    .regular-filter__option.is-visible {
      opacity: 1;
      transform: translateY(0);
    }
    .regular-filter__option input[type="checkbox"] {
      width: 1rem;
      height: 1rem;
      accent-color: var(--accent);
    }
    .regular-filter__empty {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .regular-filter__footer {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    .regular-filter__apply,
    .regular-filter__reset {
      flex: 1 1 auto;
      border-radius: 999px;
      padding: 0.6rem 1rem;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid transparent;
      position: relative;
      overflow: hidden;
      transition:
        background var(--transition-snappy) ease,
        border-color var(--transition-snappy) ease,
        color var(--transition-snappy) ease,
        box-shadow var(--transition-snappy) ease,
        transform var(--transition-snappy) ease;
    }
    .regular-filter__apply {
      background: var(--accent);
      color: #fff;
    }
    .regular-filter__apply:hover,
    .regular-filter__apply:focus-visible {
      background: #0f46c2;
      outline: none;
      box-shadow: 0 20px 38px rgba(20, 90, 252, 0.32);
      transform: translateY(-1px);
    }
    .regular-filter__reset {
      background: rgba(20, 90, 252, 0.14);
      color: var(--accent);
      border-color: rgba(20, 90, 252, 0.32);
    }
    .regular-filter__reset:hover,
    .regular-filter__reset:focus-visible {
      background: rgba(20, 90, 252, 0.22);
      outline: none;
      transform: translateY(-1px);
    }
    .regular-filter__apply[data-loading='true'],
    .regular-filter__reset[data-loading='true'] {
      color: transparent;
      pointer-events: none;
      padding-left: 2.6rem;
    }
    .regular-filter__apply[data-loading='true']::before,
    .regular-filter__reset[data-loading='true']::before {
      content: '';
      position: absolute;
      left: 0.9rem;
      top: 50%;
      width: 1.15rem;
      height: 1.15rem;
      border-radius: 50%;
      border: 2px solid currentColor;
      border-right-color: transparent;
      transform: translateY(-50%);
      animation: spin 0.9s linear infinite;
      opacity: 0.85;
    }
    .regular-filter__apply[data-loading='true']::before {
      border-color: rgba(255, 255, 255, 0.7);
      border-right-color: transparent;
    }
    .regular-filter__reset[data-loading='true']::before {
      border-color: rgba(20, 90, 252, 0.45);
      border-right-color: transparent;
    }
    .regular-filter__apply[data-loading='true']::after,
    .regular-filter__reset[data-loading='true']::after {
      content: attr(data-loading-label);
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .regular-filter__apply[data-loading='true']::after {
      color: #fff;
    }
    .regular-filter__reset[data-loading='true']::after {
      color: var(--accent);
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    @media (max-width: 768px) {
      .regular-card__header {
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
      }
      .regular-card__controls {
        width: 100%;
        justify-content: flex-start;
        margin-left: 0;
      }
      .regular-card__pagination {
        width: 100%;
        justify-content: flex-start;
        margin-left: 0;
      }
    }
    @media (max-width: 1280px) {
      .lo-grid {
        grid-template-columns: 1fr;
      }
    }
    @media (max-width: 900px) {
      .tab-nav {
        margin: 0 0 1.25rem;
        padding: 0.85rem 1.25rem;
        border-radius: 0 0 20px 20px;
      }
      .grid {
        padding: 0 1rem 1.5rem;
      }
      #regular-table_wrapper .dataTables_scrollHead {
        top: calc(var(--sticky-header-offset) - 24px);
      }
    }
    @keyframes tab-panel-in {
      from {
        opacity: 0;
        transform: translateY(24px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    @keyframes tab-panel-out {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-16px);
      }
    }
    @keyframes spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .tab-panel.active,
      .tab-panel.is-exiting,
      .regular-filter,
      .regular-filter__dialog,
      .panel-loading,
      .regular-filter__apply::before,
      .regular-filter__reset::before,
      .tab-nav__indicator,
      .card[data-animate='true'],
      .regular-filter__option,
      .header-menu__option {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      .card[data-animate='true'],
      .regular-filter__option,
      .header-menu__option {
        opacity: 1 !important;
        transform: none !important;
      }
    }
  </style>
</head>
<body>
  <nav class="tab-nav" aria-label="Dashboard views">
    <span class="tab-nav__indicator" aria-hidden="true"></span>
    <button class="tab-button" id="tab-sku-gap-button" type="button" data-tab="sku-gap" aria-controls="tab-sku-gap" aria-selected="false">SKU wise Gap</button>
    <button class="tab-button" id="tab-dashboard-button" type="button" data-tab="dashboard" aria-controls="tab-dashboard" aria-selected="false">Dashboard</button>
    <button class="tab-button" id="tab-platform-button" type="button" data-tab="platform" aria-controls="tab-platform" aria-selected="false">Store wise Daily Sales</button>
    <button class="tab-button" id="tab-new-product-button" type="button" data-tab="new-product" aria-controls="tab-new-product" aria-selected="false">New Product Performance</button>
    <button class="tab-button" id="tab-lo-button" type="button" data-tab="lo" aria-controls="tab-lo" aria-selected="false">LO - Sales &amp; Spend</button>
    <button class="tab-button" id="tab-main-button" type="button" data-tab="main" aria-controls="tab-main" aria-selected="false">Main</button>
    <button class="tab-button" id="tab-sku-summary-button" type="button" data-tab="sku-summary" aria-controls="tab-sku-summary" aria-selected="false">SKU wise summary</button>
    <button class="tab-button active" id="tab-regular-button" type="button" data-tab="regular" aria-controls="tab-regular" aria-selected="true">Regular</button>
  </nav>
  <div class="tab-panel" id="tab-sku-gap" data-tab="sku-gap" role="tabpanel" aria-labelledby="tab-sku-gap-button" aria-hidden="true">
    <section class="grid">
      <article class="card placeholder-card">
        <h2 class="placeholder-card__title">SKU wise Gap</h2>
        <p class="placeholder-card__message">A web version of the SKUWISE GAP sheet is not yet available. Please refer to the Excel workbook for the latest details.</p>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-lo" data-tab="lo" role="tabpanel" aria-labelledby="tab-lo-button" aria-hidden="true">
    <section class="grid lo-grid">
      <article class="card lo-card">
        <header class="lo-card__header">
          <div class="lo-card__heading">
            <h2 class="lo-card__title">Listing owner performance</h2>
            <p class="lo-card__subtitle">Daily sales and spend totals derived from regular data</p>
          </div>
          <div class="filter-actions">
            <button
              type="button"
              class="filter-clear-button"
              id="lo-filter-clear-button"
              aria-label="Clear listing owner filters"
              title="Clear filters"
              hidden
            >
              <span aria-hidden="true">&times;</span>
            </button>
            <button type="button" class="filter-button lo-card__filter-button" id="lo-filter-button" aria-haspopup="dialog" aria-expanded="false">Filters</button>
          </div>
        </header>
        <nav class="sub-tab-nav" aria-label="Listing owner metrics">
          <button class="sub-tab-button lo-sub-tab-button active" id="lo-sales-button" type="button" data-subtab="sales" aria-controls="lo-sales-panel" aria-selected="true">Sales</button>
          <button class="sub-tab-button lo-sub-tab-button" id="lo-spend-button" type="button" data-subtab="spend" aria-controls="lo-spend-panel" aria-selected="false">Spend</button>
        </nav>
        <div class="sub-tab-panel lo-sub-tab-panel active" id="lo-sales-panel" data-subtab="sales" role="region" aria-labelledby="lo-sales-button">
          <div class="table-container lo-table-container">
            <div class="lo-table-scroll">
              <table id="lo-sales-table" class="lo-table"></table>
            </div>
          </div>
        </div>
        <div class="sub-tab-panel lo-sub-tab-panel" id="lo-spend-panel" data-subtab="spend" role="region" aria-labelledby="lo-spend-button" aria-hidden="true">
          <div class="table-container lo-table-container">
            <div class="lo-table-scroll">
              <table id="lo-spend-table" class="lo-table"></table>
            </div>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-platform" data-tab="platform" role="tabpanel" aria-labelledby="tab-platform-button" aria-hidden="true">
    <section class="grid">
      <article class="card lo-card">
        <header class="lo-card__header">
          <div class="lo-card__heading">
            <h2 class="lo-card__title">Store wise Daily Sales</h2>
            <p class="lo-card__subtitle">Daily sales and NET totals grouped by store from regular data</p>
          </div>
          <div class="filter-actions">
            <button
              type="button"
              class="filter-clear-button"
              id="platform-filter-clear-button"
              aria-label="Clear store filters"
              title="Clear filters"
              hidden
            >
              <span aria-hidden="true">&times;</span>
            </button>
            <button type="button" class="filter-button lo-card__filter-button" id="platform-filter-button" aria-haspopup="dialog" aria-expanded="false">Filters</button>
          </div>
        </header>
        <nav class="sub-tab-nav" aria-label="Store metrics">
          <button class="sub-tab-button platform-tab-button active" id="platform-sales-button" type="button" data-subtab="sales" aria-controls="platform-sales-panel" aria-selected="true">Sales</button>
          <button class="sub-tab-button platform-tab-button" id="platform-net-button" type="button" data-subtab="net" aria-controls="platform-net-panel" aria-selected="false">NET</button>
        </nav>
        <div class="sub-tab-panel platform-tab-panel active" id="platform-sales-panel" data-subtab="sales" role="region" aria-labelledby="platform-sales-button">
          <div class="table-container lo-table-container">
            <div class="lo-table-scroll">
              <table id="platform-sales-table" class="lo-table"></table>
            </div>
          </div>
        </div>
        <div class="sub-tab-panel platform-tab-panel" id="platform-net-panel" data-subtab="net" role="region" aria-labelledby="platform-net-button" aria-hidden="true">
          <div class="table-container lo-table-container">
            <div class="lo-table-scroll">
              <table id="platform-net-table" class="lo-table"></table>
            </div>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-new-product" data-tab="new-product" role="tabpanel" aria-labelledby="tab-new-product-button" aria-hidden="true">
    <div class="new-product-status" id="new-product-status" role="status" hidden></div>
    <section class="grid new-product-grid">
      <article class="card new-product-card">
        <header class="new-product-card__header">
          <div class="new-product-card__heading">
            <h2 class="new-product-card__title">New product targets vs performance</h2>
            <p class="new-product-card__subtitle" id="new-product-target-subtitle">Pivot metrics derived from the Main sheet dataset</p>
          </div>
          <div class="filter-actions">
            <button
              type="button"
              class="filter-clear-button"
              id="new-product-target-filter-clear-button"
              aria-label="Clear new product filters"
              title="Clear filters"
              hidden
            >
              <span aria-hidden="true">&times;</span>
            </button>
            <button type="button" class="filter-button" id="new-product-target-filter-button" aria-haspopup="dialog" aria-expanded="false">Filter rows</button>
          </div>
        </header>
        <div class="new-product-table-container">
          <div class="new-product-table-wrapper">
            <table id="new-product-target-table" class="display new-product-table" style="width:100%"></table>
          </div>
        </div>
      </article>
      <article class="card new-product-card">
        <header class="new-product-card__header">
          <div class="new-product-card__heading">
            <h2 class="new-product-card__title">New product targets vs performance (pivot 2)</h2>
            <p class="new-product-card__subtitle" id="new-product-secondary-subtitle">Pivot metrics derived from the Main sheet dataset</p>
          </div>
          <div class="filter-actions">
            <button
              type="button"
              class="filter-clear-button"
              id="new-product-secondary-filter-clear-button"
              aria-label="Clear new product filters"
              title="Clear filters"
              hidden
            >
              <span aria-hidden="true">&times;</span>
            </button>
            <button type="button" class="filter-button" id="new-product-secondary-filter-button" aria-haspopup="dialog" aria-expanded="false">Filter rows</button>
          </div>
        </header>
        <div class="new-product-table-container">
          <div class="new-product-table-wrapper">
            <table id="new-product-secondary-table" class="display new-product-table" style="width:100%"></table>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-sku-summary" data-tab="sku-summary" role="tabpanel" aria-labelledby="tab-sku-summary-button" aria-hidden="true">
    <section class="grid">
      <article class="card sku-card">
        <header class="sku-card__header">
          <h2 class="sku-card__title">SKU wise summary</h2>
          <p class="sku-card__subtitle">Pivoted averages, fees, and totals by SKU directly from the workbook</p>
          <div class="sku-card__toolbar" data-active="false">
            <div class="filter-actions">
              <button
                type="button"
                class="filter-clear-button"
                id="sku-filter-clear-button"
                aria-label="Clear SKU summary filters"
                title="Clear filters"
                hidden
              >
                <span aria-hidden="true">&times;</span>
              </button>
              <button type="button" class="filter-button sku-card__filter-button" id="sku-filter-button" aria-haspopup="dialog" aria-expanded="false">Filters</button>
            </div>
            <div class="sku-card__pagination" id="sku-summary-pagination" aria-label="SKU wise summary pagination" aria-hidden="true"></div>
          </div>
        </header>
        <div class="table-container sku-table-container">
          <div class="sku-table-scroll">
            <table id="sku-summary-table" class="sku-table"></table>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-dashboard" data-tab="dashboard" role="tabpanel" aria-labelledby="tab-dashboard-button" aria-hidden="true">
    <section class="grid dashboard-grid">
      <article class="card dashboard-card">
        <header class="dashboard-card__header">
          <div class="dashboard-card__heading">
            <h2 class="dashboard-card__title">Name wise targets &amp; performance</h2>
            <p class="dashboard-card__subtitle">Aggregated Main sheet totals grouped by NAME (Excel dashboard pivot 1)</p>
          </div>
          <div class="filter-actions">
            <button
              type="button"
              class="filter-clear-button"
              id="dashboard-filter-clear-button"
              aria-label="Clear dashboard filters"
              title="Clear filters"
              hidden
            >
              <span aria-hidden="true">&times;</span>
            </button>
            <button
              type="button"
              class="filter-button dashboard-card__filter-button"
              id="dashboard-filter-button"
              aria-haspopup="dialog"
              aria-expanded="false"
              data-active="false"
            >
              Filters
            </button>
          </div>
        </header>
        <div class="dashboard-table-container">
          <div class="dashboard-table-scroll">
            <table id="dashboard-table-name" class="dashboard-table"></table>
          </div>
        </div>
      </article>
      <article class="card dashboard-card">
        <header class="dashboard-card__header">
          <div class="dashboard-card__heading">
            <h2 class="dashboard-card__title">eBay performance snapshot</h2>
            <p class="dashboard-card__subtitle">Main sheet eBay metrics grouped by EBAY owner (Excel dashboard pivot 2)</p>
          </div>
        </header>
        <div class="dashboard-table-container">
          <div class="dashboard-table-scroll">
            <table id="dashboard-table-ebay" class="dashboard-table"></table>
          </div>
        </div>
      </article>
      <article class="card dashboard-card">
        <header class="dashboard-card__header">
          <div class="dashboard-card__heading">
            <h2 class="dashboard-card__title">Website performance snapshot</h2>
            <p class="dashboard-card__subtitle">Website-focused metrics grouped by WEBSITE lead (Excel dashboard pivot 3)</p>
          </div>
        </header>
        <div class="dashboard-table-container">
          <div class="dashboard-table-scroll">
            <table id="dashboard-table-website" class="dashboard-table"></table>
          </div>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel" id="tab-main" data-tab="main" role="tabpanel" aria-labelledby="tab-main-button" aria-hidden="true">
    <section class="grid">
      <article class="card regular-card main-card">
        <header class="regular-card__header">
          <div class="regular-card__heading">
            <h2 class="regular-card__title">Main Performance</h2>
            <p class="regular-card__subtitle">Detailed metrics sourced from the Main worksheet</p>
          </div>
          <div class="regular-card__controls">
            <div class="filter-actions">
              <button
                type="button"
                class="filter-clear-button"
                id="main-filter-clear-button"
                aria-label="Clear main filters"
                title="Clear filters"
                hidden
              >
                <span aria-hidden="true">&times;</span>
              </button>
              <button type="button" class="regular-card__filter-button filter-button" id="main-filter-button" aria-haspopup="dialog" aria-expanded="false" data-active="false">Filters</button>
            </div>
            <div class="regular-card__pagination" id="main-table-pagination" aria-label="Main table pagination"></div>
          </div>
        </header>
        <div class="table-container regular-table-container">
          <table id="main-table" class="display" style="width:100%"></table>
        </div>
      </article>
    </section>
  </div>
  <div class="tab-panel active" id="tab-regular" data-tab="regular" role="tabpanel" aria-labelledby="tab-regular-button" aria-hidden="false">
    <section class="grid">
      <article class="card regular-card">
        <header class="regular-card__header">
          <div class="regular-card__heading">
            <h2 class="regular-card__title">Regular Performance</h2>
            <p class="regular-card__subtitle">Detailed order and spend metrics across all listings</p>
          </div>
          <div class="regular-card__controls">
            <div class="filter-actions">
              <button
                type="button"
                class="filter-clear-button"
                id="regular-filter-clear-button"
                aria-label="Clear regular filters"
                title="Clear filters"
                hidden
              >
                <span aria-hidden="true">&times;</span>
              </button>
              <button type="button" class="regular-card__filter-button filter-button" id="regular-filter-button" aria-haspopup="dialog" aria-expanded="false" data-active="false">Filters</button>
            </div>
            <div class="regular-card__pagination" id="regular-table-pagination" aria-label="Regular table pagination"></div>
          </div>
        </header>
        <div class="table-container regular-table-container">
          <table id="regular-table" class="display" style="width:100%"></table>
        </div>
      </article>
    </section>
  </div>
  <div class="regular-filter" id="new-product-target-filter" hidden aria-hidden="true">
    <div class="regular-filter__backdrop"></div>
    <div class="regular-filter__dialog" role="dialog" aria-modal="true" aria-labelledby="new-product-target-filter-title">
      <div class="regular-filter__header">
        <h3 class="regular-filter__title" id="new-product-target-filter-title">Filter pivot rows</h3>
        <button type="button" class="regular-filter__close" aria-label="Close filters">&times;</button>
      </div>
      <div class="regular-filter__field">
        <span class="regular-filter__label" id="new-product-target-filter-field-label">Field</span>
        <div class="regular-filter__field-options" id="new-product-target-filter-field-options" role="group" aria-labelledby="new-product-target-filter-field-label"></div>
      </div>
      <div class="regular-filter__options" id="new-product-target-filter-options" role="group" aria-label="Filter values"></div>
      <p class="regular-filter__empty" id="new-product-target-filter-empty" hidden>No filter values available</p>
      <div class="regular-filter__footer">
        <button type="button" class="regular-filter__reset" id="new-product-target-filter-reset">Reset</button>
        <button type="button" class="regular-filter__apply" id="new-product-target-filter-apply">Apply</button>
      </div>
    </div>
  </div>
  <div class="regular-filter" id="new-product-secondary-filter" hidden aria-hidden="true">
    <div class="regular-filter__backdrop"></div>
    <div class="regular-filter__dialog" role="dialog" aria-modal="true" aria-labelledby="new-product-secondary-filter-title">
      <div class="regular-filter__header">
        <h3 class="regular-filter__title" id="new-product-secondary-filter-title">Filter pivot rows</h3>
        <button type="button" class="regular-filter__close" aria-label="Close filters">&times;</button>
      </div>
      <div class="regular-filter__field">
        <span class="regular-filter__label" id="new-product-secondary-filter-field-label">Field</span>
        <div class="regular-filter__field-options" id="new-product-secondary-filter-field-options" role="group" aria-labelledby="new-product-secondary-filter-field-label"></div>
      </div>
      <div class="regular-filter__options" id="new-product-secondary-filter-options" role="group" aria-label="Filter values"></div>
      <p class="regular-filter__empty" id="new-product-secondary-filter-empty" hidden>No filter values available</p>
      <div class="regular-filter__footer">
        <button type="button" class="regular-filter__reset" id="new-product-secondary-filter-reset">Reset</button>
        <button type="button" class="regular-filter__apply" id="new-product-secondary-filter-apply">Apply</button>
      </div>
    </div>
  </div>
  <div class="regular-filter main-filter" id="main-filter" hidden aria-hidden="true">
    <div class="regular-filter__backdrop"></div>
    <div class="regular-filter__dialog" role="dialog" aria-modal="true" aria-labelledby="main-filter-title">
      <div class="regular-filter__header">
        <h3 class="regular-filter__title" id="main-filter-title">Filter main data</h3>
        <button type="button" class="regular-filter__close" aria-label="Close filters">&times;</button>
      </div>
      <div class="regular-filter__field">
        <label class="regular-filter__label" for="main-filter-column">Column</label>
        <select id="main-filter-column" class="regular-filter__select"></select>
      </div>
      <div class="regular-filter__field">
        <label class="regular-filter__label" for="main-filter-search">Search</label>
        <input id="main-filter-search" class="regular-filter__search" type="search" placeholder="Search values" autocomplete="off" />
      </div>
      <label class="regular-filter__select-all" for="main-filter-select-all">
        <input type="checkbox" id="main-filter-select-all" />
        <span>Select all</span>
      </label>
      <div class="regular-filter__options" id="main-filter-options" role="group" aria-label="Filter values"></div>
      <p class="regular-filter__empty" id="main-filter-empty" hidden>No matches found</p>
      <div class="regular-filter__footer">
        <button type="button" class="regular-filter__reset" id="main-filter-reset">Reset</button>
        <button type="button" class="regular-filter__apply" id="main-filter-apply">Apply</button>
      </div>
    </div>
  </div>
  <div class="regular-filter" id="regular-filter" hidden aria-hidden="true">
    <div class="regular-filter__backdrop"></div>
    <div class="regular-filter__dialog" role="dialog" aria-modal="true" aria-labelledby="regular-filter-title">
      <div class="regular-filter__header">
        <h3 class="regular-filter__title" id="regular-filter-title">Filter regular data</h3>
        <button type="button" class="regular-filter__close" aria-label="Close filters">&times;</button>
      </div>
      <div class="regular-filter__field">
        <label class="regular-filter__label" for="regular-filter-column">Column</label>
        <select id="regular-filter-column" class="regular-filter__select"></select>
      </div>
      <div class="regular-filter__field">
        <label class="regular-filter__label" for="regular-filter-search">Search</label>
        <input id="regular-filter-search" class="regular-filter__search" type="search" placeholder="Search values" autocomplete="off" />
      </div>
      <label class="regular-filter__select-all" for="regular-filter-select-all">
        <input type="checkbox" id="regular-filter-select-all" />
        <span>Select all</span>
      </label>
      <div class="regular-filter__options" id="regular-filter-options" role="group" aria-label="Filter values"></div>
      <p class="regular-filter__empty" id="regular-filter-empty" hidden>No matches found</p>
      <div class="regular-filter__footer">
        <button type="button" class="regular-filter__reset" id="regular-filter-reset">Reset</button>
        <button type="button" class="regular-filter__apply" id="regular-filter-apply">Apply</button>
      </div>
    </div>
  </div>
  <script>
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanels = document.querySelectorAll('.tab-panel');
    const tabNavElement = document.querySelector('.tab-nav');
    const tabNavIndicatorElement = tabNavElement ? tabNavElement.querySelector('.tab-nav__indicator') : null;
    let indicatorPreviousLeft = null;
    const loSubTabButtons = document.querySelectorAll('.lo-sub-tab-button');
    const loSubTabPanels = document.querySelectorAll('.lo-sub-tab-panel');
    const platformSubTabButtons = document.querySelectorAll('.platform-tab-button');
    const platformSubTabPanels = document.querySelectorAll('.platform-tab-panel');
    const loFilterButtonElement = document.getElementById('lo-filter-button');
    const loFilterClearButtonElement = document.getElementById('lo-filter-clear-button');
    const platformFilterButtonElement = document.getElementById('platform-filter-button');
    const platformFilterClearButtonElement = document.getElementById('platform-filter-clear-button');
    const dashboardFilterButtonElement = document.getElementById('dashboard-filter-button');
    const dashboardFilterClearButtonElement = document.getElementById('dashboard-filter-clear-button');
    const newProductStatusElement = document.getElementById('new-product-status');
    const skuFilterClearButtonElement = document.getElementById('sku-filter-clear-button');
    const mainFilterClearButtonElement = document.getElementById('main-filter-clear-button');
    const regularFilterClearButtonElement = document.getElementById('regular-filter-clear-button');

    const reduceMotionQuery = typeof window.matchMedia === 'function' ? window.matchMedia('(prefers-reduced-motion: reduce)') : null;
    let shouldReduceMotion = reduceMotionQuery ? reduceMotionQuery.matches : false;

    const animatedCards = Array.from(document.querySelectorAll('.card'));
    let cardObserver = null;

    function revealCardElement(card) {
      if (!(card instanceof HTMLElement)) {
        return;
      }
      card.classList.add('is-visible');
      if (cardObserver) {
        cardObserver.unobserve(card);
      }
    }

    if ('IntersectionObserver' in window) {
      cardObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              revealCardElement(entry.target);
            }
          });
        },
        { root: null, threshold: 0.18, rootMargin: '0px 0px -12%' },
      );
    }

    animatedCards.forEach((card) => {
      if (!(card instanceof HTMLElement)) {
        return;
      }
      card.setAttribute('data-animate', 'true');
      if (shouldReduceMotion || !cardObserver) {
        revealCardElement(card);
      } else {
        cardObserver.observe(card);
      }
    });

    if (reduceMotionQuery) {
      const handleReduceMotionChange = (event) => {
        shouldReduceMotion = event.matches;
        if (shouldReduceMotion) {
          animatedCards.forEach((card) => revealCardElement(card));
        } else if (cardObserver) {
          animatedCards.forEach((card) => {
            if (card instanceof HTMLElement && !card.classList.contains('is-visible')) {
              cardObserver.observe(card);
            }
          });
        }
      };
      if (typeof reduceMotionQuery.addEventListener === 'function') {
        reduceMotionQuery.addEventListener('change', handleReduceMotionChange);
      } else if (typeof reduceMotionQuery.addListener === 'function') {
        reduceMotionQuery.addListener(handleReduceMotionChange);
      }
    }

    const PANEL_TRANSITION_DURATION = 340;
    const FILTER_TRANSITION_DURATION = 320;
    const BUTTON_BUSY_TIMEOUT = 420;

    let regularTable;
    let regularTableInitialised = false;
    let regularTableFooterValues = [];
    let regularTableNumericColumnSet = new Set();
    let regularTableAugmentedDataset = null;
    let regularDatasetCache = null;
    let regularDatasetPromise = null;
    let mainTable;
    let mainTableInitialised = false;
    let mainTableFooterValues = [];
    let mainTableNumericColumnSet = new Set();
    let mainTableAugmentedDataset = null;
    let mainDatasetCache = null;
    let mainDatasetPromise = null;
    let loTablesInitialised = false;
    let platformTablesInitialised = false;
    let spendPivotCache = null;
    let spendPivotPromise = null;
    let skuSummaryInitialised = false;
    let skuSummaryPivotCache = null;
    let skuSummaryPivotPromise = null;
    let skuSummaryCurrentPage = 1;
    let skuSummaryPageSize = 25;
    let skuSummaryTotalRows = 0;
    let mainDashboardInitialised = false;
    let mainDashboardPivotCache = null;
    let dashboardPivotPromise = null;
    let activeTabId = null;
    let newProductInitialised = false;
    let newProductPivotCache = null;
    let newProductPivotPromise = null;

    const NUMERIC_COLUMN_EXCLUSIONS = new Set(['ORDER NO', 'PLAIN ORDER NO', 'ORDER #', 'ORDER NO.', 'CHECKOUT']);
    const ZERO_DECIMAL_COLUMNS = new Set(['qty', 'order no', 'plain order no', 'order no.', 'order #']);
    const numberFormatter = new Intl.NumberFormat('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
    const integerFormatter = new Intl.NumberFormat('en-US', { maximumFractionDigits: 0 });
    const displayDateFormatter = new Intl.DateTimeFormat('en-US', { month: '2-digit', day: '2-digit' });
    const TOTAL_ROW_LABEL = 'Grand Total';

    let columnValueOptions = [];
    let columnFilters = {};
    let mainColumnValueOptions = [];
    let mainColumnFilters = {};
    let regularFilterButtonElement = null;
    let regularFilterContainerElement = null;
    let regularFilterColumnSelect = null;
    let regularFilterSearchInput = null;
    let regularFilterOptionsElement = null;
    let regularFilterEmptyElement = null;
    let regularFilterSelectAllInput = null;
    let regularFilterApplyButton = null;
    let regularFilterResetButton = null;
    let regularFilterCloseButton = null;
    let mainFilterButtonElement = null;
    let mainFilterContainerElement = null;
    let mainFilterColumnSelect = null;
    let mainFilterSearchInput = null;
    let mainFilterOptionsElement = null;
    let mainFilterEmptyElement = null;
    let mainFilterSelectAllInput = null;
    let mainFilterApplyButton = null;
    let mainFilterResetButton = null;
    let mainFilterCloseButton = null;
    let regularFilterActiveColumnIndex = null;
    let regularFilterSelection = new Set();
    let regularFilterSearchTerm = '';
    let regularFilterInitialised = false;
    let regularFilterEligibleColumns = [];
    let regularFilterButtons = [];
    let regularFilterClearButtons = [];
    let activeRegularFilterTrigger = null;
    let mainFilterActiveColumnIndex = null;
    let mainFilterSelection = new Set();
    let mainFilterSearchTerm = '';
    let mainFilterInitialised = false;
    let mainFilterEligibleColumns = [];
    let mainFilterButtons = [];
    let mainFilterClearButtons = [];
    let activeMainFilterTrigger = null;
    let totalColumnIndex = -1;
    let mainTotalColumnIndex = -1;
    let headerMenuElement;
    let activeHeaderCell = null;
    let activeColumnIndex = null;
    const headerClickHandlers = new WeakMap();
    const HEADER_HEIGHT = 44;
    const ROW_HEIGHT = 34;
    const MIN_VISIBLE_ROWS = 5;
    const TABLE_BOTTOM_MARGIN = 18;
    const LO_TABLE_BOTTOM_MARGIN = 24;
    const MIN_LO_TABLE_HEIGHT = 320;
    const REGULAR_TABLE_FOOTER_MIN_SPACE = 128;
    const REGULAR_TABLE_FOOTER_EXTRA_GAP = 24;
    const DEFAULT_REGULAR_TABLE_RESERVED_SPACE = TABLE_BOTTOM_MARGIN + REGULAR_TABLE_FOOTER_MIN_SPACE;
    const REGULAR_TABLE_PAGE_LENGTH = 200;
    const SHOW_REGULAR_TOTAL_ROW = true;
    const REGULAR_FILTER_MAX_UNIQUE_VALUES = 350;
    const EXCEL_WORKBOOK_PATH = '../09%20GROSS%20PROCEED%20SEP-25%20COMBINE.xlsx';
    const EXCEL_REGULAR_SHEET_CANDIDATES = [
      'REGULAR SEP-25',
      'Regular Sep-25',
      'REGULAR',
      'Regular',
    ];
    const EXCEL_MAIN_SHEET_CANDIDATES = ['Main', 'MAIN'];
    const EXCEL_KEY_COLUMN_NAMES = ['ORDER NO', 'Order No', 'ORDER NO.', 'ORDER #', 'Plain Order No'];
    const EXCEL_MAIN_KEY_COLUMN_NAMES = ['SKU', 'Sr. No.', 'NAME', 'DC LIST'];
    const NEW_PRODUCT_FILTER_FIELDS = [
      { id: 'row', label: 'Row labels', type: 'row', columnIndex: 0 },
      { id: 'new-old', label: 'NEW/OLD', type: 'attribute' },
    ];
    const NEW_PRODUCT_DEFAULT_NEW_OLD_SELECTION = ['NEW24', 'NEW25'];
    const NEW_PRODUCT_PIVOT_CONFIGS = [
      {
        id: 'new-product-target',
        tableId: 'new-product-target-table',
        filterButtonId: 'new-product-target-filter-button',
        filterContainerId: 'new-product-target-filter',
        filterOptionsId: 'new-product-target-filter-options',
        filterFieldOptionsId: 'new-product-target-filter-field-options',
        filterFieldLabelId: 'new-product-target-filter-field-label',
        filterApplyId: 'new-product-target-filter-apply',
        filterResetId: 'new-product-target-filter-reset',
        filterEmptyId: 'new-product-target-filter-empty',
        filterTitleId: 'new-product-target-filter-title',
        filterClearButtonId: 'new-product-target-filter-clear-button',
        subtitleId: 'new-product-target-subtitle',
        filterFieldDefinitions: NEW_PRODUCT_FILTER_FIELDS,
      },
      {
        id: 'new-product-secondary',
        tableId: 'new-product-secondary-table',
        filterButtonId: 'new-product-secondary-filter-button',
        filterContainerId: 'new-product-secondary-filter',
        filterOptionsId: 'new-product-secondary-filter-options',
        filterFieldOptionsId: 'new-product-secondary-filter-field-options',
        filterFieldLabelId: 'new-product-secondary-filter-field-label',
        filterApplyId: 'new-product-secondary-filter-apply',
        filterResetId: 'new-product-secondary-filter-reset',
        filterEmptyId: 'new-product-secondary-filter-empty',
        filterTitleId: 'new-product-secondary-filter-title',
        filterClearButtonId: 'new-product-secondary-filter-clear-button',
        subtitleId: 'new-product-secondary-subtitle',
        filterFieldDefinitions: NEW_PRODUCT_FILTER_FIELDS,
      },
    ];
    const NEW_PRODUCT_DATASET_PIVOT_DEFINITIONS = [
      {
        groupColumn: 'AMZ',
        columns: [
          { source: 'TOTAL TARGET SALES', header: 'Sum of TOTAL TARGET SALES' },
          { source: 'Desired Rev Till Date', header: 'Sum of Desired Rev Till Date' },
          { source: 'ACHIVED REV', header: 'Sum of ACHIVED REV' },
          { source: 'Diff in rev', header: 'Sum of Diff in rev' },
          { source: 'Desired IP till Date', header: 'Sum of Desired IP till Date' },
          { source: 'Achieved IP', header: 'Sum of Achieved IP' },
          { source: 'Diff in IP', header: 'Sum of Diff in IP' },
          { source: 'ADVT SPEND', header: 'Sum of ADVT SPEND' },
        ],
        metadata: {
          segmentLabel: 'Channel',
          segmentSelection: 'AMZ (Main sheet)',
        },
      },
      {
        groupColumn: 'EBAY2',
        columns: [
          { source: 'TOTAL TARGET SALES2', header: 'Sum of TOTAL TARGET SALES2' },
          { source: 'Desired Rev Till Date2', header: 'Sum of Desired Rev Till Date2' },
          { source: 'ACHIVED REV2', header: 'Sum of ACHIVED REV2' },
          { source: 'Diff in rev2', header: 'Sum of Diff in rev2' },
          { source: 'Desired IP till Date2', header: 'Sum of Desired IP till Date2' },
          { source: 'Achieved IP2', header: 'Sum of Achieved IP2' },
          { source: 'Diff in IP2', header: 'Sum of Diff in IP2' },
          { source: 'ADVT SPEND2', header: 'Sum of ADVT SPEND2' },
        ],
        metadata: {
          segmentLabel: 'Channel',
          segmentSelection: 'EBAY2 (Main sheet)',
        },
      },
    ];
    const newProductTableFilterRegistry = new Map();
    let newProductFilterHookRegistered = false;
    const DASHBOARD_PIVOT_CONFIGS = [
      {
        id: 'name',
        tableId: 'dashboard-table-name',
        groupColumn: 'NAME',
        sheetGroupColumn: 'Row Labels',
        displayLabel: 'Name',
        columns: [
          { source: 'TOTAL TARGET SALES', sheetHeader: 'Sum of TOTAL TARGET SALES', header: 'Sum of TOTAL TARGET SALES' },
          { source: 'Desired Rev Till Date', sheetHeader: 'Sum of Desired Rev Till Date', header: 'Sum of Desired Rev Till Date' },
          { source: 'ACHIVED REV', sheetHeader: 'Sum of ACHIVED REV', header: 'Sum of ACHIVED REV' },
          { source: 'Diff in rev', sheetHeader: 'Sum of Diff in rev', header: 'Sum of Diff in rev' },
          { source: 'Desired IP till Date', sheetHeader: 'Sum of Desired IP till Date', header: 'Sum of Desired IP till Date' },
          { source: 'Achieved IP', sheetHeader: 'Sum of Achieved IP', header: 'Sum of Achieved IP' },
          { source: 'Diff in IP', sheetHeader: 'Sum of Diff in IP', header: 'Sum of Diff in IP' },
          { source: 'ADVT SPEND', sheetHeader: 'Sum of ADVT SPEND', header: 'Sum of ADVT SPEND' },
          {
            source: 'A- Ad Spend %',
            sheetHeader: 'Sum of A- Ad Spend %',
            header: 'Sum of A- Ad Spend %',
            computed: {
              type: 'ratio',
              numerator: 'ADVT SPEND',
              denominator: 'REV ACH TILL DATE',
              asPercentage: true,
            },
          },
          { source: 'Storage Fees', sheetHeader: 'Sum of Storage Fees', header: 'Sum of Storage Fees' },
          { source: '% of Ip Ach', sheetHeader: 'Sum of % of Ip Ach', header: 'Sum of % of Ip Ach' },
          { source: 'REV ACH TILL DATE', sheetHeader: 'Sum of REV ACH TILL DATE', header: 'Sum of REV ACH TILL DATE' },
          { source: 'IP ACH TILL DATE', sheetHeader: 'Sum of IP ACH TILL DATE', header: 'Sum of IP ACH TILL DATE' },
        ],
      },
      {
        id: 'ebay',
        tableId: 'dashboard-table-ebay',
        groupColumn: 'EBAY',
        sheetGroupColumn: 'Row Labels',
        displayLabel: 'eBay',
        columns: [
          { source: 'TOTAL TARGET SALES2', sheetHeader: 'Sum of TOTAL TARGET SALES2', header: 'Sum of TOTAL TARGET SALES2' },
          { source: 'Desired Rev Till Date2', sheetHeader: 'Sum of Desired Rev Till Date2', header: 'Sum of Desired Rev Till Date2' },
          { source: 'ACHIVED REV2', sheetHeader: 'Sum of ACHIVED REV2', header: 'Sum of ACHIVED REV2' },
          { source: 'Diff in rev2', sheetHeader: 'Sum of Diff in rev2', header: 'Sum of Diff in rev2' },
          { source: 'Desired IP till Date2', sheetHeader: 'Sum of Desired IP till Date2', header: 'Sum of Desired IP till Date2' },
          { source: 'Achieved IP2', sheetHeader: 'Sum of Achieved IP2', header: 'Sum of Achieved IP2' },
          { source: 'Diff in IP2', sheetHeader: 'Sum of Diff in IP2', header: 'Sum of Diff in IP2' },
          { source: 'ADVT SPEND2', sheetHeader: 'Sum of ADVT SPEND2', header: 'Sum of ADVT SPEND2' },
          {
            source: 'Ad Spend %',
            sheetHeader: 'Sum of Ad Spend %',
            header: 'Sum of Ad Spend %',
            computed: {
              type: 'ratio',
              numerator: 'ADVT SPEND2',
              denominator: 'REV ACH TILL DATE(EBAY)',
              asPercentage: true,
            },
          },
          { source: 'Storage Fees2', sheetHeader: 'Sum of Storage Fees2', header: 'Sum of Storage Fees2' },
          { source: '% of Ip Ach(ebay)', sheetHeader: 'Sum of % of Ip Ach(ebay)', header: 'Sum of % of Ip Ach(ebay)' },
          { source: 'REV ACH TILL DATE(EBAY)', sheetHeader: 'Sum of REV ACH TILL DATE(EBAY)', header: 'Sum of REV ACH TILL DATE(EBAY)' },
          { source: 'IP ACH TILL DATE(EBAY)', sheetHeader: 'Sum of IP ACH TILL DATE(EBAY)', header: 'Sum of IP ACH TILL DATE(EBAY)' },
        ],
      },
      {
        id: 'website',
        tableId: 'dashboard-table-website',
        groupColumn: 'Website',
        sheetGroupColumn: 'Row Labels',
        displayLabel: 'Website',
        columns: [
          { source: 'TOTAL TARGET SALES3', sheetHeader: 'Sum of TOTAL TARGET SALES3', header: 'Sum of TOTAL TARGET SALES3' },
          { source: 'Desired Rev Till Date3', sheetHeader: 'Sum of Desired Rev Till Date3', header: 'Sum of Desired Rev Till Date3' },
          { source: 'ACHIVED REV3', sheetHeader: 'Sum of ACHIVED REV3', header: 'Sum of ACHIVED REV3' },
          { source: 'Diff in rev3', sheetHeader: 'Sum of Diff in rev3', header: 'Sum of Diff in rev3' },
          { source: 'Desired IP till Date3', sheetHeader: 'Sum of Desired IP till Date3', header: 'Sum of Desired IP till Date3' },
          { source: 'Achieved IP3', sheetHeader: 'Sum of Achieved IP3', header: 'Sum of Achieved IP3' },
          { source: 'Diff in IP3', sheetHeader: 'Sum of Diff in IP3', header: 'Sum of Diff in IP3' },
          { source: 'ADVT SPEND3', sheetHeader: 'Sum of ADVT SPEND3', header: 'Sum of ADVT SPEND3' },
          {
            source: 'AD SPEND%(WEBSITE)',
            sheetHeader: 'Sum of AD SPEND%(WEBSITE)',
            header: 'Sum of AD SPEND%(WEBSITE)',
            computed: {
              type: 'ratio',
              numerator: 'ADVT SPEND3',
              denominator: 'REV ACH TILL DATE(WEBSITE)',
              asPercentage: true,
            },
          },
          { source: 'Storage Fees3', sheetHeader: 'Sum of Storage Fees3', header: 'Sum of Storage Fees3' },
          { source: '% of IP ACH(WEBSITE)', sheetHeader: 'Sum of % of IP ACH(WEBSITE)', header: 'Sum of % of IP ACH(WEBSITE)' },
          { source: 'REV ACH TILL DATE(WEBSITE)', sheetHeader: 'Sum of REV ACH TILL DATE(WEBSITE)', header: 'Sum of REV ACH TILL DATE(WEBSITE)' },
          { source: 'ACH IP TILL DATE(WEBSITE)', sheetHeader: 'Sum of ACH IP TILL DATE(WEBSITE)', header: 'Sum of ACH IP TILL DATE(WEBSITE)' },
        ],
      },
    ];
    const EXCEL_DEFAULT_HEADER_SEARCH_VALUES = EXCEL_KEY_COLUMN_NAMES;
    const EXCEL_MAX_BLANK_ROWS = 2000;

    function getTabPanelElement(tabId) {
      if (!tabId) {
        return null;
      }
      return Array.from(tabPanels).find((panel) => panel.dataset.tab === tabId) || null;
    }

    function showTabPanel(panel) {
      if (!panel) {
        return;
      }
      panel.classList.remove('is-exiting');
      panel.classList.add('active');
      panel.setAttribute('aria-hidden', 'false');
    }

    function hideTabPanel(panel) {
      if (!panel) {
        return;
      }
      if (!panel.classList.contains('active') && !panel.classList.contains('is-exiting')) {
        panel.setAttribute('aria-hidden', 'true');
        return;
      }
      panel.classList.remove('active');
      panel.setAttribute('aria-hidden', 'true');
      panel.classList.add('is-exiting');
      function finalize() {
        panel.classList.remove('is-exiting');
        panel.removeEventListener('animationend', handleAnimationEnd);
      }
      function handleAnimationEnd(event) {
        if (event.target !== panel) {
          return;
        }
        finalize();
      }
      panel.addEventListener('animationend', handleAnimationEnd);
      window.setTimeout(finalize, PANEL_TRANSITION_DURATION);
    }

    function updateTabIndicator(targetTab) {
      if (!tabNavElement || !tabNavIndicatorElement) {
        return;
      }
      const activeButton = Array.from(tabButtons).find((button) => button.dataset.tab === targetTab);
      if (!activeButton) {
        tabNavElement.classList.remove('has-active-indicator');
        indicatorPreviousLeft = null;
        if (tabNavIndicatorElement) {
          tabNavIndicatorElement.removeAttribute('data-direction');
        }
        return;
      }
      const applyPosition = () => {
        const navRect = tabNavElement.getBoundingClientRect();
        const buttonRect = activeButton.getBoundingClientRect();
        const left = buttonRect.left - navRect.left;
        const top = buttonRect.top - navRect.top;
        if (indicatorPreviousLeft !== null) {
          const direction = left >= indicatorPreviousLeft ? 'right' : 'left';
          tabNavIndicatorElement.setAttribute('data-direction', direction);
        } else {
          tabNavIndicatorElement.setAttribute('data-direction', 'right');
        }
        tabNavIndicatorElement.style.setProperty('--indicator-left', `${left}px`);
        tabNavIndicatorElement.style.setProperty('--indicator-top', `${top}px`);
        tabNavIndicatorElement.style.setProperty('--indicator-width', `${buttonRect.width}px`);
        tabNavIndicatorElement.style.setProperty('--indicator-height', `${buttonRect.height}px`);
        tabNavElement.classList.add('has-active-indicator');
        indicatorPreviousLeft = left;
      };
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(applyPosition);
      } else {
        applyPosition();
      }
    }

    function setTabPanelLoading(tabId, isLoading, message = 'Loading…') {
      const panel = getTabPanelElement(tabId);
      if (!panel) {
        return;
      }
      let overlay = panel.querySelector(':scope > .panel-loading');
      if (!overlay) {
        overlay = document.createElement('div');
        overlay.className = 'panel-loading';
        overlay.setAttribute('aria-hidden', 'true');
        overlay.innerHTML = `
          <div class="panel-loading__content" role="status">
            <span class="panel-loading__spinner" aria-hidden="true"></span>
            <span class="panel-loading__message"></span>
          </div>
        `;
        panel.appendChild(overlay);
      }
      const messageElement = overlay.querySelector('.panel-loading__message');
      if (messageElement && typeof message === 'string' && message.trim().length) {
        messageElement.textContent = message;
      }
      const shouldShow = Boolean(isLoading);
      overlay.classList.toggle('is-visible', shouldShow);
      overlay.setAttribute('aria-hidden', shouldShow ? 'false' : 'true');
    }

    function showFilterContainer(element) {
      if (!element) {
        return;
      }
      element.classList.remove('is-closing');
      element.removeAttribute('hidden');
      element.setAttribute('aria-hidden', 'false');
      requestAnimationFrame(() => {
        element.classList.add('is-visible');
      });
    }

    function hideFilterContainer(element) {
      if (!element) {
        return;
      }
      element.setAttribute('aria-hidden', 'true');
      element.classList.add('is-closing');
      element.classList.remove('is-visible');
      const dialog = element.querySelector('.regular-filter__dialog');
      const transitionTarget = dialog || element;
      let completed = false;
      function finalize() {
        if (completed) {
          return;
        }
        completed = true;
        element.classList.remove('is-closing');
        element.setAttribute('hidden', '');
        transitionTarget.removeEventListener('transitionend', handleTransitionEnd);
      }
      function handleTransitionEnd(event) {
        if (event.target !== transitionTarget) {
          return;
        }
        finalize();
      }
      transitionTarget.addEventListener('transitionend', handleTransitionEnd);
      window.setTimeout(finalize, FILTER_TRANSITION_DURATION + 60);
    }

    function flashButtonBusy(button, fallbackLabel = 'Applying…') {
      if (!button) {
        return;
      }
      const existingLabel = button.getAttribute('data-loading-label');
      const label = existingLabel && existingLabel.trim().length ? existingLabel : fallbackLabel;
      button.setAttribute('data-loading-label', label);
      button.dataset.loading = 'true';
      window.setTimeout(() => {
        delete button.dataset.loading;
        if (!existingLabel) {
          button.removeAttribute('data-loading-label');
        }
      }, BUTTON_BUSY_TIMEOUT);
    }

    function animateOptionList(container, selector) {
      if (!container) {
        return;
      }
      const options = Array.from(container.querySelectorAll(selector));
      if (!options.length) {
        return;
      }
      options.forEach((option) => {
        option.classList.remove('is-visible');
        option.style.removeProperty('--stagger-index');
      });
      if (shouldReduceMotion) {
        options.forEach((option) => option.classList.add('is-visible'));
        return;
      }
      requestAnimationFrame(() => {
        options.forEach((option, index) => {
          option.style.setProperty('--stagger-index', index);
          option.classList.add('is-visible');
        });
      });
    }

    let loSalesOrderCache = [];
    let loDisplayNameOverridesCache = new Map();
    let loBaselineSpendPivot = null;
    let loSpendScalingData = null;
    let loBaselineAdSpendPivot = null;

    function normaliseSheetName(value) {
      if (typeof value !== 'string') {
        return '';
      }
      return value.replace(/[^0-9a-z]+/gi, '').toLowerCase();
    }

    function normaliseNewProductLabel(value) {
      if (value === null || value === undefined) {
        return '';
      }
      if (typeof value === 'string') {
        return value.trim().toUpperCase();
      }
      return String(value).trim().toUpperCase();
    }

    function normaliseNewProductStatus(value) {
      if (value === null || value === undefined) {
        return '';
      }
      if (typeof value === 'string') {
        return value.trim().toUpperCase();
      }
      return String(value).trim().toUpperCase();
    }

    function sortNewProductNewOldValues(values) {
      if (!Array.isArray(values) || !values.length) {
        return [];
      }
      const priorityOrder = new Map([
        ['NEW', -2],
        ['OLD', -1],
      ]);
      const normalise = (value) => {
        if (typeof value === 'string') {
          return value.trim().toUpperCase();
        }
        if (value === null || value === undefined) {
          return '';
        }
        return String(value).trim().toUpperCase();
      };
      return values
        .slice()
        .filter((value, index, source) => source.indexOf(value) === index)
        .sort((a, b) => {
          const normalisedA = normalise(a);
          const normalisedB = normalise(b);
          const priorityA = priorityOrder.has(normalisedA)
            ? priorityOrder.get(normalisedA)
            : Number.POSITIVE_INFINITY;
          const priorityB = priorityOrder.has(normalisedB)
            ? priorityOrder.get(normalisedB)
            : Number.POSITIVE_INFINITY;
          if (priorityA !== priorityB) {
            return priorityA - priorityB;
          }
          if (!normalisedA && !normalisedB) {
            return 0;
          }
          if (!normalisedA) {
            return 1;
          }
          if (!normalisedB) {
            return -1;
          }
          return normalisedA.localeCompare(normalisedB);
        });
    }

    function coerceCellValue(cell) {
      if (cell === null || cell === undefined) {
        return '';
      }
      if (typeof cell === 'number') {
        return Number.isFinite(cell) ? String(cell) : '';
      }
      if (typeof cell === 'boolean') {
        return cell ? 'TRUE' : 'FALSE';
      }
      const text = String(cell);
      return text.trim().length ? text : '';
    }

    function findWorksheetFromWorkbook(workbook, options = {}) {
      if (!workbook || !Array.isArray(workbook.SheetNames) || !workbook.SheetNames.length) {
        return { worksheet: null, sheetName: null };
      }
      const sheetNames = workbook.SheetNames;
      const normalisedEntries = sheetNames.map((name) => ({
        name,
        normalised: normaliseSheetName(name),
      }));
      const candidates = Array.isArray(options.candidates) && options.candidates.length
        ? options.candidates
        : EXCEL_REGULAR_SHEET_CANDIDATES;
      for (const candidate of candidates) {
        const normalised = normaliseSheetName(candidate);
        if (!normalised) {
          continue;
        }
        const exactMatch = normalisedEntries.find((entry) => entry.normalised === normalised);
        if (exactMatch) {
          return { worksheet: workbook.Sheets[exactMatch.name], sheetName: exactMatch.name };
        }
        const prefixMatch = normalisedEntries.find((entry) => entry.normalised.startsWith(normalised));
        if (prefixMatch) {
          return { worksheet: workbook.Sheets[prefixMatch.name], sheetName: prefixMatch.name };
        }
      }
      const fallbackPredicate = typeof options.fallbackPredicate === 'function'
        ? options.fallbackPredicate
        : (name) => normaliseSheetName(name).includes('regular');
      const inferred = fallbackPredicate
        ? normalisedEntries.find((entry) => fallbackPredicate(entry.name))
        : undefined;
      if (inferred) {
        return { worksheet: workbook.Sheets[inferred.name], sheetName: inferred.name };
      }
      const firstName = sheetNames[0];
      return { worksheet: workbook.Sheets[firstName], sheetName: firstName };
    }

    function buildDatasetFromWorksheet(worksheet, options = {}) {
      if (!worksheet) {
        throw new Error('Worksheet not found in workbook');
      }
      const rawRows = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        blankrows: false,
        defval: '',
        raw: true,
      });
      if (!Array.isArray(rawRows) || !rawRows.length) {
        throw new Error('Worksheet is empty');
      }
      const headerSearchValues = Array.isArray(options.headerSearchValues) && options.headerSearchValues.length
        ? options.headerSearchValues
        : EXCEL_DEFAULT_HEADER_SEARCH_VALUES;
      const headerSearchLower = headerSearchValues
        .map((value) => (typeof value === 'string' ? value.trim().toLowerCase() : ''))
        .filter((value) => value.length);

      let headerRow = null;
      let headerIndex = -1;
      const includeHeaderPreamble = options.includeHeaderPreamble === true;

      if (Number.isInteger(options.headerRowIndex)
        && options.headerRowIndex >= 0
        && options.headerRowIndex < rawRows.length) {
        headerIndex = options.headerRowIndex;
        headerRow = Array.isArray(rawRows[headerIndex]) ? rawRows[headerIndex] : [];
      } else {
        for (let i = 0; i < rawRows.length; i += 1) {
          const row = Array.isArray(rawRows[i]) ? rawRows[i] : [];
          const hasHeaderKey = row.some((value) => {
            if (typeof value !== 'string') {
              return false;
            }
            const normalised = value.trim().toLowerCase();
            if (!normalised) {
              return false;
            }
            return headerSearchLower.some((needle) => normalised.includes(needle));
          });
          if (hasHeaderKey) {
            headerRow = row;
            headerIndex = i;
            break;
          }
        }
      }
      if (!headerRow || headerIndex === -1) {
        throw new Error('Failed to locate header row in worksheet');
      }
      const headerCounts = new Map();
      const columns = headerRow.map((cell) => {
        const baseNameRaw = typeof cell === 'string' ? cell.trim() : cell;
        const baseName = baseNameRaw && String(baseNameRaw).trim().length ? String(baseNameRaw).trim() : 'Column';
        const count = (headerCounts.get(baseName) || 0) + 1;
        headerCounts.set(baseName, count);
        if (count === 1) {
          return baseName;
        }
        return `${baseName}${count}`;
      });
      const keyColumnCandidates = Array.isArray(options.keyColumnNames) && options.keyColumnNames.length
        ? options.keyColumnNames
        : EXCEL_KEY_COLUMN_NAMES;
      const keyColumnLookup = keyColumnCandidates
        .map((name) => (typeof name === 'string' ? name.trim().toLowerCase() : ''))
        .filter((name) => name.length);

      const keyColumnIndexes = columns.reduce((indexes, name, index) => {
        const normalized = typeof name === 'string' ? name.trim().toLowerCase() : '';
        if (keyColumnLookup.some((candidate) => candidate === normalized)) {
          indexes.push(index);
        }
        return indexes;
      }, []);
      let headerPreamble = null;
      if (includeHeaderPreamble && headerIndex > 0) {
        const columnCount = columns.length;
        const normalizedRows = [];
        for (let rowIndex = 0; rowIndex < headerIndex; rowIndex += 1) {
          const sourceRow = Array.isArray(rawRows[rowIndex]) ? rawRows[rowIndex] : [];
          const normalizedRow = [];
          for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
            normalizedRow.push(coerceCellValue(sourceRow[columnIndex]));
          }
          normalizedRows.push(normalizedRow);
        }
        const merges = Array.isArray(worksheet['!merges']) ? worksheet['!merges'] : [];
        const mergeEntries = [];
        merges.forEach((merge) => {
          if (!merge || typeof merge !== 'object') {
            return;
          }
          const startRef = merge.s || merge.start || {};
          const endRef = merge.e || merge.end || {};
          const startRow = Number.isFinite(startRef.r) ? startRef.r : 0;
          const endRow = Number.isFinite(endRef.r) ? endRef.r : startRow;
          if (startRow >= headerIndex || endRow >= headerIndex) {
            return;
          }
          const startCol = Number.isFinite(startRef.c) ? startRef.c : 0;
          if (startCol >= columnCount) {
            return;
          }
          const rawEndCol = Number.isFinite(endRef.c) ? endRef.c : startCol;
          const endCol = Math.min(columnCount - 1, rawEndCol);
          if (endCol < startCol) {
            return;
          }
          const rowSpan = Math.max(1, (endRow - startRow) + 1);
          const colSpan = Math.max(1, (endCol - startCol) + 1);
          mergeEntries.push({
            row: startRow,
            column: startCol,
            rowSpan,
            colSpan,
          });
        });
        if (normalizedRows.length) {
          headerPreamble = {
            rows: normalizedRows,
            merges: mergeEntries,
          };
        }
      }
      let blankRun = 0;
      const rows = [];
      for (let i = headerIndex + 1; i < rawRows.length; i += 1) {
        const sourceRow = Array.isArray(rawRows[i]) ? rawRows[i] : [];
        const normalisedRow = columns.map((_, columnIndex) => coerceCellValue(sourceRow[columnIndex]));
        const isBlankRow = normalisedRow.every((value) => value === '');
        if (isBlankRow) {
          blankRun += 1;
          if (blankRun > EXCEL_MAX_BLANK_ROWS) {
            break;
          }
          continue;
        }
        const hasKey = keyColumnIndexes.some((index) => {
          if (index < 0 || index >= normalisedRow.length) {
            return false;
          }
          const value = normalisedRow[index];
          if (value === null || value === undefined) {
            return false;
          }
          const trimmed = typeof value === 'string' ? value.trim() : String(value).trim();
          return trimmed !== '' && trimmed !== '-' && trimmed !== '--';
        });
        if (!hasKey) {
          blankRun += 1;
          if (blankRun > EXCEL_MAX_BLANK_ROWS) {
            break;
          }
          continue;
        }
        rows.push(normalisedRow);
        blankRun = 0;
      }
      const dataset = { columns, rows };
      if (headerPreamble) {
        dataset.headerPreamble = headerPreamble;
      }
      return dataset;
    }

    function loadDatasetFromExcel(options = {}) {
      if (typeof XLSX === 'undefined') {
        return Promise.reject(new Error('Excel parser library is not available'));
      }
      return fetch(EXCEL_WORKBOOK_PATH, { cache: 'no-store' })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unable to load Excel workbook');
          }
          return response.arrayBuffer();
        })
        .then((buffer) => {
          const workbook = XLSX.read(buffer, { type: 'array' });
          const { worksheet } = findWorksheetFromWorkbook(workbook, {
            candidates: options.sheetCandidates,
            fallbackPredicate: options.fallbackPredicate,
          });
          if (!worksheet) {
            throw new Error(options.errorMessage || 'Worksheet not found in workbook');
          }
          return buildDatasetFromWorksheet(worksheet, {
            headerRowIndex: options.headerRowIndex,
            headerSearchValues: options.headerSearchValues,
            keyColumnNames: options.keyColumnNames,
            includeHeaderPreamble: options.includeHeaderPreamble,
          });
        });
    }

    function loadDashboardPivotSectionsFromExcel() {
      if (typeof XLSX === 'undefined') {
        return Promise.reject(new Error('Excel parser library is not available'));
      }
      return fetch(EXCEL_WORKBOOK_PATH, { cache: 'no-store' })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unable to load Excel workbook');
          }
          return response.arrayBuffer();
        })
        .then((buffer) => {
          const workbook = XLSX.read(buffer, { type: 'array' });
          const { worksheet } = findWorksheetFromWorkbook(workbook, {
            candidates: EXCEL_MAIN_SHEET_CANDIDATES,
            fallbackPredicate: (name) => normaliseSheetName(name).includes('main'),
          });
          if (!worksheet) {
            throw new Error('Main worksheet not found in workbook');
          }
          const dataset = buildDatasetFromWorksheet(worksheet, {
            headerRowIndex: 3,
            headerSearchValues: ['SKU', 'DC LIST', 'TOTAL SALES'],
            keyColumnNames: EXCEL_MAIN_KEY_COLUMN_NAMES,
            includeHeaderPreamble: true,
          });
          mainDatasetCache = dataset;
          ensureMainFilterSetup(dataset);
          return buildDashboardPivotResultsFromDataset(dataset);
        });
    }

    function fetchDashboardPivotSections() {
      if (mainDashboardPivotCache instanceof Map && mainDashboardInitialised) {
        return Promise.resolve(mainDashboardPivotCache);
      }
      if (dashboardPivotPromise) {
        return dashboardPivotPromise;
      }
      dashboardPivotPromise = loadDashboardPivotSectionsFromExcel()
        .then((results) => {
          dashboardPivotPromise = null;
          return results;
        })
        .catch((error) => {
          dashboardPivotPromise = null;
          throw error;
        });
      return dashboardPivotPromise;
    }

    function fetchRegularDataset() {
      if (regularDatasetCache) {
        return Promise.resolve(regularDatasetCache);
      }
      if (regularDatasetPromise) {
        return regularDatasetPromise;
      }
      regularDatasetPromise = loadDatasetFromExcel({
        sheetCandidates: EXCEL_REGULAR_SHEET_CANDIDATES,
        fallbackPredicate: (name) => {
          const normalised = normaliseSheetName(name);
          return normalised.includes('regular') && normalised.includes('sep');
        },
        errorMessage: 'REGULAR SEP-25 worksheet not found in workbook',
      })
        .catch((excelError) => {
          console.error('Failed to load dataset from Excel:', excelError);
          return fetch('regular_sep25_data.json')
            .then((response) => {
              if (!response.ok) {
                throw new Error('Unable to load fallback dataset');
              }
              return response.json();
            });
        })
        .then((data) => {
          regularDatasetCache = data;
          return data;
        })
        .catch((error) => {
          regularDatasetPromise = null;
          throw error;
        });
      return regularDatasetPromise;
    }

    function fetchMainDataset() {
      if (mainDatasetCache) {
        return Promise.resolve(mainDatasetCache);
      }
      if (mainDatasetPromise) {
        return mainDatasetPromise;
      }
      mainDatasetPromise = loadDatasetFromExcel({
        sheetCandidates: EXCEL_MAIN_SHEET_CANDIDATES,
        fallbackPredicate: (name) => {
          const normalised = normaliseSheetName(name);
          return normalised.includes('main');
        },
        errorMessage: 'Main worksheet not found in workbook',
        headerRowIndex: 3,
        headerSearchValues: ['SKU', 'DC LIST', 'TOTAL SALES'],
        keyColumnNames: EXCEL_MAIN_KEY_COLUMN_NAMES,
        includeHeaderPreamble: true,
      })
        .then((data) => {
          mainDatasetCache = data;
          return data;
        })
        .catch((error) => {
          mainDatasetPromise = null;
          throw error;
        });
      return mainDatasetPromise;
    }

    function fetchSpendPivot() {
      if (spendPivotCache) {
        return Promise.resolve(spendPivotCache);
      }
      if (spendPivotPromise) {
        return spendPivotPromise;
      }
      const datasetSource = regularDatasetCache ? Promise.resolve(regularDatasetCache) : fetchRegularDataset();
      spendPivotPromise = datasetSource
        .then((dataset) => {
          const options = {};
          if (Array.isArray(loSalesOrderCache) && loSalesOrderCache.length) {
            options.normalizedOrder = loSalesOrderCache;
          }
          if (loDisplayNameOverridesCache instanceof Map && loDisplayNameOverridesCache.size) {
            options.displayNameOverrides = loDisplayNameOverridesCache;
          }
          const pivot = buildLoPivot(dataset, 'Ad Spend', options);
          spendPivotCache = pivot;
          return pivot;
        })
        .catch((error) => {
          spendPivotPromise = null;
          throw error;
        });
      return spendPivotPromise;
    }

    function fetchSkuSummaryPivot() {
      if (skuSummaryPivotCache) {
        return Promise.resolve(skuSummaryPivotCache);
      }
      if (skuSummaryPivotPromise) {
        return skuSummaryPivotPromise;
      }
      skuSummaryPivotPromise = fetch('sku_summary_pivot.json')
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unable to load SKU pivot');
          }
          return response.json();
        })
        .then((data) => {
          skuSummaryPivotCache = data;
          return data;
        })
        .catch((error) => {
          skuSummaryPivotPromise = null;
          throw error;
        });
      return skuSummaryPivotPromise;
    }

    function showNewProductStatus(message, state = 'info') {
      if (!newProductStatusElement) {
        return;
      }
      if (!message) {
        newProductStatusElement.textContent = '';
        newProductStatusElement.hidden = true;
        newProductStatusElement.removeAttribute('data-state');
        return;
      }
      newProductStatusElement.textContent = message;
      newProductStatusElement.hidden = false;
      if (state && state !== 'info') {
        newProductStatusElement.dataset.state = state;
      } else {
        newProductStatusElement.removeAttribute('data-state');
      }
    }

    function buildDatasetColumnLookup(columns) {
      const lookup = new Map();
      if (!Array.isArray(columns)) {
        return lookup;
      }
      columns.forEach((column, index) => {
        if (typeof column !== 'string') {
          return;
        }
        const key = column.trim().toLowerCase();
        if (key && !lookup.has(key)) {
          lookup.set(key, index);
        }
      });
      return lookup;
    }

    function buildNewProductPivotFromDataset(dataset, definition) {
      if (!dataset || !Array.isArray(dataset.columns) || !Array.isArray(dataset.rows)) {
        return null;
      }
      if (!definition || !definition.groupColumn || !Array.isArray(definition.columns)) {
        return null;
      }
      const columnLookup = buildDatasetColumnLookup(dataset.columns);
      const normalise = (value) => (typeof value === 'string' ? value.trim().toLowerCase() : '');
      const groupIndex = columnLookup.get(normalise(definition.groupColumn));
      if (groupIndex === undefined) {
        return null;
      }
      const metricDescriptors = [];
      const headers = [];
      definition.columns.forEach((column) => {
        if (!column || !column.source || !column.header) {
          return;
        }
        const datasetIndex = columnLookup.get(normalise(column.source));
        if (datasetIndex === undefined) {
          return;
        }
        metricDescriptors.push({ datasetIndex, header: column.header });
        headers.push(column.header);
      });
      if (!metricDescriptors.length) {
        return null;
      }
      const newOldIndex = columnLookup.get(normalise('NEW/OLD'));
      const groups = [];
      const groupLookup = new Map();
      const normalizedTotal = TOTAL_ROW_LABEL.toLowerCase();

      dataset.rows.forEach((row) => {
        if (!Array.isArray(row)) {
          return;
        }
        const rawLabel = groupIndex < row.length ? row[groupIndex] : null;
        if (isPlaceholderValue(rawLabel)) {
          return;
        }
        const label = typeof rawLabel === 'string'
          ? rawLabel.trim()
          : (rawLabel === null || rawLabel === undefined ? '' : String(rawLabel).trim());
        if (!label || label.toLowerCase() === normalizedTotal) {
          return;
        }
        const normalizedLabel = normaliseNewProductLabel(label);
        if (!normalizedLabel) {
          return;
        }
        let entry = groupLookup.get(normalizedLabel);
        if (!entry) {
          entry = {
            label,
            normalizedLabel,
            totals: new Array(metricDescriptors.length).fill(0),
            hasValue: new Array(metricDescriptors.length).fill(false),
            newOldValues: new Set(),
            newOldBreakdown: new Map(),
          };
          groupLookup.set(normalizedLabel, entry);
          groups.push(entry);
        }
        let newOldEntry = null;
        if (newOldIndex !== undefined && newOldIndex < row.length) {
          const rawNewOld = row[newOldIndex];
          const trimmed = typeof rawNewOld === 'string'
            ? rawNewOld.trim()
            : (rawNewOld === null || rawNewOld === undefined ? '' : String(rawNewOld).trim());
          const normalizedNewOld = normaliseNewProductStatus(trimmed);
          if (normalizedNewOld) {
            entry.newOldValues.add(trimmed);
            if (!entry.newOldBreakdown.has(normalizedNewOld)) {
              entry.newOldBreakdown.set(normalizedNewOld, {
                label: trimmed,
                normalizedLabel: normalizedNewOld,
                totals: new Array(metricDescriptors.length).fill(0),
                hasValue: new Array(metricDescriptors.length).fill(false),
              });
            }
            newOldEntry = entry.newOldBreakdown.get(normalizedNewOld);
          }
        }
        metricDescriptors.forEach((descriptor, descriptorIndex) => {
          if (!descriptor) {
            return;
          }
          const value = descriptor.datasetIndex < row.length ? row[descriptor.datasetIndex] : null;
          if (isPlaceholderValue(value)) {
            return;
          }
          const numericValue = parseNumericValue(value);
          if (numericValue !== null) {
            entry.totals[descriptorIndex] += numericValue;
            entry.hasValue[descriptorIndex] = true;
            if (newOldEntry) {
              newOldEntry.totals[descriptorIndex] += numericValue;
              newOldEntry.hasValue[descriptorIndex] = true;
            }
          }
        });
      });

      const rows = [];
      const rowAttributes = [];
      groups.forEach((entry) => {
        if (!entry.hasValue.some((value) => value)) {
          return;
        }
        const values = [entry.label];
        entry.totals.forEach((total, index) => {
          values.push(entry.hasValue[index] ? total : '');
        });
        rows.push(values);
        rowAttributes.push({
          label: entry.label,
          normalizedLabel: entry.normalizedLabel,
          newOld: new Set(entry.newOldValues),
          totals: entry.totals.slice(),
          hasValue: entry.hasValue.slice(),
          newOldBreakdown: (() => {
            const breakdown = new Map();
            entry.newOldBreakdown.forEach((value, key) => {
              breakdown.set(key, {
                label: value.label,
                normalizedLabel: value.normalizedLabel,
                totals: value.totals.slice(),
                hasValue: value.hasValue.slice(),
              });
            });
            return breakdown;
          })(),
        });
      });

      if (!rows.length) {
        return null;
      }

      return {
        columns: ['Row Labels', ...headers],
        rows,
        metadata: definition.metadata || null,
        rowAttributes,
      };
    }

    function buildNewProductPivotSectionsFromDataset(dataset) {
      return NEW_PRODUCT_DATASET_PIVOT_DEFINITIONS.map((definition) => buildNewProductPivotFromDataset(dataset, definition));
    }

    function cloneNewProductRowAttributes(attributes) {
      if (!Array.isArray(attributes)) {
        return [];
      }
      return attributes.map((attribute) => {
        if (!attribute || typeof attribute !== 'object') {
          return {
            label: '',
            normalizedLabel: '',
            newOld: new Set(),
            totals: [],
            hasValue: [],
            newOldBreakdown: new Map(),
          };
        }
        const breakdown = new Map();
        if (attribute.newOldBreakdown instanceof Map) {
          attribute.newOldBreakdown.forEach((value, key) => {
            if (!value || typeof value !== 'object') {
              return;
            }
            const totals = Array.isArray(value.totals) ? value.totals.slice() : [];
            const hasValue = Array.isArray(value.hasValue) ? value.hasValue.slice() : [];
            breakdown.set(key, {
              label: value.label || '',
              normalizedLabel: value.normalizedLabel || key,
              totals,
              hasValue,
            });
          });
        }
        return {
          label: attribute.label || '',
          normalizedLabel: attribute.normalizedLabel || normaliseNewProductLabel(attribute.label || ''),
          newOld: attribute.newOld instanceof Set ? new Set(attribute.newOld) : new Set(),
          totals: Array.isArray(attribute.totals) ? attribute.totals.slice() : [],
          hasValue: Array.isArray(attribute.hasValue) ? attribute.hasValue.slice() : [],
          newOldBreakdown: breakdown,
        };
      });
    }

    function loadNewProductPivotSectionsFromDataset() {
      const datasetSource = mainDatasetCache ? Promise.resolve(mainDatasetCache) : fetchMainDataset();
      return datasetSource.then((dataset) => {
        const sections = buildNewProductPivotSectionsFromDataset(dataset);
        const hasData = Array.isArray(sections)
          && sections.some((section) => Array.isArray(section?.rows) && section.rows.length);
        if (!hasData) {
          throw new Error('No new product pivot data available from the Main worksheet');
        }
        return sections;
      });
    }

    function fetchNewProductPivotSections() {
      if (Array.isArray(newProductPivotCache) && newProductPivotCache.length) {
        return Promise.resolve(newProductPivotCache);
      }
      if (newProductPivotPromise) {
        return newProductPivotPromise;
      }
      newProductPivotPromise = loadNewProductPivotSectionsFromDataset()
        .then((sections) => {
          newProductPivotCache = sections;
          newProductPivotPromise = null;
          return sections;
        })
        .catch((error) => {
          newProductPivotPromise = null;
          throw error;
        });
      return newProductPivotPromise;
    }


    function ensureNewProductFilterHook() {
      if (newProductFilterHookRegistered) {
        return;
      }
      $.fn.dataTable.ext.search.push((settings, data) => {
        if (!settings || !settings.sTableId) {
          return true;
        }
        const config = newProductTableFilterRegistry.get(settings.sTableId);
        if (!config) {
          return true;
        }
        const filterState = config.filterState;
        if (!filterState || !(filterState.fields instanceof Map)) {
          return true;
        }
        const newOldField = filterState.fields.get('new-old');
        if (newOldField && newOldField.activeSelection instanceof Set) {
          if (!newOldField.activeSelection.size) {
            return false;
          }
          const label = Array.isArray(data) ? data[0] : '';
          const normalizedLabel = normaliseNewProductLabel(label);
          const labelSet = config.rowLabelNewOldMap instanceof Map
            ? config.rowLabelNewOldMap.get(normalizedLabel)
            : null;
          if (!(labelSet instanceof Set) || !labelSet.size) {
            return false;
          }
          let matches = false;
          newOldField.activeSelection.forEach((value) => {
            if (labelSet.has(value)) {
              matches = true;
            }
          });
          return matches;
        }
        return true;
      });
      newProductFilterHookRegistered = true;
    }

    function ensureNewProductFilterState(config) {
      if (!config) {
        return null;
      }
      if (!Object.prototype.hasOwnProperty.call(config, 'defaultNewOldSelectionApplied')) {
        config.defaultNewOldSelectionApplied = false;
      }
      if (!config.filterState) {
        const definitionsSource = Array.isArray(config.filterFieldDefinitions) && config.filterFieldDefinitions.length
          ? config.filterFieldDefinitions
          : NEW_PRODUCT_FILTER_FIELDS;
        const definitions = definitionsSource.map((definition) => ({
          id: definition.id,
          label: definition.label || definition.id,
          type: definition.type || 'attribute',
          columnIndex: Number.isInteger(definition.columnIndex) ? definition.columnIndex : null,
        }));
        const fields = new Map();
        definitions.forEach((definition) => {
          fields.set(definition.id, {
            id: definition.id,
            label: definition.label,
            type: definition.type,
            columnIndex: definition.columnIndex,
            availableValues: [],
            activeSelection: null,
            pendingSelection: null,
          });
        });
        config.filterState = {
          definitions,
          fields,
          activeFieldId: definitions[0]?.id || null,
        };
      }
      const filterState = config.filterState;
      if (!config.defaultNewOldSelectionApplied) {
        const newOldField = filterState.fields.get('new-old');
        if (newOldField && !(newOldField.activeSelection instanceof Set)) {
          const initialSelection = NEW_PRODUCT_DEFAULT_NEW_OLD_SELECTION
            .map((value) => (typeof value === 'string' ? value.trim() : ''))
            .filter((value) => value.length > 0);
          if (initialSelection.length) {
            newOldField.activeSelection = new Set(initialSelection);
            config.defaultNewOldSelectionApplied = true;
          }
        }
      }
      return filterState;
    }

    function getActiveNewProductFilterField(config) {
      const filterState = ensureNewProductFilterState(config);
      if (!filterState) {
        return null;
      }
      let field = filterState.fields.get(filterState.activeFieldId);
      if (field && Array.isArray(field.availableValues) && field.availableValues.length) {
        return field;
      }
      const fallback = filterState.definitions.find((definition) => {
        const candidate = filterState.fields.get(definition.id);
        return candidate && Array.isArray(candidate.availableValues) && candidate.availableValues.length;
      });
      if (fallback) {
        filterState.activeFieldId = fallback.id;
        field = filterState.fields.get(fallback.id);
        return field;
      }
      return field || null;
    }

    function renderNewProductFilterFieldButtons(config) {
      if (!config || !config.filterFieldOptionsElement) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      if (!filterState) {
        config.filterFieldOptionsElement.innerHTML = '';
        return;
      }
      const buttonsMarkup = filterState.definitions
        .map((definition) => {
          const field = filterState.fields.get(definition.id);
          const hasValues = field && Array.isArray(field.availableValues) && field.availableValues.length > 0;
          const isActive = hasValues && filterState.activeFieldId === definition.id;
          const pressedAttr = isActive ? ' aria-pressed="true"' : ' aria-pressed="false"';
          const disabledAttr = hasValues ? '' : ' aria-disabled="true" disabled';
          const safeLabel = escapeHtml(definition.label || definition.id);
          return `<button type="button" class="regular-filter__field-button"${pressedAttr}${disabledAttr} data-field-id="${definition.id}">${safeLabel}</button>`;
        })
        .join('');
      config.filterFieldOptionsElement.innerHTML = buttonsMarkup;
      const buttons = config.filterFieldOptionsElement.querySelectorAll('button[data-field-id]');
      buttons.forEach((button) => {
        button.addEventListener('click', (event) => {
          event.preventDefault();
          const fieldId = button.getAttribute('data-field-id');
          if (!fieldId) {
            return;
          }
          const field = filterState.fields.get(fieldId);
          if (!field || !Array.isArray(field.availableValues) || !field.availableValues.length) {
            return;
          }
          filterState.activeFieldId = fieldId;
          renderNewProductFilterFieldButtons(config);
          renderNewProductFilterOptions(config);
        });
      });
    }

    function updateNewProductFilterButtonState(config) {
      if (!config) {
        return;
      }
      const button = config.filterButton || document.getElementById(config.filterButtonId);
      const clearButton = config.filterClearButton || (config.filterClearButtonId
        ? document.getElementById(config.filterClearButtonId)
        : null);
      if (!button) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      const hasValues = filterState
        ? Array.from(filterState.fields.values()).some((field) => Array.isArray(field.availableValues) && field.availableValues.length)
        : false;
      if (!hasValues) {
        button.setAttribute('aria-disabled', 'true');
        button.disabled = true;
        button.setAttribute('data-active', 'false');
        if (clearButton) {
          clearButton.hidden = true;
          clearButton.setAttribute('aria-hidden', 'true');
          clearButton.disabled = true;
        }
        return;
      }
      button.disabled = false;
      button.removeAttribute('aria-disabled');
      const isActive = filterState
        ? Array.from(filterState.fields.values()).some((field) => field.activeSelection instanceof Set && field.activeSelection.size > 0)
        : false;
      button.setAttribute('data-active', isActive ? 'true' : 'false');
      if (clearButton) {
        if (isActive) {
          clearButton.hidden = false;
          clearButton.removeAttribute('aria-hidden');
          clearButton.disabled = false;
        } else {
          clearButton.hidden = true;
          clearButton.setAttribute('aria-hidden', 'true');
          clearButton.disabled = true;
        }
      }
    }

    function computeNewProductRowValues(baseRow, attribute, normalizedNewOldSelection) {
      const safeRow = Array.isArray(baseRow) ? baseRow : [];
      const label = safeRow.length ? safeRow[0] : '';
      const metricCount = Math.max(0, safeRow.length - 1);
      if (!Array.isArray(normalizedNewOldSelection)) {
        const hasValues = (() => {
          if (!attribute || typeof attribute !== 'object') {
            return safeRow.slice(1).some((value) => !isPlaceholderValue(value));
          }
          if (Array.isArray(attribute.hasValue)) {
            return attribute.hasValue.some((flag) => Boolean(flag));
          }
          return safeRow.slice(1).some((value) => !isPlaceholderValue(value));
        })();
        return {
          row: safeRow.slice(),
          hasValues,
        };
      }
      if (!normalizedNewOldSelection.length) {
        return {
          row: [label, ...new Array(metricCount).fill('')],
          hasValues: false,
        };
      }
      const breakdown = attribute && attribute.newOldBreakdown instanceof Map ? attribute.newOldBreakdown : null;
      if (!breakdown || !breakdown.size) {
        return {
          row: [label, ...new Array(metricCount).fill('')],
          hasValues: false,
        };
      }
      const totals = new Array(metricCount).fill(0);
      const hasValueFlags = new Array(metricCount).fill(false);
      normalizedNewOldSelection.forEach((key) => {
        if (!key || !breakdown.has(key)) {
          return;
        }
        const entry = breakdown.get(key);
        if (!entry || typeof entry !== 'object') {
          return;
        }
        const entryTotals = Array.isArray(entry.totals) ? entry.totals : [];
        const entryHasValue = Array.isArray(entry.hasValue) ? entry.hasValue : [];
        entryTotals.forEach((value, index) => {
          if (!Number.isFinite(value)) {
            return;
          }
          totals[index] += value;
          if (entryHasValue[index] || value !== 0) {
            hasValueFlags[index] = true;
          }
        });
      });
      const hasValues = hasValueFlags.some((flag) => Boolean(flag));
      const computedRow = [label];
      for (let index = 0; index < metricCount; index += 1) {
        if (hasValueFlags[index]) {
          computedRow.push(totals[index]);
        } else {
          computedRow.push('');
        }
      }
      return {
        row: computedRow,
        hasValues,
      };
    }

    function updateNewProductTableFilters(config) {
      if (!config || !config.table) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      const rowField = filterState ? filterState.fields.get('row') : null;
      const newOldField = filterState ? filterState.fields.get('new-old') : null;
      const rowSelection = rowField ? rowField.activeSelection : null;
      const newOldSelection = newOldField ? newOldField.activeSelection : null;
      const rawRows = Array.isArray(config.rawRows) ? config.rawRows : [];
      const rowAttributes = Array.isArray(config.rowAttributes) ? config.rowAttributes : [];
      const columns = Array.isArray(config.columns) ? config.columns : [];
      const normalizedRowSelection = rowSelection instanceof Set
        ? new Set(Array.from(rowSelection).map((value) => normaliseNewProductLabel(value)))
        : null;
      const normalizedNewOldSelection = newOldSelection instanceof Set
        ? Array.from(newOldSelection)
          .map((value) => normaliseNewProductStatus(value))
          .filter((value) => value.length)
        : null;
      const filteredRows = [];
      rawRows.forEach((row, index) => {
        if (!Array.isArray(row) || !row.length) {
          return;
        }
        const label = row[0];
        const normalizedLabel = normaliseNewProductLabel(label);
        if (normalizedRowSelection instanceof Set) {
          if (!normalizedRowSelection.size) {
            return;
          }
          if (!normalizedRowSelection.has(normalizedLabel)) {
            return;
          }
        }
        const attribute = rowAttributes[index];
        const computed = computeNewProductRowValues(row, attribute, normalizedNewOldSelection);
        if (!computed.hasValues) {
          return;
        }
        filteredRows.push(computed.row);
      });
      const formattedRows = filteredRows.map((row) => row.map((value, columnIndex) => formatCellValue(value, columns[columnIndex])));
      config.table.clear();
      if (formattedRows.length) {
        config.table.rows.add(formattedRows);
      }
      config.table.draw();
      if (typeof config.tableId === 'string') {
        newProductTableFilterRegistry.set(config.tableId, config);
      }
    }

    function renderNewProductFilterOptions(config) {
      if (!config || !config.filterOptionsElement) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      const field = getActiveNewProductFilterField(config);
      if (!field || !Array.isArray(field.availableValues) || !field.availableValues.length) {
        config.filterOptionsElement.innerHTML = '';
        if (config.filterEmptyElement) {
          const message = field && field.label ? `No values available for ${field.label}` : 'No filter values available';
          config.filterEmptyElement.textContent = message;
          config.filterEmptyElement.hidden = false;
        }
        if (config.filterApplyButton) {
          config.filterApplyButton.disabled = true;
        }
        if (config.filterResetButton) {
          config.filterResetButton.disabled = true;
        }
        return;
      }
      if (config.filterEmptyElement) {
        config.filterEmptyElement.hidden = true;
      }
      if (config.filterApplyButton) {
        config.filterApplyButton.disabled = false;
      }
      if (config.filterResetButton) {
        config.filterResetButton.disabled = false;
      }
      let selection = field.pendingSelection;
      if (!(selection === null || selection instanceof Set)) {
        selection = field.activeSelection instanceof Set ? new Set(field.activeSelection) : null;
      }
      field.pendingSelection = selection instanceof Set ? new Set(selection) : selection;
      const optionsMarkup = field.availableValues
        .map((value, index) => {
          const checkboxId = `${config.id}-${field.id}-filter-option-${index}`;
          const isSelected = selection === null || (selection instanceof Set && selection.has(value));
          const checkedAttr = isSelected ? ' checked' : '';
          const safeLabel = escapeHtml(value);
          return `<label class="regular-filter__option" for="${checkboxId}"><input type="checkbox" id="${checkboxId}" value="${safeLabel}"${checkedAttr}><span>${safeLabel}</span></label>`;
        })
        .join('');
      config.filterOptionsElement.innerHTML = optionsMarkup;
      animateOptionList(config.filterOptionsElement, '.regular-filter__option');
      const checkboxes = config.filterOptionsElement.querySelectorAll('input[type="checkbox"]');
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener('change', (event) => {
          const target = event.target;
          const { checked } = target;
          const value = target.value;
          let selectionSet = field.pendingSelection;
          if (selectionSet === null) {
            selectionSet = new Set(field.availableValues);
          } else if (selectionSet instanceof Set) {
            selectionSet = new Set(selectionSet);
          } else {
            selectionSet = new Set(field.availableValues);
          }
          if (checked) {
            selectionSet.add(value);
          } else {
            selectionSet.delete(value);
          }
          if (selectionSet.size === field.availableValues.length) {
            selectionSet = null;
          }
          field.pendingSelection = selectionSet;
        });
      });
    }

    function openNewProductFilter(config) {
      if (!config || !config.filterContainer) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      if (filterState) {
        filterState.fields.forEach((field) => {
          if (field.activeSelection instanceof Set) {
            field.pendingSelection = new Set(field.activeSelection);
          } else if (field.activeSelection === null) {
            field.pendingSelection = null;
          } else {
            field.pendingSelection = null;
          }
        });
      }
      renderNewProductFilterOptions(config);
      renderNewProductFilterFieldButtons(config);
      showFilterContainer(config.filterContainer);
      if (config.filterButton) {
        config.filterButton.setAttribute('aria-expanded', 'true');
      }
      const firstCheckbox = config.filterOptionsElement
        ? config.filterOptionsElement.querySelector('input[type="checkbox"]')
        : null;
      if (firstCheckbox) {
        firstCheckbox.focus();
      } else if (config.filterApplyButton) {
        config.filterApplyButton.focus();
      }
    }

    function closeNewProductFilter(config, options = {}) {
      if (!config || !config.filterContainer) {
        return;
      }
      const { keepSelection } = options;
      if (!keepSelection) {
        const filterState = ensureNewProductFilterState(config);
        if (filterState) {
          filterState.fields.forEach((field) => {
            field.pendingSelection = null;
          });
        }
      }
      hideFilterContainer(config.filterContainer);
      if (config.filterButton) {
        config.filterButton.setAttribute('aria-expanded', 'false');
      }
      if (options.returnFocus !== false && config.filterButton && typeof config.filterButton.focus === 'function') {
        config.filterButton.focus();
      }
    }

    function applyNewProductFilter(config) {
      if (!config) {
        return;
      }
      if (config.filterApplyButton) {
        flashButtonBusy(config.filterApplyButton);
      }
      const filterState = ensureNewProductFilterState(config);
      if (filterState) {
        filterState.fields.forEach((field) => {
          if (field.pendingSelection === null) {
            field.activeSelection = null;
          } else if (field.pendingSelection instanceof Set) {
            field.activeSelection = new Set(field.pendingSelection);
          } else {
            field.activeSelection = null;
          }
          field.pendingSelection = null;
        });
      }
      closeNewProductFilter(config, { keepSelection: true, returnFocus: true });
      updateNewProductFilterButtonState(config);
      if (config.table) {
        updateNewProductTableFilters(config);
        config.table.draw();
      }
    }

    function clearNewProductFilters(config) {
      if (!config) {
        return;
      }
      const filterState = ensureNewProductFilterState(config);
      if (filterState) {
        filterState.fields.forEach((field) => {
          field.activeSelection = null;
          field.pendingSelection = null;
        });
      }
      closeNewProductFilter(config, { keepSelection: true, returnFocus: false });
      updateNewProductFilterButtonState(config);
      if (config.table) {
        updateNewProductTableFilters(config);
        config.table.draw();
      }
    }

    function resetNewProductFilterState(config) {
      const filterState = ensureNewProductFilterState(config);
      if (filterState) {
        filterState.fields.forEach((field) => {
          field.availableValues = [];
          field.activeSelection = null;
          field.pendingSelection = null;
        });
      }
      config.rowLabelNewOldMap = new Map();
      config.defaultNewOldSelectionApplied = false;
    }

    function setupNewProductFilter(config) {
      if (!config) {
        return;
      }
      config.filterButton = document.getElementById(config.filterButtonId);
      config.filterContainer = document.getElementById(config.filterContainerId);
      config.filterOptionsElement = document.getElementById(config.filterOptionsId);
      config.filterFieldOptionsElement = document.getElementById(config.filterFieldOptionsId);
      config.filterApplyButton = document.getElementById(config.filterApplyId);
      config.filterResetButton = document.getElementById(config.filterResetId);
      config.filterEmptyElement = document.getElementById(config.filterEmptyId);
      config.filterCloseButton = config.filterContainer
        ? config.filterContainer.querySelector('.regular-filter__close')
        : null;
      config.filterClearButton = config.filterClearButtonId
        ? document.getElementById(config.filterClearButtonId)
        : null;
      ensureNewProductFilterState(config);
      if (!config.filterButton || !config.filterContainer) {
        return;
      }
      config.filterContainer.setAttribute('hidden', '');
      config.filterButton.addEventListener('click', () => {
        if (config.filterContainer.classList.contains('is-visible')) {
          closeNewProductFilter(config, { returnFocus: false });
        } else {
          openNewProductFilter(config);
        }
      });
      if (config.filterCloseButton) {
        config.filterCloseButton.addEventListener('click', () => closeNewProductFilter(config));
      }
      config.filterContainer.addEventListener('click', (event) => {
        const target = event.target;
        if (target === config.filterContainer || (target instanceof HTMLElement && target.classList.contains('regular-filter__backdrop'))) {
          closeNewProductFilter(config);
        }
      });
      config.filterContainer.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          closeNewProductFilter(config);
        }
      });
      if (config.filterApplyButton) {
        config.filterApplyButton.addEventListener('click', () => applyNewProductFilter(config));
      }
      if (config.filterResetButton) {
        config.filterResetButton.addEventListener('click', () => {
          const filterState = ensureNewProductFilterState(config);
          if (filterState) {
            filterState.fields.forEach((field) => {
              field.pendingSelection = null;
              field.activeSelection = null;
            });
          }
          applyNewProductFilter(config);
        });
      }
      if (config.filterClearButton) {
        config.filterClearButton.addEventListener('click', () => clearNewProductFilters(config));
      }
    }

    function renderNewProductPivotTable(config, pivot) {
      const tableElement = document.getElementById(config.tableId);
      if (!tableElement) {
        return;
      }
      if ($.fn.DataTable.isDataTable(tableElement)) {
        $(tableElement).DataTable().destroy();
      }
      tableElement.innerHTML = '';
      const columns = Array.isArray(pivot?.columns) ? pivot.columns.slice() : [];
      const rows = Array.isArray(pivot?.rows)
        ? pivot.rows.map((row) => (Array.isArray(row) ? row.slice() : []))
        : [];
      const rowAttributes = Array.isArray(pivot?.rowAttributes)
        ? cloneNewProductRowAttributes(pivot.rowAttributes)
        : [];
      config.rawRows = rows.map((row) => row.slice());
      config.rowAttributes = rowAttributes;
      config.columns = columns.slice();
      if (!columns.length || !rows.length) {
        tableElement.innerHTML = '<tbody><tr><td>No data available</td></tr></tbody>';
        config.table = null;
        resetNewProductFilterState(config);
        if (typeof config.tableId === 'string') {
          newProductTableFilterRegistry.delete(config.tableId);
        }
        if (config.filterInitialised) {
          renderNewProductFilterFieldButtons(config);
        }
        updateNewProductFilterButtonState(config);
        return;
      }
      const dataColumns = columns.map((title) => ({ title }));
      const formattedRows = rows.map((row) => {
        return columns.map((columnName, columnIndex) => formatCellValue(row[columnIndex], columnName));
      });
      const columnDefs = columns.map((_, index) => ({
        targets: index,
        className: index === 0 ? 'cell-label' : 'cell-numeric',
      }));
      const table = $(tableElement).DataTable({
        data: formattedRows,
        columns: dataColumns,
        columnDefs,
        scrollX: true,
        deferRender: true,
        paging: false,
        ordering: false,
        info: false,
        searching: false,
        autoWidth: false,
      });
      config.table = table;
      ensureNewProductFilterHook();
      const filterState = ensureNewProductFilterState(config);
      const rowField = filterState ? filterState.fields.get('row') : null;
      const newOldField = filterState ? filterState.fields.get('new-old') : null;
      const labelValues = formattedRows.map((row) => row[0]).filter((value) => typeof value === 'string' && value.length);
      const uniqueLabels = Array.from(new Set(labelValues));
      if (rowField) {
        rowField.availableValues = uniqueLabels;
        if (!(rowField.activeSelection instanceof Set) && rowField.activeSelection !== null) {
          rowField.activeSelection = null;
        }
        if (rowField.activeSelection instanceof Set) {
          const validValues = Array.from(rowField.activeSelection).filter((value) => rowField.availableValues.includes(value));
          rowField.activeSelection = validValues.length ? new Set(validValues) : null;
        }
      }
      const rowLabelNewOldMap = new Map();
      const newOldValues = new Set();
      const appendNewOldValue = (valueSet, rawValue) => {
        if (typeof rawValue !== 'string') {
          return;
        }
        const trimmed = rawValue.trim();
        if (!trimmed) {
          return;
        }
        valueSet.add(trimmed);
        newOldValues.add(trimmed);
      };
      formattedRows.forEach((row, index) => {
        const label = row[0];
        const normalizedLabel = normaliseNewProductLabel(label);
        if (!normalizedLabel) {
          return;
        }
        let valueSet = rowLabelNewOldMap.get(normalizedLabel);
        if (!valueSet) {
          valueSet = new Set();
          rowLabelNewOldMap.set(normalizedLabel, valueSet);
        }
        const attribute = rowAttributes[index];
        const rawNewOld = attribute ? attribute.newOld : null;
        if (rawNewOld instanceof Set) {
          rawNewOld.forEach((value) => appendNewOldValue(valueSet, value));
        } else if (Array.isArray(rawNewOld)) {
          rawNewOld.forEach((value) => appendNewOldValue(valueSet, value));
        } else if (typeof rawNewOld === 'string') {
          appendNewOldValue(valueSet, rawNewOld);
        }
      });
      config.rowLabelNewOldMap = rowLabelNewOldMap;
      if (newOldField) {
        newOldField.availableValues = sortNewProductNewOldValues(Array.from(newOldValues));
        if (!(newOldField.activeSelection instanceof Set) && newOldField.activeSelection !== null) {
          newOldField.activeSelection = null;
        }
        if (newOldField.activeSelection instanceof Set) {
          const validValues = Array.from(newOldField.activeSelection).filter((value) => newOldField.availableValues.includes(value));
          newOldField.activeSelection = validValues.length ? new Set(validValues) : null;
        }
      }
      if (!config.filterInitialised) {
        setupNewProductFilter(config);
        config.filterInitialised = true;
      }
      renderNewProductFilterFieldButtons(config);
      updateNewProductTableFilters(config);
      if (config.table) {
        config.table.draw();
      }
      updateNewProductFilterButtonState(config);
      const subtitleElement = document.getElementById(config.subtitleId);
      if (subtitleElement) {
        const parts = [];
        const meta = pivot?.metadata || {};
        if (typeof meta.segmentLabel === 'string' && meta.segmentLabel.trim().length) {
          parts.push(meta.segmentLabel.trim());
        }
        if (typeof meta.segmentSelection === 'string' && meta.segmentSelection.trim().length) {
          parts.push(meta.segmentSelection.trim());
        }
        subtitleElement.textContent = parts.length
          ? `Segment: ${parts.join(' • ')}`
          : 'Pivot metrics derived from the Main sheet dataset';
      }
    }

    function renderNewProductPivots(sections) {
      if (!Array.isArray(sections) || !sections.length) {
        NEW_PRODUCT_PIVOT_CONFIGS.forEach((config) => {
          const tableElement = document.getElementById(config.tableId);
          if (tableElement) {
            tableElement.innerHTML = '<tbody><tr><td>No data available</td></tr></tbody>';
          }
          config.table = null;
          resetNewProductFilterState(config);
          if (typeof config.tableId === 'string') {
            newProductTableFilterRegistry.delete(config.tableId);
          }
          if (config.filterInitialised) {
            renderNewProductFilterFieldButtons(config);
          }
          updateNewProductFilterButtonState(config);
        });
        showNewProductStatus('No new product pivot data available', 'error');
        return;
      }
      NEW_PRODUCT_PIVOT_CONFIGS.forEach((config, index) => {
        const pivot = sections[index];
        if (pivot) {
          renderNewProductPivotTable(config, pivot);
        } else {
          const tableElement = document.getElementById(config.tableId);
          if (tableElement) {
            tableElement.innerHTML = '<tbody><tr><td>No data available</td></tr></tbody>';
          }
          config.table = null;
          resetNewProductFilterState(config);
          if (typeof config.tableId === 'string') {
            newProductTableFilterRegistry.delete(config.tableId);
          }
          if (config.filterInitialised) {
            renderNewProductFilterFieldButtons(config);
          }
          updateNewProductFilterButtonState(config);
        }
      });
      showNewProductStatus('');
    }

    function loadNewProductPivots() {
      if (newProductInitialised && Array.isArray(newProductPivotCache) && newProductPivotCache.length) {
        renderNewProductPivots(newProductPivotCache);
        setTabPanelLoading('new-product', false);
        return Promise.resolve(newProductPivotCache);
      }
      setTabPanelLoading('new-product', true, 'Loading new product pivots…');
      showNewProductStatus('Loading new product pivots…');
      return fetchNewProductPivotSections()
        .then((sections) => {
          newProductInitialised = true;
          newProductPivotCache = sections;
          renderNewProductPivots(sections);
        })
        .catch((error) => {
          console.error('Failed to load new product pivots:', error);
          showNewProductStatus(error.message || 'Unable to load new product pivots', 'error');
        })
        .finally(() => {
          setTabPanelLoading('new-product', false);
        });
    }

    function getStickyOffsetValue() {
      const rawValue = getComputedStyle(document.documentElement).getPropertyValue('--sticky-header-offset');
      const parsed = Number.parseFloat(rawValue);
      return Number.isFinite(parsed) ? parsed : 0;
    }

    function calculateScrollBodyHeight(rowCount, viewportTopOffset, reservedSpace) {
      const baselineMinHeight = HEADER_HEIGHT + MIN_VISIBLE_ROWS * ROW_HEIGHT;
      const viewportHeight = Number.isFinite(window.innerHeight) ? window.innerHeight : baselineMinHeight;
      let availableViewport = viewportHeight;
      const bottomSpacing = Number.isFinite(reservedSpace)
        ? reservedSpace
        : TABLE_BOTTOM_MARGIN;
      if (Number.isFinite(viewportTopOffset)) {
        availableViewport = viewportHeight - viewportTopOffset - bottomSpacing;
      } else {
        const stickyOffset = getStickyOffsetValue() + 64;
        availableViewport = viewportHeight - stickyOffset - bottomSpacing;
      }

      const usableViewport = Math.max(availableViewport, baselineMinHeight);
      const rowsToFillViewport = Math.max(
        MIN_VISIBLE_ROWS,
        Math.ceil(Math.max(0, usableViewport - HEADER_HEIGHT) / ROW_HEIGHT)
      );
      const effectiveRowCount = Math.max(rowCount, rowsToFillViewport);
      const desiredHeight = HEADER_HEIGHT + effectiveRowCount * ROW_HEIGHT;
      const heightWithinViewport = Math.min(desiredHeight, usableViewport);
      const minimumAllowedHeight = Math.min(baselineMinHeight, viewportHeight - bottomSpacing);
      const finalHeight = Math.max(heightWithinViewport, minimumAllowedHeight, HEADER_HEIGHT + MIN_VISIBLE_ROWS * ROW_HEIGHT);
      return Math.round(finalHeight);
    }

    function resizeLoTableContainers() {
      const containers = document.querySelectorAll('.lo-table-container');
      if (!containers.length) {
        return;
      }

      const viewportHeight = Number.isFinite(window.innerHeight) ? window.innerHeight : null;
      containers.forEach((container) => {
        if (!(container instanceof HTMLElement)) {
          return;
        }
        const rect = container.getBoundingClientRect();
        if (!rect) {
          return;
        }

        const topOffset = Number.isFinite(rect.top) ? rect.top : null;
        let availableHeight = viewportHeight;
        if (Number.isFinite(viewportHeight) && Number.isFinite(topOffset)) {
          availableHeight = viewportHeight - topOffset - LO_TABLE_BOTTOM_MARGIN;
        }

        if (!Number.isFinite(availableHeight)) {
          availableHeight = MIN_LO_TABLE_HEIGHT;
        }

        const finalHeight = Math.max(Math.floor(availableHeight), MIN_LO_TABLE_HEIGHT);
        container.style.height = `${finalHeight}px`;
        container.style.maxHeight = `${finalHeight}px`;
      });
    }

    function syncHeaderColumnWidths(table) {
      if (!table) {
        return;
      }
      const container = table.table().container();
      const scrollHead = container.querySelector('.dataTables_scrollHead');
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      const scrollFoot = container.querySelector('.dataTables_scrollFoot');
      const headerTable = scrollHead ? scrollHead.querySelector('table') : null;
      const bodyTable = scrollBody ? scrollBody.querySelector('table') : null;
      const footTables = [];
      if (scrollFoot) {
        const scrollFootTable = scrollFoot.querySelector('table');
        if (scrollFootTable) {
          footTables.push(scrollFootTable);
        }
      }
      const baseFoot = table.table().footer();
      if (baseFoot) {
        footTables.push(baseFoot);
      }
      if (!headerTable || !bodyTable) {
        return;
      }

      const columnWidths = [];
      const columnIndexes = table.columns().indexes().toArray();
      columnIndexes.forEach((columnIndex) => {
        const numericIndex = Number(columnIndex);
        const column = table.column(columnIndex);
        const headerCell = column.header();
        if (!headerCell) {
          return;
        }

        const bodyCells = column.nodes().toArray();
        let maxWidth = 0;
        bodyCells.forEach((cell) => {
          if (!(cell instanceof HTMLElement)) {
            return;
          }
          const { width } = cell.getBoundingClientRect();
          if (width > maxWidth) {
            maxWidth = width;
          }
        });

        if (maxWidth <= 0) {
          const { width } = headerCell.getBoundingClientRect();
          maxWidth = width;
        }

        if (maxWidth > 0) {
          const numericWidth = Math.ceil(maxWidth);
          columnWidths[numericIndex] = numericWidth;
          const widthPx = `${numericWidth}px`;
          headerCell.style.width = widthPx;
          headerCell.style.minWidth = widthPx;
          headerCell.style.maxWidth = widthPx;
          headerCell.style.boxSizing = 'border-box';
          bodyCells.forEach((cell) => {
            if (cell instanceof HTMLElement) {
              cell.style.width = widthPx;
              cell.style.minWidth = widthPx;
              cell.style.maxWidth = widthPx;
              cell.style.boxSizing = 'border-box';
            }
          });
          footTables.forEach((footTable) => {
            const footCells = footTable.querySelectorAll('th');
            const footCell = footCells[columnIndex];
            if (footCell instanceof HTMLElement) {
              footCell.style.width = widthPx;
              footCell.style.minWidth = widthPx;
              footCell.style.maxWidth = widthPx;
              footCell.style.boxSizing = 'border-box';
            }
          });
        }
      });

      const updatePreambleCellWidths = (tableLike) => {
        if (!tableLike) {
          return;
        }
        const head = tableLike.tHead || tableLike.querySelector('thead');
        if (!head) {
          return;
        }
        const rows = Array.from(head.rows);
        if (rows.length <= 1) {
          return;
        }
        const preambleRows = rows.slice(0, -1);
        preambleRows.forEach((row) => {
          let columnPosition = 0;
          Array.from(row.cells).forEach((cell) => {
            const span = Math.max(1, Number(cell.colSpan) || 1);
            let totalWidth = 0;
            for (let offset = 0; offset < span; offset += 1) {
              const lookupIndex = columnPosition + offset;
              const widthValue = columnWidths[lookupIndex];
              if (Number.isFinite(widthValue)) {
                totalWidth += widthValue;
              }
            }
            if (totalWidth > 0) {
              const widthPx = `${totalWidth}px`;
              cell.style.width = widthPx;
              cell.style.minWidth = widthPx;
              cell.style.maxWidth = widthPx;
              cell.style.boxSizing = 'border-box';
            }
            columnPosition += span;
          });
        });
      };

      updatePreambleCellWidths(headerTable);
      const baseHeader = table.table().header();
      if (baseHeader) {
        const baseHeaderTable = baseHeader.closest('table');
        updatePreambleCellWidths(baseHeaderTable);
      }

      const bodyWidth = bodyTable.getBoundingClientRect().width;
      if (bodyWidth > 0) {
        const widthPx = `${Math.ceil(bodyWidth)}px`;
        headerTable.style.width = widthPx;
        const scrollHeadInner = scrollHead.querySelector('.dataTables_scrollHeadInner');
        if (scrollHeadInner) {
          scrollHeadInner.style.width = widthPx;
        }
        if (scrollFoot) {
          const scrollFootInner = scrollFoot.querySelector('.dataTables_scrollFootInner');
          if (scrollFootInner) {
            scrollFootInner.style.width = widthPx;
          }
        }
        footTables.forEach((footTable) => {
          footTable.style.width = widthPx;
        });
      }
    }

    function adjustScrollBodyPadding(table) {
      if (!table) {
        return;
      }
      const container = table.table().container();
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      if (!scrollBody) {
        return;
      }
      const scrollFoot = container.querySelector('.dataTables_scrollFoot');
      let paddingBottom = 0;
      if (scrollFoot) {
        const footRect = scrollFoot.getBoundingClientRect();
        if (footRect && Number.isFinite(footRect.height)) {
          paddingBottom = Math.max(0, Math.ceil(footRect.height) - 6);
        }
      }
      const MINIMUM_PADDING = 16;
      const appliedPadding = Math.max(paddingBottom, MINIMUM_PADDING);
      scrollBody.style.paddingBottom = `${appliedPadding}px`;
    }

    function applyHeaderPreambleToTable(tableElement, preamble, columnTitles) {
      if (!tableElement) {
        return;
      }
      const columns = Array.isArray(columnTitles) ? columnTitles.slice() : [];
      const columnCount = columns.length;
      const existingThead = tableElement.querySelector('thead');
      if (existingThead) {
        tableElement.removeChild(existingThead);
      }
      if (columnCount === 0) {
        return;
      }

      const thead = document.createElement('thead');
      const hasPreamble = preamble
        && Array.isArray(preamble.rows)
        && preamble.rows.length > 0;

      if (hasPreamble) {
        const normalisedRows = [];
        for (let rowIndex = 0; rowIndex < preamble.rows.length; rowIndex += 1) {
          const sourceRow = Array.isArray(preamble.rows[rowIndex]) ? preamble.rows[rowIndex] : [];
          const row = new Array(columnCount).fill('');
          for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
            if (columnIndex < sourceRow.length) {
              row[columnIndex] = sourceRow[columnIndex];
            }
          }
          normalisedRows.push(row);
        }

        const mergeEntries = Array.isArray(preamble.merges) ? preamble.merges : [];
        const mergeMap = new Map();
        const skipSet = new Set();
        mergeEntries.forEach((entry) => {
          if (!entry) {
            return;
          }
          const startRow = Number.isFinite(entry.row) ? Math.max(0, Math.floor(entry.row)) : 0;
          const startCol = Number.isFinite(entry.column) ? Math.max(0, Math.floor(entry.column)) : 0;
          const requestedRowSpan = Number.isFinite(entry.rowSpan) ? Math.floor(entry.rowSpan) : 1;
          const requestedColSpan = Number.isFinite(entry.colSpan) ? Math.floor(entry.colSpan) : 1;
          const rowSpan = Math.max(1, requestedRowSpan);
          const colSpan = Math.max(1, requestedColSpan);
          if (startRow >= normalisedRows.length || startCol >= columnCount) {
            return;
          }
          const maxRow = Math.min(normalisedRows.length - 1, startRow + rowSpan - 1);
          const maxCol = Math.min(columnCount - 1, startCol + colSpan - 1);
          if (maxRow < startRow || maxCol < startCol) {
            return;
          }
          const effectiveRowSpan = Math.max(1, maxRow - startRow + 1);
          const effectiveColSpan = Math.max(1, maxCol - startCol + 1);
          const key = `${startRow},${startCol}`;
          mergeMap.set(key, { rowSpan: effectiveRowSpan, colSpan: effectiveColSpan });
          for (let row = startRow; row <= maxRow; row += 1) {
            for (let col = startCol; col <= maxCol; col += 1) {
              if (row === startRow && col === startCol) {
                continue;
              }
              skipSet.add(`${row},${col}`);
            }
          }
        });

        normalisedRows.forEach((row, rowIndex) => {
          const tr = document.createElement('tr');
          tr.classList.add('table-preamble-row');
          for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
            const cellKey = `${rowIndex},${columnIndex}`;
            if (skipSet.has(cellKey)) {
              continue;
            }
            const span = mergeMap.get(cellKey) || null;
            const rawValue = row && columnIndex < row.length ? row[columnIndex] : '';
            const text = typeof rawValue === 'string'
              ? rawValue
              : (rawValue === null || rawValue === undefined ? '' : String(rawValue));
            const trimmed = text.trim();
            const th = document.createElement('th');
            th.classList.add('table-preamble__cell');
            if (span) {
              if (span.rowSpan > 1) {
                th.rowSpan = span.rowSpan;
              }
              if (span.colSpan > 1) {
                th.colSpan = span.colSpan;
              }
            }
            if (trimmed.length === 0) {
              th.classList.add('is-empty');
              th.innerHTML = '&nbsp;';
            } else {
              th.innerHTML = escapeHtml(text);
            }
            tr.appendChild(th);
          }
          thead.appendChild(tr);
        });
      }

      const headerRow = document.createElement('tr');
      columns.forEach((title, columnIndex) => {
        const th = document.createElement('th');
        th.dataset.columnIndex = String(columnIndex);
        const value = typeof title === 'string'
          ? title
          : (title === null || title === undefined ? '' : String(title));
        th.innerHTML = escapeHtml(value);
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      tableElement.insertBefore(thead, tableElement.firstChild || null);
    }

    function calculateRegularTableReservedSpace(container) {
      let reservedSpace = DEFAULT_REGULAR_TABLE_RESERVED_SPACE;
      if (!container) {
        return reservedSpace;
      }
      const footer = container.querySelector('.regular-table__footer, .main-table__footer');
      if (!footer) {
        return reservedSpace;
      }
      const footerRect = footer.getBoundingClientRect();
      if (!footerRect || !Number.isFinite(footerRect.height)) {
        return reservedSpace;
      }
      const measuredFooterSpace = Math.ceil(footerRect.height) + REGULAR_TABLE_FOOTER_EXTRA_GAP;
      reservedSpace = Math.max(reservedSpace, TABLE_BOTTOM_MARGIN + measuredFooterSpace);
      return reservedSpace;
    }

    function applyTableHeight(table) {
      if (!table) {
        return;
      }
      const rowCount = table.rows({ page: 'current' }).count();
      const container = table.table().container();
      const scrollBody = container.querySelector('.dataTables_scrollBody');
      const scrollBodyRect = scrollBody ? scrollBody.getBoundingClientRect() : null;
      const viewportTopOffset = scrollBodyRect && Number.isFinite(scrollBodyRect.top) ? scrollBodyRect.top : null;
      const reservedSpace = calculateRegularTableReservedSpace(container);
      const height = calculateScrollBodyHeight(rowCount, viewportTopOffset, reservedSpace);
      if (scrollBody) {
        scrollBody.style.height = `${height}px`;
        scrollBody.style.maxHeight = `${height}px`;
      }
      const settings = table.settings()[0];
      if (settings && settings.oScroll) {
        settings.oScroll.sY = `${height}px`;
      }
      table.columns.adjust();
      requestAnimationFrame(() => {
        syncHeaderColumnWidths(table);
        adjustScrollBodyPadding(table);
      });
    }

    function applyFooterValuesToCells(cells, values, numericColumnSet, totalIndex = totalColumnIndex) {
      if (!cells || !values || values.length === 0) {
        return;
      }
      values.forEach((value, index) => {
        const cell = cells[index];
        if (!cell) {
          return;
        }
        const displayValue = value ?? '';
        const isLabelCell = index === 0;
        const isNumeric = numericColumnSet.has(index);
        const isTotalColumn = Number.isFinite(totalIndex) && totalIndex >= 0 && index === totalIndex;
        cell.textContent = displayValue;
        cell.classList.toggle('cell-total-label', isLabelCell);
        cell.classList.toggle('cell-total', !isLabelCell);
        cell.classList.toggle('cell-numeric', isNumeric && !isLabelCell);
        cell.classList.toggle('cell-total-column', isTotalColumn);
        if (isLabelCell) {
          cell.style.textAlign = 'left';
        } else if (isNumeric) {
          cell.style.textAlign = 'right';
        } else {
          cell.style.textAlign = 'left';
        }
      });
    }

    function ensureTableFooter(tableElement, columnCount, values = [], numericColumnSet = new Set(), totalIndex = totalColumnIndex) {
      if (!tableElement) {
        return;
      }
      const existingFoot = tableElement.querySelector('tfoot');
      if (existingFoot) {
        tableElement.removeChild(existingFoot);
      }
      const tfoot = document.createElement('tfoot');
      const row = document.createElement('tr');
      for (let index = 0; index < columnCount; index += 1) {
        row.appendChild(document.createElement('th'));
      }
      tfoot.appendChild(row);
      tableElement.appendChild(tfoot);
      if (values.length === columnCount) {
        const cells = tfoot.querySelectorAll('th');
        applyFooterValuesToCells(cells, values, numericColumnSet, totalIndex);
      }
    }

    function renderFooterRow(table, values, numericColumnSet, totalIndex) {
      if (!table || !Array.isArray(values) || !values.length) {
        return;
      }
      const container = table.table().container();
      const baseFooter = table.table().footer();
      const footerTables = [];
      if (baseFooter) {
        footerTables.push(baseFooter);
      }
      const scrollFoot = container.querySelector('.dataTables_scrollFoot table');
      if (scrollFoot) {
        footerTables.push(scrollFoot);
      }
      footerTables.forEach((footerTable) => {
        const cells = footerTable.querySelectorAll('th');
        applyFooterValuesToCells(cells, values, numericColumnSet, totalIndex);
      });
      adjustScrollBodyPadding(table);
    }

    function refreshRegularTableLayout() {
      if (!regularTableInitialised || !regularTable) {
        return;
      }
      applyTableHeight(regularTable);
      if (SHOW_REGULAR_TOTAL_ROW) {
        updateRegularTableFooter(regularTable);
      } else if (regularTableFooterValues.length) {
        renderFooterRow(regularTable, regularTableFooterValues, regularTableNumericColumnSet, totalColumnIndex);
      }
      moveRegularTablePagination();
    }

    function moveRegularTablePagination() {
      const paginationHost = document.getElementById('regular-table-pagination');
      const tableWrapper = document.getElementById('regular-table_wrapper');
      if (!paginationHost || !tableWrapper) {
        return;
      }
      let paginate = tableWrapper.querySelector('.dataTables_paginate');
      if (!paginate) {
        paginate = paginationHost.querySelector('.dataTables_paginate');
      }
      if (!paginate) {
        paginationHost.textContent = '';
        return;
      }
      if (paginate.parentElement !== paginationHost) {
        paginationHost.textContent = '';
        paginationHost.appendChild(paginate);
      }
    }

    function calculateMainTableFooterValues(table) {
      if (!table || !mainTableAugmentedDataset) {
        return mainTableFooterValues;
      }

      const columns = Array.isArray(mainTableAugmentedDataset.columns)
        ? mainTableAugmentedDataset.columns
        : [];
      const columnCount = columns.length;
      if (columnCount === 0) {
        return [];
      }

      const baseValues = buildFormattedFooterValues(mainTableAugmentedDataset);
      const values = Array.isArray(baseValues) && baseValues.length === columnCount
        ? baseValues.slice()
        : (() => {
            const fallback = new Array(columnCount).fill('');
            const totalsRow = Array.isArray(mainTableAugmentedDataset.totalsRow)
              ? mainTableAugmentedDataset.totalsRow
              : [];
            const labelValue = totalsRow[0];
            if (typeof labelValue === 'string' && labelValue.trim().length) {
              fallback[0] = labelValue;
            } else {
              fallback[0] = TOTAL_ROW_LABEL;
            }
            return fallback;
          })();

      if (!mainTableNumericColumnSet || mainTableNumericColumnSet.size === 0) {
        return values;
      }

      const filteredRows = table.rows({ search: 'applied' }).data().toArray();

      mainTableNumericColumnSet.forEach((columnIndex) => {
        if (typeof columnIndex !== 'number' || columnIndex < 0 || columnIndex >= columnCount) {
          return;
        }
        let sum = 0;
        let hasValue = false;
        filteredRows.forEach((row) => {
          if (!row || columnIndex >= row.length) {
            return;
          }
          const numericValue = parseNumericValue(row[columnIndex]);
          if (numericValue !== null) {
            sum += numericValue;
            hasValue = true;
          }
        });

        const formattedTotal = hasValue
          ? formatCellValue(sum, columns[columnIndex])
          : formatCellValue(0, columns[columnIndex]);
        values[columnIndex] = formattedTotal;
      });

      return values;
    }

    function updateMainTableFooter(table) {
      if (!SHOW_REGULAR_TOTAL_ROW || !table) {
        return;
      }
      mainTableFooterValues = calculateMainTableFooterValues(table);
      renderFooterRow(table, mainTableFooterValues, mainTableNumericColumnSet, mainTotalColumnIndex);
    }

    function refreshMainTableLayout() {
      if (!mainTableInitialised || !mainTable) {
        return;
      }
      applyTableHeight(mainTable);
      if (SHOW_REGULAR_TOTAL_ROW) {
        updateMainTableFooter(mainTable);
      } else if (mainTableFooterValues.length) {
        renderFooterRow(mainTable, mainTableFooterValues, mainTableNumericColumnSet, mainTotalColumnIndex);
      }
      moveMainTablePagination();
    }

    function moveMainTablePagination() {
      const paginationHost = document.getElementById('main-table-pagination');
      const tableWrapper = document.getElementById('main-table_wrapper');
      if (!paginationHost || !tableWrapper) {
        return;
      }
      let paginate = tableWrapper.querySelector('.dataTables_paginate');
      if (!paginate) {
        paginate = paginationHost.querySelector('.dataTables_paginate');
      }
      if (!paginate) {
        paginationHost.textContent = '';
        return;
      }
      if (paginate.parentElement !== paginationHost) {
        paginationHost.textContent = '';
        paginationHost.appendChild(paginate);
      }
    }

    function setActiveTab(targetTab) {
      const previousTab = activeTabId;
      activeTabId = targetTab;
      tabButtons.forEach((button) => {
        const isActive = button.dataset.tab === targetTab;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', String(isActive));
      });
      updateTabIndicator(targetTab);
      const nextPanel = getTabPanelElement(targetTab);
      const previousPanel = previousTab ? getTabPanelElement(previousTab) : null;
      if (previousPanel && previousPanel !== nextPanel) {
        hideTabPanel(previousPanel);
      }
      if (nextPanel) {
        showTabPanel(nextPanel);
      }
      if (targetTab !== 'main' && mainFilterContainerElement && mainFilterContainerElement.classList.contains('is-visible')) {
        closeMainFilter({ returnFocus: false });
      }
      if (targetTab === 'regular') {
        loadRegularTable();
        refreshRegularTableLayout();
        return;
      }
      closeHeaderMenu();
      if (targetTab === 'main') {
        if (regularFilterContainerElement && regularFilterContainerElement.classList.contains('is-visible')) {
          closeRegularFilter({ returnFocus: false });
        }
        loadMainTable();
        refreshMainTableLayout();
        return;
      }
      if (targetTab === 'dashboard') {
        if (regularFilterContainerElement && regularFilterContainerElement.classList.contains('is-visible')) {
          closeRegularFilter({ returnFocus: false });
        }
        loadMainDashboard();
        return;
      }
      if (targetTab === 'sku-summary') {
        loadSkuSummaryTable();
        return;
      }
      if (targetTab === 'new-product') {
        loadNewProductPivots();
        return;
      }
      if (targetTab === 'lo' || targetTab === 'platform') {
        if (regularFilterContainerElement && regularFilterContainerElement.classList.contains('is-visible')) {
          closeRegularFilter({ returnFocus: false });
        }
        const showLoLoader = targetTab === 'lo' && !loTablesInitialised;
        const showPlatformLoader = targetTab === 'platform' && !platformTablesInitialised;
        if (showLoLoader || showPlatformLoader) {
          renderLoMessage('Loading data…');
        }
        if (showLoLoader) {
          setTabPanelLoading('lo', true, 'Loading listing owner metrics…');
        }
        if (showPlatformLoader) {
          setTabPanelLoading('platform', true, 'Loading store metrics…');
        }
        fetchRegularDataset()
          .then((dataset) => {
            initializeLoTables(dataset);
          })
          .catch((error) => {
            renderLoMessage(error.message || 'Unable to load data');
          })
          .finally(() => {
            setTabPanelLoading('lo', false);
            setTabPanelLoading('platform', false);
          });
        requestAnimationFrame(() => resizeLoTableContainers());
      }
    }

    tabButtons.forEach((button) => {
      button.addEventListener('click', () => setActiveTab(button.dataset.tab));
    });

    function setActiveLoSubTab(targetSubTab) {
      if (!loSubTabButtons.length) {
        return;
      }
      loSubTabButtons.forEach((button) => {
        const isActive = button.dataset.subtab === targetSubTab;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', String(isActive));
      });
      loSubTabPanels.forEach((panel) => {
        const isActive = panel.dataset.subtab === targetSubTab;
        panel.classList.toggle('active', isActive);
        panel.setAttribute('aria-hidden', String(!isActive));
      });
      if (loFilterButtonElement) {
        const hideFilter = targetSubTab === 'spend';
        loFilterButtonElement.classList.toggle('lo-card__filter-button--hidden', hideFilter);
        loFilterButtonElement.setAttribute('aria-hidden', String(hideFilter));
        if (hideFilter) {
          loFilterButtonElement.setAttribute('tabindex', '-1');
          if (regularFilterContainerElement && regularFilterContainerElement.classList.contains('is-visible')) {
            closeRegularFilter({ returnFocus: false });
          }
        } else {
          loFilterButtonElement.removeAttribute('tabindex');
        }
      }
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    loSubTabButtons.forEach((button) => {
      button.addEventListener('click', () => setActiveLoSubTab(button.dataset.subtab));
    });

    if (loSubTabButtons.length > 0) {
      setActiveLoSubTab('sales');
    }

    function setActivePlatformSubTab(targetSubTab) {
      if (!platformSubTabButtons.length) {
        return;
      }
      platformSubTabButtons.forEach((button) => {
        const isActive = button.dataset.subtab === targetSubTab;
        button.classList.toggle('active', isActive);
        button.setAttribute('aria-selected', String(isActive));
      });
      platformSubTabPanels.forEach((panel) => {
        const isActive = panel.dataset.subtab === targetSubTab;
        panel.classList.toggle('active', isActive);
        panel.setAttribute('aria-hidden', String(!isActive));
      });
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    platformSubTabButtons.forEach((button) => {
      button.addEventListener('click', () => setActivePlatformSubTab(button.dataset.subtab));
    });

    if (platformSubTabButtons.length > 0) {
      setActivePlatformSubTab('sales');
    }

    function updateStickyOffset() {
      const headerEl = document.querySelector('header');
      const navEl = document.querySelector('.tab-nav');
      const headerHeight = headerEl ? headerEl.offsetHeight : 0;
      const navHeight = navEl ? navEl.offsetHeight : 0;
      let navTop = 0;
      if (navEl) {
        const computedTop = window.getComputedStyle(navEl).top;
        const numericTop = Number.parseFloat(computedTop || '0');
        navTop = Number.isFinite(numericTop) ? numericTop : 0;
      }
      const offset = headerHeight + navHeight + navTop + 24;
      document.documentElement.style.setProperty('--sticky-header-offset', `${offset}px`);
    }

    setActiveTab('regular');
    NEW_PRODUCT_PIVOT_CONFIGS.forEach((config) => updateNewProductFilterButtonState(config));
    updateStickyOffset();
    updateTabIndicator(activeTabId);
    window.addEventListener('resize', () => {
      updateStickyOffset();
      updateTabIndicator(activeTabId);
      resizeLoTableContainers();
      if (regularTableInitialised && regularTable) {
        applyTableHeight(regularTable);
      }
      if (mainTableInitialised && mainTable) {
        applyTableHeight(mainTable);
      }
    });

    function ensureHeaderMenu() {
      if (!headerMenuElement) {
        headerMenuElement = document.createElement('div');
        headerMenuElement.className = 'header-menu hidden';
        headerMenuElement.setAttribute('role', 'dialog');
        headerMenuElement.setAttribute('aria-modal', 'false');
        document.body.appendChild(headerMenuElement);

        document.addEventListener('click', (event) => {
          if (!headerMenuElement.classList.contains('hidden')) {
            const target = event.target;
            if (headerMenuElement && !headerMenuElement.contains(target) && !(target.closest('#regular-table thead')) && !(target.closest('#main-table thead'))) {
              closeHeaderMenu();
            }
          }
        });

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            closeHeaderMenu();
          }
        });

        window.addEventListener('resize', () => {
          if (!headerMenuElement.classList.contains('hidden') && activeHeaderCell) {
            positionHeaderMenu(activeHeaderCell);
          }
        });

        window.addEventListener('scroll', () => {
          if (!headerMenuElement.classList.contains('hidden') && activeHeaderCell) {
            positionHeaderMenu(activeHeaderCell);
          }
        }, { passive: true });
      }
    }

    function closeHeaderMenu() {
      if (headerMenuElement) {
        headerMenuElement.classList.add('hidden');
        headerMenuElement.innerHTML = '';
      }
      activeHeaderCell = null;
      activeColumnIndex = null;
    }

    function hasActiveColumnFilters(filters = columnFilters) {
      const source = filters || {};
      return Object.values(source).some((values) => Array.isArray(values) && values.length > 0);
    }

    function setFilterClearButtonsVisibility(buttons, isActive) {
      const shouldShow = Boolean(isActive);
      buttons.forEach((button) => {
        if (!button) {
          return;
        }
        if (shouldShow) {
          button.hidden = false;
          button.removeAttribute('aria-hidden');
          button.disabled = false;
        } else {
          button.hidden = true;
          button.setAttribute('aria-hidden', 'true');
          button.disabled = true;
        }
      });
    }

    function updateRegularFilterButtonState() {
      const isActive = hasActiveColumnFilters();
      const targets = regularFilterButtons.length
        ? regularFilterButtons
        : (regularFilterButtonElement ? [regularFilterButtonElement] : []);
      targets.forEach((button) => {
        if (button) {
          button.setAttribute('data-active', isActive ? 'true' : 'false');
        }
      });
      setFilterClearButtonsVisibility(regularFilterClearButtons, isActive);
    }

    function updateMainFilterButtonState() {
      const isActive = hasActiveColumnFilters(mainColumnFilters);
      const targets = mainFilterButtons.length
        ? mainFilterButtons
        : (mainFilterButtonElement ? [mainFilterButtonElement] : []);
      targets.forEach((button) => {
        if (button) {
          button.setAttribute('data-active', isActive ? 'true' : 'false');
        }
      });
      setFilterClearButtonsVisibility(mainFilterClearButtons, isActive);
    }

    function syncRegularFilterSelectionFromFilters(columnIndex) {
      if (!Number.isFinite(columnIndex)) {
        return;
      }
      if (!(regularFilterSelection instanceof Set)) {
        regularFilterSelection = new Set();
      }
      regularFilterSelection.clear();
      const options = columnValueOptions[columnIndex] || [];
      const activeValues = columnFilters[columnIndex];
      if (Array.isArray(activeValues) && activeValues.length > 0) {
        activeValues.forEach((value) => regularFilterSelection.add(value));
      } else {
        options.forEach((value) => regularFilterSelection.add(value));
      }
    }

    function syncMainFilterSelectionFromFilters(columnIndex) {
      if (!Number.isFinite(columnIndex)) {
        return;
      }
      if (!(mainFilterSelection instanceof Set)) {
        mainFilterSelection = new Set();
      }
      mainFilterSelection.clear();
      const options = mainColumnValueOptions[columnIndex] || [];
      const activeValues = mainColumnFilters[columnIndex];
      if (Array.isArray(activeValues) && activeValues.length > 0) {
        activeValues.forEach((value) => mainFilterSelection.add(value));
      } else {
        options.forEach((value) => mainFilterSelection.add(value));
      }
    }

    function updateRegularFilterSelectAllState() {
      if (!regularFilterSelectAllInput) {
        return;
      }
      const checkboxes = regularFilterOptionsElement
        ? Array.from(regularFilterOptionsElement.querySelectorAll('input[type="checkbox"]'))
        : [];
      if (!checkboxes.length) {
        regularFilterSelectAllInput.checked = false;
        regularFilterSelectAllInput.indeterminate = false;
        regularFilterSelectAllInput.disabled = true;
        return;
      }
      regularFilterSelectAllInput.disabled = false;
      let selectedCount = 0;
      checkboxes.forEach((checkbox) => {
        if (regularFilterSelection.has(checkbox.value)) {
          checkbox.checked = true;
          selectedCount += 1;
        } else {
          checkbox.checked = false;
        }
      });
      if (selectedCount === 0) {
        regularFilterSelectAllInput.checked = false;
        regularFilterSelectAllInput.indeterminate = false;
      } else if (selectedCount === checkboxes.length) {
        regularFilterSelectAllInput.checked = true;
        regularFilterSelectAllInput.indeterminate = false;
      } else {
        regularFilterSelectAllInput.checked = false;
        regularFilterSelectAllInput.indeterminate = true;
      }
    }

    function updateMainFilterSelectAllState() {
      if (!mainFilterSelectAllInput) {
        return;
      }
      const checkboxes = mainFilterOptionsElement
        ? Array.from(mainFilterOptionsElement.querySelectorAll('input[type="checkbox"]'))
        : [];
      if (!checkboxes.length) {
        mainFilterSelectAllInput.checked = false;
        mainFilterSelectAllInput.indeterminate = false;
        mainFilterSelectAllInput.disabled = true;
        return;
      }
      mainFilterSelectAllInput.disabled = false;
      let selectedCount = 0;
      checkboxes.forEach((checkbox) => {
        if (mainFilterSelection.has(checkbox.value)) {
          checkbox.checked = true;
          selectedCount += 1;
        } else {
          checkbox.checked = false;
        }
      });
      if (selectedCount === 0) {
        mainFilterSelectAllInput.checked = false;
        mainFilterSelectAllInput.indeterminate = false;
      } else if (selectedCount === checkboxes.length) {
        mainFilterSelectAllInput.checked = true;
        mainFilterSelectAllInput.indeterminate = false;
      } else {
        mainFilterSelectAllInput.checked = false;
        mainFilterSelectAllInput.indeterminate = true;
      }
    }

    function renderRegularFilterOptions() {
      if (!regularFilterOptionsElement || !Number.isFinite(regularFilterActiveColumnIndex)) {
        return;
      }
      const allOptions = columnValueOptions[regularFilterActiveColumnIndex] || [];
      const normalizedQuery = regularFilterSearchTerm.trim().toLowerCase();
      const filteredOptions = normalizedQuery.length
        ? allOptions.filter((value) => optionLabel(value).toLowerCase().includes(normalizedQuery))
        : allOptions.slice();

      if (!filteredOptions.length) {
        regularFilterOptionsElement.innerHTML = '';
      } else {
        const optionsMarkup = filteredOptions
          .map((value) => {
            const label = optionLabel(value);
            const safeLabel = escapeHtml(label);
            const safeValue = escapeHtml(value);
            const checkedAttr = regularFilterSelection.has(value) ? ' checked' : '';
            return `<label class="regular-filter__option"><input type="checkbox" value="${safeValue}"${checkedAttr}>${safeLabel}</label>`;
          })
          .join('');
        regularFilterOptionsElement.innerHTML = optionsMarkup;
        animateOptionList(regularFilterOptionsElement, '.regular-filter__option');
      }

      if (regularFilterEmptyElement) {
        regularFilterEmptyElement.hidden = filteredOptions.length !== 0;
      }
      updateRegularFilterSelectAllState();
    }

    function renderMainFilterOptions() {
      if (!mainFilterOptionsElement || !Number.isFinite(mainFilterActiveColumnIndex)) {
        return;
      }
      const allOptions = mainColumnValueOptions[mainFilterActiveColumnIndex] || [];
      const normalizedQuery = mainFilterSearchTerm.trim().toLowerCase();
      const filteredOptions = normalizedQuery.length
        ? allOptions.filter((value) => optionLabel(value).toLowerCase().includes(normalizedQuery))
        : allOptions.slice();

      if (!filteredOptions.length) {
        mainFilterOptionsElement.innerHTML = '';
      } else {
        const optionsMarkup = filteredOptions
          .map((value) => {
            const label = optionLabel(value);
            const safeLabel = escapeHtml(label);
            const safeValue = escapeHtml(value);
            const checkedAttr = mainFilterSelection.has(value) ? ' checked' : '';
            return `<label class="regular-filter__option"><input type="checkbox" value="${safeValue}"${checkedAttr}>${safeLabel}</label>`;
          })
          .join('');
        mainFilterOptionsElement.innerHTML = optionsMarkup;
        animateOptionList(mainFilterOptionsElement, '.regular-filter__option');
      }

      if (mainFilterEmptyElement) {
        mainFilterEmptyElement.hidden = filteredOptions.length !== 0;
      }
      updateMainFilterSelectAllState();
    }

    function setRegularFilterColumn(columnIndex) {
      if (!Number.isFinite(columnIndex)) {
        return;
      }
      regularFilterActiveColumnIndex = columnIndex;
      if (regularFilterColumnSelect) {
        regularFilterColumnSelect.value = String(columnIndex);
      }
      syncRegularFilterSelectionFromFilters(columnIndex);
      regularFilterSearchTerm = '';
      if (regularFilterSearchInput) {
        regularFilterSearchInput.value = '';
      }
      renderRegularFilterOptions();
    }

    function setMainFilterColumn(columnIndex) {
      if (!Number.isFinite(columnIndex)) {
        return;
      }
      mainFilterActiveColumnIndex = columnIndex;
      if (mainFilterColumnSelect) {
        mainFilterColumnSelect.value = String(columnIndex);
      }
      syncMainFilterSelectionFromFilters(columnIndex);
      mainFilterSearchTerm = '';
      if (mainFilterSearchInput) {
        mainFilterSearchInput.value = '';
      }
      renderMainFilterOptions();
    }

    function openRegularFilter(triggerButton = null) {
      if (!regularFilterContainerElement || !regularFilterInitialised) {
        return;
      }
      const targets = regularFilterButtons.length
        ? regularFilterButtons.slice()
        : (regularFilterButtonElement ? [regularFilterButtonElement] : []);
      if (triggerButton) {
        activeRegularFilterTrigger = triggerButton;
      } else if (!activeRegularFilterTrigger && targets.length) {
        activeRegularFilterTrigger = targets[0];
      }
      if (activeRegularFilterTrigger && !targets.includes(activeRegularFilterTrigger)) {
        targets.push(activeRegularFilterTrigger);
      }
      if (!Number.isFinite(regularFilterActiveColumnIndex)) {
        const selectedOption = regularFilterColumnSelect && regularFilterColumnSelect.value !== ''
          ? Number(regularFilterColumnSelect.value)
          : null;
        if (Number.isFinite(selectedOption)) {
          setRegularFilterColumn(selectedOption);
        } else if (regularFilterEligibleColumns.length) {
          setRegularFilterColumn(regularFilterEligibleColumns[0].index);
        }
      } else {
        syncRegularFilterSelectionFromFilters(regularFilterActiveColumnIndex);
        renderRegularFilterOptions();
      }
      showFilterContainer(regularFilterContainerElement);
      targets.forEach((button) => {
        if (button) {
          const expanded = button === activeRegularFilterTrigger;
          button.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      });
      requestAnimationFrame(() => {
        if (regularFilterSearchInput) {
          regularFilterSearchInput.focus();
        }
      });
    }

    function closeRegularFilter(options = {}) {
      if (!regularFilterContainerElement) {
        return;
      }
      const { returnFocus = true } = options;
      const previousTrigger = activeRegularFilterTrigger;
      hideFilterContainer(regularFilterContainerElement);
      const targets = regularFilterButtons.length
        ? regularFilterButtons
        : (regularFilterButtonElement ? [regularFilterButtonElement] : []);
      targets.forEach((button) => {
        if (button) {
          button.setAttribute('aria-expanded', 'false');
        }
      });
      activeRegularFilterTrigger = null;
      if (returnFocus && previousTrigger && typeof previousTrigger.focus === 'function') {
        previousTrigger.focus();
      }
    }

    function openMainFilter(triggerButton = null) {
      if (!mainFilterContainerElement || !mainFilterInitialised) {
        return;
      }
      const targets = mainFilterButtons.length
        ? mainFilterButtons.slice()
        : (mainFilterButtonElement ? [mainFilterButtonElement] : []);
      if (triggerButton) {
        activeMainFilterTrigger = triggerButton;
      } else if (!activeMainFilterTrigger && targets.length) {
        activeMainFilterTrigger = targets[0];
      }
      if (activeMainFilterTrigger && !targets.includes(activeMainFilterTrigger)) {
        targets.push(activeMainFilterTrigger);
      }
      if (!Number.isFinite(mainFilterActiveColumnIndex)) {
        const selectedOption = mainFilterColumnSelect && mainFilterColumnSelect.value !== ''
          ? Number(mainFilterColumnSelect.value)
          : null;
        if (Number.isFinite(selectedOption)) {
          setMainFilterColumn(selectedOption);
        } else if (mainFilterEligibleColumns.length) {
          setMainFilterColumn(mainFilterEligibleColumns[0].index);
        }
      } else {
        syncMainFilterSelectionFromFilters(mainFilterActiveColumnIndex);
        renderMainFilterOptions();
      }
      showFilterContainer(mainFilterContainerElement);
      targets.forEach((button) => {
        if (button) {
          const expanded = button === activeMainFilterTrigger;
          button.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        }
      });
      requestAnimationFrame(() => {
        if (mainFilterSearchInput) {
          mainFilterSearchInput.focus();
        }
      });
    }

    function closeMainFilter(options = {}) {
      if (!mainFilterContainerElement) {
        return;
      }
      const { returnFocus = true } = options;
      const previousTrigger = activeMainFilterTrigger;
      hideFilterContainer(mainFilterContainerElement);
      const targets = mainFilterButtons.length
        ? mainFilterButtons
        : (mainFilterButtonElement ? [mainFilterButtonElement] : []);
      targets.forEach((button) => {
        if (button) {
          button.setAttribute('aria-expanded', 'false');
        }
      });
      activeMainFilterTrigger = null;
      if (returnFocus && previousTrigger && typeof previousTrigger.focus === 'function') {
        previousTrigger.focus();
      }
    }

    function clearAllColumnFilters(table, filters = columnFilters, onChange = handleFilterChange) {
      const hasTable = table && typeof table.column === 'function';
      const filterSource = filters || {};
      const activeIndices = Object.keys(filterSource)
        .map((key) => Number(key))
        .filter((index) => Number.isFinite(index));
      if (!activeIndices.length) {
        if (Object.keys(filterSource).length) {
          if (filters === columnFilters) {
            columnFilters = {};
          } else {
            Object.keys(filterSource).forEach((key) => {
              delete filterSource[key];
            });
          }
          onChange();
        }
        return;
      }
      if (hasTable) {
        activeIndices.forEach((columnIndex) => {
          table.column(columnIndex).search('', false, false);
          const headerCell = table.column(columnIndex).header();
          if (headerCell) {
            headerCell.classList.remove('has-filter');
          }
        });
        table.draw();
      }
      if (filters === columnFilters) {
        columnFilters = {};
      } else {
        Object.keys(filterSource).forEach((key) => {
          delete filterSource[key];
        });
      }
      onChange();
    }

    function buildFilteredDataset(baseDataset, filters) {
      if (!baseDataset || !Array.isArray(baseDataset.columns) || !Array.isArray(baseDataset.rows)) {
        return baseDataset;
      }
      const filterEntries = Object.entries(filters || {})
        .map(([key, values]) => {
          const columnIndex = Number(key);
          if (!Number.isFinite(columnIndex)) {
            return null;
          }
          if (!Array.isArray(values) || values.length === 0) {
            return null;
          }
          return { columnIndex, values };
        })
        .filter(Boolean);
      if (!filterEntries.length) {
        return baseDataset;
      }
      const filteredRows = baseDataset.rows.filter((row) => {
        return filterEntries.every(({ columnIndex, values }) => {
          if (columnIndex < 0 || columnIndex >= baseDataset.columns.length) {
            return true;
          }
          const columnName = baseDataset.columns[columnIndex];
          const formattedValue = formatCellValue(row[columnIndex], columnName);
          return values.includes(formattedValue);
        });
      });
      return {
        columns: baseDataset.columns,
        rows: filteredRows,
      };
    }

    function handleFilterChange() {
      updateRegularFilterButtonState();
      if (!regularDatasetCache || !Array.isArray(regularDatasetCache.rows)) {
        return;
      }
      const animateRegular = regularTableInitialised && Boolean(regularTable);
      const animateLo = loTablesInitialised;
      const animatePlatform = platformTablesInitialised;
      const animateSku = skuSummaryInitialised;
      if (animateRegular) {
        setTabPanelLoading('regular', true, 'Applying filters…');
      }
      if (animateLo) {
        setTabPanelLoading('lo', true, 'Updating view…');
      }
      if (animatePlatform) {
        setTabPanelLoading('platform', true, 'Updating view…');
      }
      if (animateSku) {
        setTabPanelLoading('sku-summary', true, 'Updating summary…');
      }
      const filteredDataset = buildFilteredDataset(regularDatasetCache, columnFilters);
      if (loTablesInitialised) {
        updateLoTablesWithDataset(filteredDataset);
      }
      if (platformTablesInitialised) {
        updatePlatformTablesWithDataset(filteredDataset);
      }
      if (skuSummaryInitialised) {
        updateSkuSummaryWithDataset(filteredDataset);
      }
      requestAnimationFrame(() => {
        if (animateRegular) {
          setTabPanelLoading('regular', false);
        }
        if (animateLo) {
          setTabPanelLoading('lo', false);
        }
        if (animatePlatform) {
          setTabPanelLoading('platform', false);
        }
        if (animateSku) {
          setTabPanelLoading('sku-summary', false);
        }
      });
    }

    function handleMainFilterChange() {
      updateMainFilterButtonState();
      if (mainTableInitialised && mainTable) {
        requestAnimationFrame(() => updateMainTableFooter(mainTable));
      }
      const animateMain = mainTableInitialised && Boolean(mainTable);
      if (animateMain) {
        setTabPanelLoading('main', true, 'Applying filters…');
      }
      setTabPanelLoading('dashboard', true, 'Updating dashboard…');
      const datasetSource = mainDatasetCache
        ? Promise.resolve(mainDatasetCache)
        : fetchMainDataset();
      datasetSource
        .then((dataset) => {
          if (!dataset) {
            return;
          }
          ensureMainFilterSetup(dataset);
          const effectiveDataset = buildFilteredDataset(dataset, mainColumnFilters);
          const pivotResults = buildDashboardPivotResultsFromDataset(effectiveDataset);
          if (pivotResults instanceof Map) {
            mainDashboardPivotCache = pivotResults;
            mainDashboardInitialised = true;
            renderMainDashboard(pivotResults);
          }
        })
        .catch((error) => {
          console.error('Failed to update dashboard filters:', error);
        })
        .finally(() => {
          if (animateMain) {
            setTabPanelLoading('main', false);
          }
          setTabPanelLoading('dashboard', false);
        });
    }

    function initializeRegularFilterControls(augmentedDataset) {
      if (regularFilterInitialised) {
        return;
      }
      regularFilterButtonElement = document.getElementById('regular-filter-button');
      regularFilterContainerElement = document.getElementById('regular-filter');
      regularFilterColumnSelect = document.getElementById('regular-filter-column');
      regularFilterSearchInput = document.getElementById('regular-filter-search');
      regularFilterOptionsElement = document.getElementById('regular-filter-options');
      regularFilterEmptyElement = document.getElementById('regular-filter-empty');
      regularFilterSelectAllInput = document.getElementById('regular-filter-select-all');
      regularFilterApplyButton = document.getElementById('regular-filter-apply');
      regularFilterResetButton = document.getElementById('regular-filter-reset');
      regularFilterCloseButton = regularFilterContainerElement
        ? regularFilterContainerElement.querySelector('.regular-filter__close')
        : null;
      const skuFilterButton = document.getElementById('sku-filter-button');
      regularFilterButtons = [regularFilterButtonElement, loFilterButtonElement, platformFilterButtonElement, skuFilterButton].filter((button) => button);
      regularFilterClearButtons = [
        regularFilterClearButtonElement,
        loFilterClearButtonElement,
        platformFilterClearButtonElement,
        skuFilterClearButtonElement,
      ].filter((button) => button);

      const handleRegularClear = () => {
        const tableInstance = regularTableInitialised && regularTable ? regularTable : null;
        clearAllColumnFilters(tableInstance);
        closeRegularFilter({ returnFocus: false });
      };
      regularFilterClearButtons.forEach((button) => {
        button.addEventListener('click', handleRegularClear);
      });

      const elementsReady = [
        regularFilterButtonElement,
        regularFilterContainerElement,
        regularFilterColumnSelect,
        regularFilterSearchInput,
        regularFilterOptionsElement,
        regularFilterEmptyElement,
        regularFilterSelectAllInput,
        regularFilterApplyButton,
        regularFilterResetButton,
        regularFilterCloseButton,
      ].every(Boolean);

      if (!elementsReady) {
        return;
      }

      const filterTargets = regularFilterButtons.length
        ? regularFilterButtons
        : [regularFilterButtonElement];

      const registerFilterButton = (button) => {
        if (!button) {
          return;
        }
        button.addEventListener('click', () => {
          const isVisible = regularFilterContainerElement.classList.contains('is-visible');
          if (isVisible && activeRegularFilterTrigger === button) {
            closeRegularFilter();
          } else {
            openRegularFilter(button);
          }
        });
      };

      filterTargets.forEach(registerFilterButton);

      const columns = Array.isArray(augmentedDataset?.columns)
        ? augmentedDataset.columns
            .map((title, index) => ({
              title: title || `Column ${index + 1}`,
              index,
              options: columnValueOptions[index] || [],
            }))
            .filter((entry) => entry.options.length > 0 && entry.options.length <= REGULAR_FILTER_MAX_UNIQUE_VALUES)
        : [];

      if (!columns.length) {
        filterTargets.forEach((button) => {
          if (button) {
            button.setAttribute('aria-disabled', 'true');
            button.disabled = true;
          }
        });
        return;
      }

      filterTargets.forEach((button) => {
        if (button) {
          button.removeAttribute('aria-disabled');
          button.disabled = false;
        }
      });

      regularFilterEligibleColumns = columns;
      const optionsMarkup = columns
        .map((entry) => `<option value="${entry.index}">${escapeHtml(entry.title)}</option>`)
        .join('');
      regularFilterColumnSelect.innerHTML = optionsMarkup;

      regularFilterCloseButton.addEventListener('click', () => closeRegularFilter());

      regularFilterContainerElement.addEventListener('click', (event) => {
        const target = event.target;
        if (target === regularFilterContainerElement || (target instanceof HTMLElement && target.classList.contains('regular-filter__backdrop'))) {
          closeRegularFilter();
        }
      });

      regularFilterColumnSelect.addEventListener('change', (event) => {
        const selectedValue = Number(event.target.value);
        if (Number.isFinite(selectedValue)) {
          setRegularFilterColumn(selectedValue);
        }
      });

      regularFilterSearchInput.addEventListener('input', (event) => {
        regularFilterSearchTerm = event.target.value || '';
        renderRegularFilterOptions();
      });

      regularFilterOptionsElement.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement) || target.type !== 'checkbox') {
          return;
        }
        const value = target.value;
        if (target.checked) {
          regularFilterSelection.add(value);
        } else {
          regularFilterSelection.delete(value);
        }
        updateRegularFilterSelectAllState();
      });

      regularFilterSelectAllInput.addEventListener('change', (event) => {
        if (!Number.isFinite(regularFilterActiveColumnIndex)) {
          return;
        }
        const selectAll = event.target.checked;
        const allOptions = columnValueOptions[regularFilterActiveColumnIndex] || [];
        if (selectAll) {
          regularFilterSelection = new Set(allOptions);
        } else {
          regularFilterSelection = new Set();
        }
        renderRegularFilterOptions();
      });

      regularFilterApplyButton.addEventListener('click', () => {
        if (!Number.isFinite(regularFilterActiveColumnIndex)) {
          return;
        }
        flashButtonBusy(regularFilterApplyButton);
        const tableInstance = regularTableInitialised && regularTable ? regularTable : null;
        const allOptions = columnValueOptions[regularFilterActiveColumnIndex] || [];
        const selectedValues = Array.from(regularFilterSelection);
        const valuesToApply = selectedValues.length === allOptions.length ? [] : selectedValues;
        const headerCell = tableInstance ? tableInstance.column(regularFilterActiveColumnIndex).header() : null;
        applyColumnFilter(tableInstance, regularFilterActiveColumnIndex, valuesToApply, headerCell);
        closeRegularFilter();
      });

      regularFilterResetButton.addEventListener('click', () => {
        const tableInstance = regularTableInitialised && regularTable ? regularTable : null;
        clearAllColumnFilters(tableInstance);
        if (Number.isFinite(regularFilterActiveColumnIndex)) {
          syncRegularFilterSelectionFromFilters(regularFilterActiveColumnIndex);
          renderRegularFilterOptions();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && regularFilterContainerElement.classList.contains('is-visible')) {
          closeRegularFilter();
        }
      });

      regularFilterInitialised = true;
      updateRegularFilterButtonState();

      const firstColumn = columns[0];
      if (firstColumn) {
        setRegularFilterColumn(firstColumn.index);
      }
    }

    function initializeMainFilterControls(augmentedDataset) {
      if (mainFilterInitialised) {
        return;
      }
      mainFilterButtonElement = document.getElementById('main-filter-button');
      mainFilterContainerElement = document.getElementById('main-filter');
      mainFilterColumnSelect = document.getElementById('main-filter-column');
      mainFilterSearchInput = document.getElementById('main-filter-search');
      mainFilterOptionsElement = document.getElementById('main-filter-options');
      mainFilterEmptyElement = document.getElementById('main-filter-empty');
      mainFilterSelectAllInput = document.getElementById('main-filter-select-all');
      mainFilterApplyButton = document.getElementById('main-filter-apply');
      mainFilterResetButton = document.getElementById('main-filter-reset');
      mainFilterCloseButton = mainFilterContainerElement
        ? mainFilterContainerElement.querySelector('.regular-filter__close')
        : null;
      mainFilterButtons = [mainFilterButtonElement, dashboardFilterButtonElement].filter((button) => button);
      mainFilterClearButtons = [mainFilterClearButtonElement, dashboardFilterClearButtonElement].filter((button) => button);

      const handleMainClear = () => {
        const tableInstance = mainTableInitialised && mainTable ? mainTable : null;
        clearAllColumnFilters(tableInstance, mainColumnFilters, handleMainFilterChange);
        closeMainFilter({ returnFocus: false });
      };
      mainFilterClearButtons.forEach((button) => {
        button.addEventListener('click', handleMainClear);
      });

      const elementsReady = [
        mainFilterButtonElement,
        mainFilterContainerElement,
        mainFilterColumnSelect,
        mainFilterSearchInput,
        mainFilterOptionsElement,
        mainFilterEmptyElement,
        mainFilterSelectAllInput,
        mainFilterApplyButton,
        mainFilterResetButton,
        mainFilterCloseButton,
      ].every(Boolean);

      if (!elementsReady) {
        return;
      }

      const filterTargets = mainFilterButtons.length
        ? mainFilterButtons
        : [mainFilterButtonElement];

      const registerFilterButton = (button) => {
        if (!button) {
          return;
        }
        button.addEventListener('click', () => {
          const isVisible = mainFilterContainerElement.classList.contains('is-visible');
          if (isVisible && activeMainFilterTrigger === button) {
            closeMainFilter();
          } else {
            openMainFilter(button);
          }
        });
      };

      filterTargets.forEach(registerFilterButton);

      const columns = Array.isArray(augmentedDataset?.columns)
        ? augmentedDataset.columns
            .map((title, index) => ({
              title: title || `Column ${index + 1}`,
              index,
              options: mainColumnValueOptions[index] || [],
            }))
            .filter((entry) => entry.options.length > 0 && entry.options.length <= REGULAR_FILTER_MAX_UNIQUE_VALUES)
        : [];

      if (!columns.length) {
        filterTargets.forEach((button) => {
          if (button) {
            button.setAttribute('aria-disabled', 'true');
            button.disabled = true;
          }
        });
        return;
      }

      filterTargets.forEach((button) => {
        if (button) {
          button.removeAttribute('aria-disabled');
          button.disabled = false;
        }
      });

      mainFilterEligibleColumns = columns;
      const optionsMarkup = columns
        .map((entry) => `<option value="${entry.index}">${escapeHtml(entry.title)}</option>`)
        .join('');
      mainFilterColumnSelect.innerHTML = optionsMarkup;

      mainFilterCloseButton.addEventListener('click', () => closeMainFilter());
      mainFilterContainerElement.addEventListener('click', (event) => {
        const target = event.target;
        if (target === mainFilterContainerElement || (target instanceof HTMLElement && target.classList.contains('regular-filter__backdrop'))) {
          closeMainFilter();
        }
      });

      mainFilterColumnSelect.addEventListener('change', (event) => {
        const selectedValue = Number(event.target.value);
        if (Number.isFinite(selectedValue)) {
          setMainFilterColumn(selectedValue);
        }
      });

      mainFilterSearchInput.addEventListener('input', (event) => {
        mainFilterSearchTerm = event.target.value || '';
        renderMainFilterOptions();
      });

      mainFilterOptionsElement.addEventListener('change', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLInputElement) || target.type !== 'checkbox') {
          return;
        }
        if (!mainFilterSelection) {
          mainFilterSelection = new Set();
        }
        if (target.checked) {
          mainFilterSelection.add(target.value);
        } else {
          mainFilterSelection.delete(target.value);
        }
        updateMainFilterSelectAllState();
      });

      mainFilterSelectAllInput.addEventListener('change', (event) => {
        if (!Number.isFinite(mainFilterActiveColumnIndex)) {
          return;
        }
        const selectAll = event.target.checked;
        const allOptions = mainColumnValueOptions[mainFilterActiveColumnIndex] || [];
        if (selectAll) {
          mainFilterSelection = new Set(allOptions);
        } else {
          mainFilterSelection = new Set();
        }
        renderMainFilterOptions();
      });

      mainFilterApplyButton.addEventListener('click', () => {
        if (!Number.isFinite(mainFilterActiveColumnIndex)) {
          return;
        }
        flashButtonBusy(mainFilterApplyButton);
        const tableInstance = mainTableInitialised && mainTable ? mainTable : null;
        const allOptions = mainColumnValueOptions[mainFilterActiveColumnIndex] || [];
        const selectedValues = Array.from(mainFilterSelection);
        const valuesToApply = selectedValues.length === allOptions.length ? [] : selectedValues;
        const headerCell = tableInstance ? tableInstance.column(mainFilterActiveColumnIndex).header() : null;
        applyColumnFilter(tableInstance, mainFilterActiveColumnIndex, valuesToApply, headerCell, {
          filters: mainColumnFilters,
          onChange: handleMainFilterChange,
        });
        closeMainFilter();
      });

      mainFilterResetButton.addEventListener('click', () => {
        const tableInstance = mainTableInitialised && mainTable ? mainTable : null;
        clearAllColumnFilters(tableInstance, mainColumnFilters, handleMainFilterChange);
        if (Number.isFinite(mainFilterActiveColumnIndex)) {
          syncMainFilterSelectionFromFilters(mainFilterActiveColumnIndex);
          renderMainFilterOptions();
        }
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && mainFilterContainerElement.classList.contains('is-visible')) {
          closeMainFilter();
        }
      });

      mainFilterInitialised = true;
      updateMainFilterButtonState();

      const firstColumn = columns[0];
      if (firstColumn) {
        setMainFilterColumn(firstColumn.index);
      }
    }

    function ensureMainFilterSetup(dataset) {
      if (!dataset || !Array.isArray(dataset.columns)) {
        return;
      }
      if (!mainTableAugmentedDataset) {
        mainTableAugmentedDataset = augmentDatasetWithTotals(dataset);
      }
      const augmented = mainTableAugmentedDataset;
      if (!augmented || !Array.isArray(augmented.columns) || !augmented.columns.length) {
        return;
      }
      if (!Array.isArray(mainColumnValueOptions) || !mainColumnValueOptions.length) {
        mainColumnValueOptions = buildColumnOptions(augmented);
      }
      if (!mainFilterInitialised) {
        initializeMainFilterControls(augmented);
      }
    }

    function escapeRegex(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function optionLabel(value) {
      const normalized = value === null || value === undefined ? '' : String(value);
      return normalized === '' ? '(Blank)' : normalized;
    }

    function escapeHtml(value) {
      return String(value).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }

    function applyColumnFilter(table, columnIndex, values, headerCell, options = {}) {
      if (!Number.isFinite(columnIndex)) {
        return;
      }
      const safeValues = Array.isArray(values) ? values.slice() : [];
      const hasTable = table && typeof table.column === 'function';
      const filters = options.filters || columnFilters;
      const onChange = typeof options.onChange === 'function' ? options.onChange : handleFilterChange;
      if (safeValues.length === 0) {
        if (hasTable) {
          table.column(columnIndex).search('', false, false).draw();
        }
        if (filters && typeof filters === 'object') {
          delete filters[columnIndex];
        }
        if (headerCell) {
          headerCell.classList.remove('has-filter');
        } else if (hasTable) {
          const tableHeaderCell = table.column(columnIndex).header();
          if (tableHeaderCell) {
            tableHeaderCell.classList.remove('has-filter');
          }
        }
        onChange();
        return;
      }
      if (hasTable) {
        const regex = `^(${safeValues.map((value) => escapeRegex(value)).join('|')})$`;
        table.column(columnIndex).search(regex, true, false).draw();
      }
      if (filters && typeof filters === 'object') {
        filters[columnIndex] = safeValues;
      }
      if (headerCell) {
        headerCell.classList.add('has-filter');
      } else if (hasTable) {
        const tableHeaderCell = table.column(columnIndex).header();
        if (tableHeaderCell) {
          tableHeaderCell.classList.add('has-filter');
        }
      }
      onChange();
    }

    function positionHeaderMenu(headerCell) {
      if (!headerMenuElement) return;
      const rect = headerCell.getBoundingClientRect();
      const top = rect.bottom + window.scrollY + 8;
      const left = rect.left + window.scrollX;
      headerMenuElement.style.top = `${top}px`;
      headerMenuElement.style.left = `${left}px`;
    }

    function openHeaderMenu(headerCell, table, options = {}) {
      ensureHeaderMenu();
      if (!headerMenuElement) return;

      activeHeaderCell = headerCell;
      const dataTableIndexAttr = headerCell.getAttribute('data-dt-column');
      if (dataTableIndexAttr !== null && dataTableIndexAttr !== '') {
        activeColumnIndex = Number(dataTableIndexAttr);
      } else if (headerCell.dataset.columnIndex) {
        activeColumnIndex = Number(headerCell.dataset.columnIndex);
      } else {
        activeColumnIndex = headerCell.cellIndex ?? 0;
      }
      const columnTitle = headerCell.textContent.trim();
      const valueOptions = Array.isArray(options.valueOptions) ? options.valueOptions : columnValueOptions;
      const filters = options.filters || columnFilters;
      const onChange = typeof options.onChange === 'function' ? options.onChange : handleFilterChange;
      const optionsForColumn = Array.isArray(valueOptions) ? valueOptions[activeColumnIndex] || [] : [];
      const selectedValues = filters[activeColumnIndex] ? [...filters[activeColumnIndex]] : [];
      const sortingEnabled = options.allowSorting !== false;

      const optionsMarkup = optionsForColumn.map((value) => {
        const checked = selectedValues.includes(value) ? 'checked' : '';
        const rawLabel = optionLabel(value);
        const safeLabel = escapeHtml(rawLabel);
        const safeValueAttr = escapeHtml(value);
        const dataLabel = escapeHtml(rawLabel.toLowerCase());
        return `<label class="header-menu__option" data-label="${dataLabel}"><input type="checkbox" value="${safeValueAttr}" ${checked}>${safeLabel}</label>`;
      }).join('');
      const hasOptions = optionsForColumn.length > 0;

      const sortControlsMarkup = sortingEnabled
        ? `
        <div class="header-menu__section">
          <div class="header-menu__buttons">
            <button type="button" class="header-menu__button" data-sort="asc">Sort ascending</button>
            <button type="button" class="header-menu__button" data-sort="desc">Sort descending</button>
          </div>
        </div>`
        : '';

      headerMenuElement.innerHTML = `
        <div class="header-menu__header">
          <h3 class="header-menu__title">${columnTitle}</h3>
          <button type="button" class="header-menu__close" aria-label="Close menu">&times;</button>
        </div>
        ${sortControlsMarkup}
        <div class="header-menu__section">
          <label for="header-menu-search" class="sr-only">Search values</label>
          <input id="header-menu-search" class="header-menu__search" type="search" placeholder="Search values" autocomplete="off">
        </div>
        <div class="header-menu__section">
          <div class="header-menu__options" role="group" aria-label="Filter values">
            ${hasOptions ? optionsMarkup : ''}
          </div>
          ${hasOptions ? '<div class="header-menu__empty-message" hidden>No matches found</div>' : '<p style="margin:0.5rem 0 0;color:var(--muted);font-size:0.85rem;">No values available</p>'}
        </div>
        <div class="header-menu__footer">
          <button type="button" class="header-menu__clear">Clear</button>
          <button type="button" class="header-menu__apply">Apply</button>
        </div>
      `;

      animateOptionList(headerMenuElement.querySelector('.header-menu__options'), '.header-menu__option');

      headerMenuElement.classList.remove('hidden');
      positionHeaderMenu(headerCell);

      const closeButton = headerMenuElement.querySelector('.header-menu__close');
      closeButton?.addEventListener('click', () => closeHeaderMenu());

      const sortButtons = headerMenuElement.querySelectorAll('[data-sort]');
      sortButtons.forEach((button) => {
        button.addEventListener('click', (event) => {
          const direction = event.currentTarget.getAttribute('data-sort');
          table.order([activeColumnIndex, direction]).draw();
          closeHeaderMenu();
        });
      });

      const optionsContainer = headerMenuElement.querySelector('.header-menu__options');
      const searchInput = headerMenuElement.querySelector('#header-menu-search');
      const emptyMessage = headerMenuElement.querySelector('.header-menu__empty-message');
      if (!hasOptions && searchInput) {
        searchInput.disabled = true;
        searchInput.placeholder = 'No values available';
      }
      searchInput?.addEventListener('input', (event) => {
        const query = event.currentTarget.value.trim().toLowerCase();
        const labels = optionsContainer ? optionsContainer.querySelectorAll('.header-menu__option') : [];
        let visibleCount = 0;
        labels.forEach((labelEl) => {
          const labelValue = labelEl.getAttribute('data-label') || '';
          const isVisible = labelValue.includes(query);
          labelEl.style.display = isVisible ? 'flex' : 'none';
          if (isVisible) {
            visibleCount += 1;
          }
        });
        if (emptyMessage) {
          emptyMessage.hidden = visibleCount !== 0;
        }
      });

      const applyButton = headerMenuElement.querySelector('.header-menu__apply');
      applyButton?.addEventListener('click', () => {
        const checkedInputs = optionsContainer ? Array.from(optionsContainer.querySelectorAll('input[type="checkbox"]')).filter((input) => input.checked) : [];
        const values = checkedInputs.map((input) => input.value);
        applyColumnFilter(table, activeColumnIndex, values, headerCell, { filters, onChange });
        closeHeaderMenu();
      });

      const clearButton = headerMenuElement.querySelector('.header-menu__clear');
      clearButton?.addEventListener('click', () => {
        if (optionsContainer) {
          optionsContainer.querySelectorAll('input[type="checkbox"]').forEach((input) => {
            input.checked = false;
          });
        }
        applyColumnFilter(table, activeColumnIndex, [], headerCell, { filters, onChange });
        closeHeaderMenu();
      });
    }

    function buildColumnOptions(dataset) {
      const sets = dataset.columns.map(() => new Set());
      dataset.rows.forEach((row) => {
        row.forEach((value, index) => {
          const columnName = dataset.columns[index];
          const formatted = formatCellValue(value, columnName);
          sets[index].add(formatted);
        });
      });
      return sets.map((set) => Array.from(set).sort((a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' })));
    }

    function wireHeaderEvents(table, options = {}) {
      const container = table.table().container();
      const headerCells = Array.from(container.querySelectorAll('thead th'));

      headerCells.forEach((cell, index) => {
        if (!cell.dataset.columnIndex) {
          cell.dataset.columnIndex = String(index);
        }
        cell.classList.add('is-filterable');
        cell.classList.remove('is-static');
        cell.style.cursor = '';
        cell.removeAttribute('aria-disabled');
      });

      $(headerCells).off('click.DT keypress.DT');
      headerCells.forEach((cell, index) => {
        const existingHandler = headerClickHandlers.get(cell);
        if (existingHandler) {
          cell.removeEventListener('click', existingHandler);
          headerClickHandlers.delete(cell);
        }
        const totalIndex = Number.isFinite(options.totalIndex) ? options.totalIndex : totalColumnIndex;
        const isTotalColumn = Number.isFinite(totalIndex) && totalIndex >= 0 && index === totalIndex;
        if (isTotalColumn) {
          return;
        }
        const handler = (event) => {
          event.preventDefault();
          event.stopPropagation();
          openHeaderMenu(cell, table, options);
        };
        headerClickHandlers.set(cell, handler);
        cell.addEventListener('click', handler);
      });
    }

    function isPlaceholderValue(value) {
      if (value === null || value === undefined) {
        return true;
      }
      const normalized = typeof value === 'string' ? value.trim() : value;
      return normalized === '' || normalized === '-' || normalized === '--';
    }

    function parseNumericValue(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        return value;
      }
      if (typeof value === 'string') {
        const trimmed = value.trim();
        if (isPlaceholderValue(trimmed)) {
          return null;
        }
        const numeric = Number(trimmed.replace(/,/g, ''));
        return Number.isNaN(numeric) ? null : numeric;
      }
      return null;
    }

    function parseExcelSerialToDate(value) {
      const numeric = parseNumericValue(value);
      if (numeric === null) {
        return null;
      }
      const serial = Math.floor(numeric);
      if (serial <= 0) {
        return null;
      }
      const fractional = numeric - serial;
      const adjustedSerial = serial >= 60 ? serial - 1 : serial;
      const excelEpoch = Date.UTC(1899, 11, 31);
      const dayMilliseconds = 24 * 60 * 60 * 1000;
      const timestamp = excelEpoch + adjustedSerial * dayMilliseconds + Math.round(fractional * dayMilliseconds);
      const date = new Date(timestamp);
      return Number.isNaN(date.getTime()) ? null : date;
    }

    function formatExcelSerialDate(value) {
      const date = parseExcelSerialToDate(value);
      if (!date) {
        return null;
      }
      const day = String(date.getUTCDate()).padStart(2, '0');
      const month = String(date.getUTCMonth() + 1).padStart(2, '0');
      const year = date.getUTCFullYear();
      return `${day}-${month}-${year}`;
    }

    function detectNumericColumns(dataset) {
      return dataset.columns.reduce((accumulator, column, columnIndex) => {
        const normalizedColumn = column ? column.toUpperCase().trim() : '';
        if (NUMERIC_COLUMN_EXCLUSIONS.has(normalizedColumn)) {
          return accumulator;
        }
        let hasNumeric = false;
        const isNumericColumn = dataset.rows.every((row) => {
          const value = row[columnIndex];
          if (isPlaceholderValue(value)) {
            return true;
          }
          const numericValue = parseNumericValue(value);
          if (numericValue === null) {
            return false;
          }
          hasNumeric = true;
          return true;
        });
        if (isNumericColumn && hasNumeric) {
          accumulator.push(columnIndex);
        }
        return accumulator;
      }, []);
    }

    function formatCellValue(value, columnName) {
      if (isPlaceholderValue(value)) {
        return typeof value === 'string' ? value.trim() : '';
      }
      const normalizedColumn = columnName ? columnName.trim().toLowerCase() : '';
      if (normalizedColumn === 'checkout') {
        const formattedDate = formatExcelSerialDate(value);
        if (formattedDate) {
          return formattedDate;
        }
      }
      const numericValue = parseNumericValue(value);
      if (numericValue !== null) {
        const decimals = ZERO_DECIMAL_COLUMNS.has(normalizedColumn) ? 0 : 2;
        return numericValue.toFixed(decimals);
      }
      return typeof value === 'string' ? value : String(value ?? '');
    }

    const RATIO_EPSILON = 1e-9;

    function getRatioMultiplier(computedConfig) {
      if (!computedConfig || typeof computedConfig !== 'object') {
        return 100;
      }
      const { multiplier, asPercentage } = computedConfig;
      if (typeof multiplier === 'number' && Number.isFinite(multiplier)) {
        return multiplier;
      }
      if (asPercentage === false) {
        return 1;
      }
      return 100;
    }

    function formatDashboardRatioValue(metric, columnConfig) {
      if (!metric) {
        return '';
      }
      const numeratorHasValue = Boolean(metric.numeratorHasValue);
      const denominatorHasValue = Boolean(metric.denominatorHasValue);
      if (!numeratorHasValue && !denominatorHasValue) {
        return '';
      }
      const denominator = typeof metric.denominator === 'number' ? metric.denominator : 0;
      if (!denominatorHasValue || Math.abs(denominator) < RATIO_EPSILON) {
        return numeratorHasValue ? '#DIV/0!' : '';
      }
      const numerator = typeof metric.numerator === 'number' ? metric.numerator : 0;
      const multiplier = getRatioMultiplier(columnConfig?.computed);
      const ratioValue = (numerator / denominator) * multiplier;
      const columnName = columnConfig?.header || columnConfig?.source;
      return formatCellValue(ratioValue, columnName);
    }

    function augmentDatasetWithTotals(dataset) {
      if (!dataset || !Array.isArray(dataset.columns) || !Array.isArray(dataset.rows)) {
        return {
          columns: [],
          rows: [],
          totalsRow: [],
          numericColumnIndices: [],
          totalColumnIndex: -1,
        };
      }

      const baseColumns = dataset.columns.slice();
      const numericColumnIndices = detectNumericColumns(dataset);
      const totalsByColumn = new Map();
      numericColumnIndices.forEach((index) => totalsByColumn.set(index, 0));

      const augmentedRows = dataset.rows.map((row) => {
        const newRow = row.slice();
        numericColumnIndices.forEach((columnIndex) => {
          const numericValue = parseNumericValue(row[columnIndex]);
          if (numericValue === null) {
            return;
          }
          totalsByColumn.set(columnIndex, (totalsByColumn.get(columnIndex) ?? 0) + numericValue);
        });
        return newRow;
      });

      const totalsRow = new Array(baseColumns.length).fill('');
      if (totalsRow.length > 0) {
        totalsRow[0] = TOTAL_ROW_LABEL;
      }

      numericColumnIndices.forEach((columnIndex) => {
        const total = totalsByColumn.get(columnIndex);
        if (typeof total === 'number' && Number.isFinite(total)) {
          totalsRow[columnIndex] = total;
        } else {
          totalsRow[columnIndex] = 0;
        }
      });

      const augmented = {
        columns: baseColumns,
        rows: augmentedRows,
        totalsRow,
        numericColumnIndices,
        totalColumnIndex: -1,
      };
      if (dataset.headerPreamble && Array.isArray(dataset.headerPreamble.rows)) {
        augmented.headerPreamble = dataset.headerPreamble;
      }
      return augmented;
    }

    function buildFormattedFooterValues(augmentedDataset) {
      if (!augmentedDataset || !Array.isArray(augmentedDataset.columns) || !Array.isArray(augmentedDataset.totalsRow)) {
        return [];
      }
      const numericColumns = new Set(augmentedDataset.numericColumnIndices || []);
      return augmentedDataset.totalsRow.map((value, index) => {
        if (index === 0) {
          const label = typeof value === 'string' && value.trim().length ? value : TOTAL_ROW_LABEL;
          return label;
        }
        if (numericColumns.has(index)) {
          return formatCellValue(value, augmentedDataset.columns[index]);
        }
        if (value === null || value === undefined) {
          return '';
        }
        return typeof value === 'string' ? value : String(value);
      });
    }

    function calculateRegularTableFooterValues(table) {
      if (!table || !regularTableAugmentedDataset) {
        return regularTableFooterValues;
      }

      const columns = Array.isArray(regularTableAugmentedDataset.columns)
        ? regularTableAugmentedDataset.columns
        : [];
      const columnCount = columns.length;
      if (columnCount === 0) {
        return [];
      }

      const baseValues = buildFormattedFooterValues(regularTableAugmentedDataset);
      const values = Array.isArray(baseValues) && baseValues.length === columnCount
        ? baseValues.slice()
        : (() => {
            const fallback = new Array(columnCount).fill('');
            const totalsRow = Array.isArray(regularTableAugmentedDataset.totalsRow)
              ? regularTableAugmentedDataset.totalsRow
              : [];
            const labelValue = totalsRow[0];
            if (typeof labelValue === 'string' && labelValue.trim().length) {
              fallback[0] = labelValue;
            } else {
              fallback[0] = TOTAL_ROW_LABEL;
            }
            return fallback;
          })();

      if (!regularTableNumericColumnSet || regularTableNumericColumnSet.size === 0) {
        return values;
      }

      const filteredRows = table.rows({ search: 'applied' }).data().toArray();

      regularTableNumericColumnSet.forEach((columnIndex) => {
        if (typeof columnIndex !== 'number' || columnIndex < 0 || columnIndex >= columnCount) {
          return;
        }
        let sum = 0;
        let hasValue = false;
        filteredRows.forEach((row) => {
          if (!row || columnIndex >= row.length) {
            return;
          }
          const numericValue = parseNumericValue(row[columnIndex]);
          if (numericValue !== null) {
            sum += numericValue;
            hasValue = true;
          }
        });

        const formattedTotal = hasValue
          ? formatCellValue(sum, columns[columnIndex])
          : formatCellValue(0, columns[columnIndex]);
        values[columnIndex] = formattedTotal;
      });

      return values;
    }

    function updateRegularTableFooter(table) {
      if (!SHOW_REGULAR_TOTAL_ROW || !table) {
        return;
      }
      regularTableFooterValues = calculateRegularTableFooterValues(table);
      renderFooterRow(table, regularTableFooterValues, regularTableNumericColumnSet, totalColumnIndex);
    }

    function findColumnIndex(dataset, targetName) {
      if (!dataset || !Array.isArray(dataset.columns)) {
        return -1;
      }
      const normalizedTarget = targetName ? targetName.trim().toLowerCase() : '';
      return dataset.columns.findIndex((column) => (column || '').trim().toLowerCase() === normalizedTarget);
    }

    function formatTwoDecimal(value) {
      const numeric = Number.isFinite(value) ? value : 0;
      return numberFormatter.format(numeric);
    }

    function buildDailyPivot(dataset, dimensionColumnName, targetColumnName, options = {}) {
      if (!dataset || !Array.isArray(dataset.rows)) {
        return { loList: [], rows: [], totals: [], order: [], displayNames: new Map() };
      }

      const checkoutIndex = findColumnIndex(dataset, 'checkout');
      const dimensionIndex = findColumnIndex(dataset, dimensionColumnName);
      const valueIndex = findColumnIndex(dataset, targetColumnName);

      if (checkoutIndex < 0 || dimensionIndex < 0 || valueIndex < 0) {
        return { loList: [], rows: [], totals: [], order: [], displayNames: new Map() };
      }

      const normalizedOrder = Array.isArray(options.normalizedOrder) ? options.normalizedOrder : null;
      const normalizedDisplayOverrides = options.displayNameOverrides instanceof Map
        ? options.displayNameOverrides
        : (options.displayNameOverrides && typeof options.displayNameOverrides === 'object'
          ? new Map(Object.entries(options.displayNameOverrides))
          : new Map());
      const fallbackLabel = typeof options.fallbackLabel === 'string' && options.fallbackLabel.trim().length
        ? options.fallbackLabel.trim()
        : 'Unassigned';

      const dimensionLabels = new Map();
      const dimensionTotals = new Map();
      const dateMap = new Map();

      dataset.rows.forEach((row) => {
        const date = parseExcelSerialToDate(row[checkoutIndex]);
        if (!date) {
          return;
        }
        const isoKey = date.toISOString().slice(0, 10);
        const rawLabel = row[dimensionIndex];
        let label = '';
        if (typeof rawLabel === 'string') {
          label = rawLabel.trim();
        } else if (rawLabel === null || rawLabel === undefined) {
          label = '';
        } else {
          label = String(rawLabel).trim();
        }
        const effectiveLabel = label || fallbackLabel;
        const normalizedLabel = effectiveLabel.toLocaleLowerCase();
        const displayName = normalizedDisplayOverrides.get(normalizedLabel) ?? effectiveLabel;

        const rawValue = row[valueIndex];
        const numericValue = parseNumericValue(rawValue);
        const value = numericValue === null ? 0 : numericValue;

        if (!dimensionLabels.has(normalizedLabel)) {
          dimensionLabels.set(normalizedLabel, displayName);
        }
        dimensionTotals.set(normalizedLabel, (dimensionTotals.get(normalizedLabel) ?? 0) + value);
        if (!dateMap.has(isoKey)) {
          dateMap.set(isoKey, { date, values: new Map() });
        }
        const entry = dateMap.get(isoKey);
        entry.values.set(normalizedLabel, (entry.values.get(normalizedLabel) ?? 0) + value);
      });

      if (dimensionLabels.size === 0) {
        return { loList: [], rows: [], totals: [], order: [], displayNames: new Map() };
      }

      let dimensionOrder;
      if (normalizedOrder && normalizedOrder.length) {
        const orderSet = new Set();
        dimensionOrder = normalizedOrder.filter((key) => {
          if (!dimensionLabels.has(key) || orderSet.has(key)) {
            return false;
          }
          orderSet.add(key);
          return true;
        });
        const remainingDimensions = Array.from(dimensionLabels.keys()).filter((key) => !orderSet.has(key));
        remainingDimensions.sort((a, b) => {
          const totalDiff = (dimensionTotals.get(b) ?? 0) - (dimensionTotals.get(a) ?? 0);
          if (Math.abs(totalDiff) > Number.EPSILON) {
            return totalDiff;
          }
          const displayA = dimensionLabels.get(a) ?? '';
          const displayB = dimensionLabels.get(b) ?? '';
          return displayA.localeCompare(displayB, undefined, { sensitivity: 'base' });
        });
        dimensionOrder.push(...remainingDimensions);
      } else {
        dimensionOrder = Array.from(dimensionLabels.keys());
        dimensionOrder.sort((a, b) => {
          const totalDiff = (dimensionTotals.get(b) ?? 0) - (dimensionTotals.get(a) ?? 0);
          if (Math.abs(totalDiff) > Number.EPSILON) {
            return totalDiff;
          }
          const displayA = dimensionLabels.get(a) ?? '';
          const displayB = dimensionLabels.get(b) ?? '';
          return displayA.localeCompare(displayB, undefined, { sensitivity: 'base' });
        });
      }

      const loList = dimensionOrder.map((dimensionKey) => dimensionLabels.get(dimensionKey) ?? dimensionKey);
      const rows = Array.from(dateMap.values())
        .sort((a, b) => a.date - b.date)
        .map(({ date, values }) => {
          const displayDate = displayDateFormatter.format(date);
          const formattedValues = dimensionOrder.map((dimensionKey) => formatTwoDecimal(values.get(dimensionKey) ?? 0));
          return { displayDate, formattedValues };
        });

      const totals = dimensionOrder.map((dimensionKey) => formatTwoDecimal(dimensionTotals.get(dimensionKey) ?? 0));

      return {
        loList,
        rows,
        totals,
        order: dimensionOrder,
        displayNames: new Map(dimensionLabels),
      };
    }

    function buildLoPivot(dataset, targetColumnName, options = {}) {
      const mergedOptions = {
        ...options,
      };
      if (!Object.prototype.hasOwnProperty.call(mergedOptions, 'fallbackLabel')) {
        mergedOptions.fallbackLabel = 'Unassigned';
      }
      return buildDailyPivot(dataset, 'listing owner', targetColumnName, mergedOptions);
    }

    function renderLoTable(tableElement, pivotData) {
      if (!tableElement) {
        return;
      }
      const { loList, rows, totals } = pivotData;
      if (!loList.length || !rows.length) {
        const columnCount = Math.max(1, loList.length + 1);
        tableElement.innerHTML = `<tbody><tr><td class="cell-date" colspan="${columnCount}">No data available</td></tr></tbody>`;
        return;
      }

      let headerHtml = '<thead><tr><th scope="col" class="cell-date">Date</th>';
      loList.forEach((owner) => {
        headerHtml += `<th scope="col">${escapeHtml(owner)}</th>`;
      });
      headerHtml += '</tr></thead>';

      let bodyHtml = '<tbody>';
      rows.forEach(({ displayDate, formattedValues }) => {
        bodyHtml += `<tr><td class="cell-date">${escapeHtml(displayDate)}</td>`;
        formattedValues.forEach((value) => {
          bodyHtml += `<td>${value}</td>`;
        });
        bodyHtml += '</tr>';
      });
      bodyHtml += '</tbody>';

      let footerHtml = '';
      if (Array.isArray(totals) && totals.length === loList.length) {
        footerHtml = '<tfoot><tr>';
        footerHtml += '<th scope="row" class="cell-date">Total</th>';
        totals.forEach((value) => {
          footerHtml += `<td>${value}</td>`;
        });
        footerHtml += '</tr></tfoot>';
      }

      tableElement.innerHTML = `${headerHtml}${bodyHtml}${footerHtml}`;
    }

    function buildSpendScaling(actualPivot, referencePivot) {
      if (!actualPivot || !referencePivot) {
        return null;
      }
      const ownerKeys = Array.isArray(actualPivot.loList)
        ? actualPivot.loList.map((label) => normalizeOwnerKey(label))
        : [];
      if (!ownerKeys.length) {
        return null;
      }
      const scaling = {
        ownerKeys,
        byDate: new Map(),
        totals: new Map(),
      };
      const referenceRowMap = new Map();
      if (Array.isArray(referencePivot.rows)) {
        referencePivot.rows.forEach((row) => {
          referenceRowMap.set(row.displayDate, row);
        });
      }
      if (Array.isArray(actualPivot.rows)) {
        actualPivot.rows.forEach((row) => {
          const referenceRow = referenceRowMap.get(row.displayDate);
          const valueMap = new Map();
          ownerKeys.forEach((ownerKey, index) => {
            const actualValue = parseNumericValue(row.formattedValues?.[index]) ?? 0;
            const referenceValue = referenceRow
              ? parseNumericValue(referenceRow.formattedValues?.[index]) ?? 0
              : 0;
            valueMap.set(ownerKey, { actualValue, referenceValue });
          });
          scaling.byDate.set(row.displayDate, valueMap);
        });
      }
      const referenceTotals = Array.isArray(referencePivot.totals) ? referencePivot.totals : [];
      const actualTotals = Array.isArray(actualPivot.totals) ? actualPivot.totals : [];
      ownerKeys.forEach((ownerKey, index) => {
        const actualValue = parseNumericValue(actualTotals[index]) ?? 0;
        const referenceValue = parseNumericValue(referenceTotals[index]) ?? 0;
        scaling.totals.set(ownerKey, { actualValue, referenceValue });
      });
      return scaling;
    }

    function applySpendScaling(basePivot, scaling, filtersActive) {
      if (!basePivot || !scaling) {
        return basePivot;
      }
      const ownerKeys = Array.isArray(scaling.ownerKeys) ? scaling.ownerKeys : [];
      const scaledRows = Array.isArray(basePivot.rows)
        ? basePivot.rows.map((row) => {
            const dateMap = scaling.byDate.get(row.displayDate);
            const formattedValues = Array.isArray(row.formattedValues)
              ? row.formattedValues.map((value, index) => {
                  const ownerKey = ownerKeys[index];
                  const reference = dateMap ? dateMap.get(ownerKey) : null;
                  const numericValue = parseNumericValue(value) ?? 0;
                  let scaledNumeric = numericValue;
                  if (reference) {
                    if (Math.abs(reference.referenceValue) > 1e-6) {
                      const factor = reference.actualValue / reference.referenceValue;
                      scaledNumeric = numericValue * factor;
                    } else if (!filtersActive) {
                      scaledNumeric = reference.actualValue;
                    }
                  }
                  return formatTwoDecimal(scaledNumeric);
                })
              : [];
            return { displayDate: row.displayDate, formattedValues };
          })
        : [];
      const scaledTotals = Array.isArray(basePivot.totals)
        ? basePivot.totals.map((value, index) => {
            const ownerKey = ownerKeys[index];
            const reference = scaling.totals.get(ownerKey);
            const numericValue = parseNumericValue(value) ?? 0;
            let scaledNumeric = numericValue;
            if (reference) {
              if (Math.abs(reference.referenceValue) > 1e-6) {
                const factor = reference.actualValue / reference.referenceValue;
                scaledNumeric = numericValue * factor;
              } else if (!filtersActive) {
                scaledNumeric = reference.actualValue;
              }
            }
            return formatTwoDecimal(scaledNumeric);
          })
        : [];
      return {
        loList: Array.isArray(basePivot.loList) ? basePivot.loList.slice() : [],
        rows: scaledRows,
        totals: scaledTotals,
      };
    }

    function updateLoTablesWithDataset(dataset) {
      const salesTableElement = document.getElementById('lo-sales-table');
      const spendTableElement = document.getElementById('lo-spend-table');
      if (!salesTableElement || !spendTableElement) {
        return;
      }
      const filtersActive = hasActiveColumnFilters();
      const baseOptions = {};
      if (Array.isArray(loSalesOrderCache) && loSalesOrderCache.length) {
        baseOptions.normalizedOrder = loSalesOrderCache;
      }
      if (loDisplayNameOverridesCache instanceof Map && loDisplayNameOverridesCache.size) {
        baseOptions.displayNameOverrides = loDisplayNameOverridesCache;
      }
      const salesPivot = buildLoPivot(dataset, 'total revenue', baseOptions);
      if (!Array.isArray(loSalesOrderCache) || loSalesOrderCache.length === 0) {
        loSalesOrderCache = Array.isArray(salesPivot.order) ? salesPivot.order.slice() : [];
      }
      if (salesPivot.displayNames instanceof Map) {
        loDisplayNameOverridesCache = new Map(salesPivot.displayNames);
      }
      renderLoTable(salesTableElement, salesPivot);

      let spendPivot;
      if (!filtersActive && loBaselineSpendPivot) {
        spendPivot = loBaselineSpendPivot;
      } else {
        const spendOptions = {};
        if (Array.isArray(loSalesOrderCache) && loSalesOrderCache.length) {
          spendOptions.normalizedOrder = loSalesOrderCache;
        }
        if (loDisplayNameOverridesCache instanceof Map && loDisplayNameOverridesCache.size) {
          spendOptions.displayNameOverrides = loDisplayNameOverridesCache;
        }
        const adSpendPivot = buildLoPivot(dataset, 'Ad Spend', spendOptions);
        if (!loBaselineAdSpendPivot) {
          loBaselineAdSpendPivot = adSpendPivot;
        }
        if (loSpendScalingData) {
          spendPivot = applySpendScaling(adSpendPivot, loSpendScalingData, filtersActive);
        } else {
          spendPivot = adSpendPivot;
        }
      }
      renderLoTable(spendTableElement, spendPivot);
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    function updatePlatformTablesWithDataset(dataset) {
      const platformSalesTableElement = document.getElementById('platform-sales-table');
      const platformNetTableElement = document.getElementById('platform-net-table');
      if (!platformSalesTableElement || !platformNetTableElement) {
        return;
      }

      const platformSalesPivot = buildDailyPivot(dataset, 'Platform', 'total revenue', {
        fallbackLabel: 'Unassigned Platform',
      });
      renderLoTable(platformSalesTableElement, platformSalesPivot);

      const platformNetPivot = buildDailyPivot(dataset, 'Platform', 'NET', {
        fallbackLabel: 'Unassigned Platform',
      });
      renderLoTable(platformNetTableElement, platformNetPivot);

      requestAnimationFrame(() => resizeLoTableContainers());
    }

    function normalizeOwnerKey(label) {
      if (typeof label !== 'string') {
        return '';
      }
      return label.trim().toLocaleLowerCase();
    }

    function alignPivotToReference(pivotData, referencePivot) {
      if (!pivotData || !Array.isArray(pivotData.loList) || !Array.isArray(pivotData.rows)) {
        return { loList: [], rows: [], totals: [] };
      }
      const referenceLabels = Array.isArray(referencePivot?.loList) ? referencePivot.loList : [];
      const referenceKeys = referenceLabels.map((label) => normalizeOwnerKey(label));
      const pivotKeys = pivotData.loList.map((label) => normalizeOwnerKey(label));

      const labelMap = new Map();
      pivotKeys.forEach((key, index) => {
        if (!labelMap.has(key)) {
          labelMap.set(key, pivotData.loList[index] ?? '');
        }
      });

      const columnIndexMap = new Map();
      pivotKeys.forEach((key, index) => {
        if (!columnIndexMap.has(key)) {
          columnIndexMap.set(key, index);
        }
      });

      const orderedKeys = [];
      referenceKeys.forEach((key) => {
        if (columnIndexMap.has(key) && !orderedKeys.includes(key)) {
          orderedKeys.push(key);
        }
      });
      pivotKeys.forEach((key) => {
        if (!orderedKeys.includes(key)) {
          orderedKeys.push(key);
        }
      });

      const loList = orderedKeys.map((key) => labelMap.get(key) ?? '');
      const totalsAccumulator = new Array(orderedKeys.length).fill(0);

      const rows = pivotData.rows.map((row) => {
        const displayDate = typeof row.displayDate === 'string' ? row.displayDate : '';
        const formattedValuesSource = Array.isArray(row.formattedValues) ? row.formattedValues : [];
        const formattedValues = orderedKeys.map((key, targetIndex) => {
          const columnIndex = columnIndexMap.get(key);
          if (typeof columnIndex !== 'number') {
            return '0.00';
          }
          const value = formattedValuesSource[columnIndex];
          const numericValue = parseNumericValue(value);
          if (numericValue !== null) {
            totalsAccumulator[targetIndex] += numericValue;
          }
          if (typeof value === 'string') {
            return value;
          }
          if (typeof value === 'number' && Number.isFinite(value)) {
            return value.toFixed(2);
          }
          return '0.00';
        });
        return { displayDate, formattedValues };
      });

      const totalsSource = Array.isArray(pivotData.totals) ? pivotData.totals : [];
      const totals = orderedKeys.map((key, targetIndex) => {
        const columnIndex = columnIndexMap.get(key);
        if (typeof columnIndex !== 'number') {
          const computedFallback = totalsAccumulator[targetIndex] ?? 0;
          return formatTwoDecimal(computedFallback);
        }
        const value = totalsSource[columnIndex];
        const numericValue = parseNumericValue(value);
        if (numericValue !== null) {
          return formatTwoDecimal(numericValue);
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (trimmed.length) {
            return trimmed;
          }
        }
        const computedFallback = totalsAccumulator[targetIndex] ?? 0;
        return formatTwoDecimal(computedFallback);
      });

      return { loList, rows, totals };
    }

    function formatSkuSummaryValue(value, column) {
      if (value === null || value === undefined || value === '') {
        return '';
      }
      const columnType = column && typeof column.type === 'string' ? column.type : 'decimal';
      const numeric = typeof value === 'number' ? value : Number(value);
      if (Number.isFinite(numeric)) {
        if (columnType === 'integer') {
          return integerFormatter.format(Math.round(numeric));
        }
        return numberFormatter.format(numeric);
      }
      return escapeHtml(String(value));
    }

    function buildSkuSummaryPivotFromDataset(dataset) {
      if (!dataset || !Array.isArray(dataset.columns) || !Array.isArray(dataset.rows)) {
        return { columns: [], rows: [], totals: null };
      }
      const skuIndex = findColumnIndex(dataset, 'SKU_2');
      const salePriceIndex = findColumnIndex(dataset, 'Sale Price + Shipping');
      const carrierFeeIndex = findColumnIndex(dataset, 'CARRIER FEE');
      const marketplaceFeeIndex = findColumnIndex(dataset, 'Ebay/ Amazon');
      const costIndex = findColumnIndex(dataset, 'P.COST');
      const netPerQtyIndex = findColumnIndex(dataset, 'NET/Q');
      const netIndex = findColumnIndex(dataset, 'NET');
      const finalNetIndex = findColumnIndex(dataset, 'Final Net');
      const revenueIndex = findColumnIndex(dataset, 'Total Revenue');
      const qtyIndex = findColumnIndex(dataset, 'Qty');
      const requiredIndices = [
        skuIndex,
        salePriceIndex,
        carrierFeeIndex,
        marketplaceFeeIndex,
        costIndex,
        netPerQtyIndex,
        netIndex,
        finalNetIndex,
        revenueIndex,
        qtyIndex,
      ];
      if (requiredIndices.some((index) => index === -1)) {
        return { columns: [], rows: [], totals: null };
      }

      const summary = new Map();
      const totalsAccumulator = {
        salePriceSum: 0,
        salePriceCount: 0,
        carrierFeeSum: 0,
        carrierFeeCount: 0,
        marketplaceFeeSum: 0,
        marketplaceFeeCount: 0,
        costSum: 0,
        costCount: 0,
        netPerQtySum: 0,
        netPerQtyCount: 0,
        netSum: 0,
        finalNetSum: 0,
        revenueSum: 0,
        qtySum: 0,
      };

      dataset.rows.forEach((row) => {
        const rawSku = row[skuIndex];
        const sku = rawSku === null || rawSku === undefined ? '' : String(rawSku).trim();
        if (!sku || sku === '-') {
          return;
        }
        if (!summary.has(sku)) {
          summary.set(sku, {
            sku,
            salePriceSum: 0,
            salePriceCount: 0,
            carrierFeeSum: 0,
            carrierFeeCount: 0,
            marketplaceFeeSum: 0,
            marketplaceFeeCount: 0,
            costSum: 0,
            costCount: 0,
            netPerQtySum: 0,
            netPerQtyCount: 0,
            netSum: 0,
            finalNetSum: 0,
            revenueSum: 0,
            qtySum: 0,
          });
        }
        const entry = summary.get(sku);

        const salePriceValue = parseNumericValue(row[salePriceIndex]);
        if (salePriceValue !== null) {
          entry.salePriceSum += salePriceValue;
          entry.salePriceCount += 1;
          totalsAccumulator.salePriceSum += salePriceValue;
          totalsAccumulator.salePriceCount += 1;
        }

        const carrierFeeValue = parseNumericValue(row[carrierFeeIndex]);
        if (carrierFeeValue !== null) {
          entry.carrierFeeSum += carrierFeeValue;
          entry.carrierFeeCount += 1;
          totalsAccumulator.carrierFeeSum += carrierFeeValue;
          totalsAccumulator.carrierFeeCount += 1;
        }

        const marketplaceFeeValue = parseNumericValue(row[marketplaceFeeIndex]);
        if (marketplaceFeeValue !== null) {
          entry.marketplaceFeeSum += marketplaceFeeValue;
          entry.marketplaceFeeCount += 1;
          totalsAccumulator.marketplaceFeeSum += marketplaceFeeValue;
          totalsAccumulator.marketplaceFeeCount += 1;
        }

        const costValue = parseNumericValue(row[costIndex]);
        if (costValue !== null) {
          entry.costSum += costValue;
          entry.costCount += 1;
          totalsAccumulator.costSum += costValue;
          totalsAccumulator.costCount += 1;
        }

        const netPerQtyValue = parseNumericValue(row[netPerQtyIndex]);
        if (netPerQtyValue !== null) {
          entry.netPerQtySum += netPerQtyValue;
          entry.netPerQtyCount += 1;
          totalsAccumulator.netPerQtySum += netPerQtyValue;
          totalsAccumulator.netPerQtyCount += 1;
        }

        const netValue = parseNumericValue(row[netIndex]);
        if (netValue !== null) {
          entry.netSum += netValue;
          totalsAccumulator.netSum += netValue;
        }

        const finalNetValue = parseNumericValue(row[finalNetIndex]);
        if (finalNetValue !== null) {
          entry.finalNetSum += finalNetValue;
          totalsAccumulator.finalNetSum += finalNetValue;
        }

        const revenueValue = parseNumericValue(row[revenueIndex]);
        if (revenueValue !== null) {
          entry.revenueSum += revenueValue;
          totalsAccumulator.revenueSum += revenueValue;
        }

        const qtyValue = parseNumericValue(row[qtyIndex]);
        if (qtyValue !== null) {
          entry.qtySum += qtyValue;
          totalsAccumulator.qtySum += qtyValue;
        }
      });

      const rows = Array.from(summary.values())
        .map((entry) => ({
          sku: entry.sku,
          average_of_sale_price_shipping: entry.salePriceCount ? entry.salePriceSum / entry.salePriceCount : null,
          average_of_carrier_fee: entry.carrierFeeCount ? entry.carrierFeeSum / entry.carrierFeeCount : null,
          average_of_ebay_amazon: entry.marketplaceFeeCount ? entry.marketplaceFeeSum / entry.marketplaceFeeCount : null,
          average_of_p_cost: entry.costCount ? entry.costSum / entry.costCount : null,
          average_of_net_q: entry.netPerQtyCount ? entry.netPerQtySum / entry.netPerQtyCount : null,
          sum_of_net: entry.netSum,
          sum_of_final_net: entry.finalNetSum,
          sum_of_total_revenue: entry.revenueSum,
          sum_of_qty: entry.qtySum,
        }))
        .sort((a, b) => a.sku.localeCompare(b.sku, undefined, { numeric: true, sensitivity: 'base' }));

      const totals = {
        sku: 'Grand Total',
        average_of_sale_price_shipping: totalsAccumulator.salePriceCount
          ? totalsAccumulator.salePriceSum / totalsAccumulator.salePriceCount
          : null,
        average_of_carrier_fee: totalsAccumulator.carrierFeeCount
          ? totalsAccumulator.carrierFeeSum / totalsAccumulator.carrierFeeCount
          : null,
        average_of_ebay_amazon: totalsAccumulator.marketplaceFeeCount
          ? totalsAccumulator.marketplaceFeeSum / totalsAccumulator.marketplaceFeeCount
          : null,
        average_of_p_cost: totalsAccumulator.costCount
          ? totalsAccumulator.costSum / totalsAccumulator.costCount
          : null,
        average_of_net_q: totalsAccumulator.netPerQtyCount
          ? totalsAccumulator.netPerQtySum / totalsAccumulator.netPerQtyCount
          : null,
        sum_of_net: totalsAccumulator.netSum,
        sum_of_final_net: totalsAccumulator.finalNetSum,
        sum_of_total_revenue: totalsAccumulator.revenueSum,
        sum_of_qty: totalsAccumulator.qtySum,
      };

      const columns = [
        { key: 'sku', label: 'SKU', type: 'string' },
        { key: 'average_of_sale_price_shipping', label: 'Average of Sale Price + Shipping', type: 'decimal' },
        { key: 'average_of_carrier_fee', label: 'Average of CARRIER FEE', type: 'decimal' },
        { key: 'average_of_ebay_amazon', label: 'Average of Ebay/ Amazon', type: 'decimal' },
        { key: 'average_of_p_cost', label: 'Average of P.COST', type: 'decimal' },
        { key: 'average_of_net_q', label: 'Average of NET/Q', type: 'decimal' },
        { key: 'sum_of_net', label: 'Sum of NET', type: 'decimal' },
        { key: 'sum_of_total_revenue', label: 'Sum of Total Revenue', type: 'decimal' },
        { key: 'sum_of_qty', label: 'Sum of Qty', type: 'integer' },
        { key: 'sum_of_final_net', label: 'Final Net (Sum)', type: 'decimal' },
      ];

      return { columns, rows, totals };
    }

    function updateSkuSummaryWithDataset(dataset) {
      const pivot = buildSkuSummaryPivotFromDataset(dataset);
      skuSummaryPivotCache = pivot;
      skuSummaryCurrentPage = 1;
      skuSummaryTotalRows = Array.isArray(pivot.rows) ? pivot.rows.length : 0;
      renderSkuSummaryTable(pivot, { page: 1 });
    }

    function renderSkuSummaryMessage(message, columnCount = 2) {
      const tableElement = document.getElementById('sku-summary-table');
      if (!tableElement) {
        return;
      }
      const span = Math.max(1, columnCount);
      const content = escapeHtml(message);
      tableElement.innerHTML = `<tbody><tr><td class="sku-table__message" colspan="${span}">${content}</td></tr></tbody>`;
      skuSummaryTotalRows = 0;
      skuSummaryCurrentPage = 1;
      renderSkuSummaryPagination(0, skuSummaryPageSize, 1);
    }

    function renderSkuSummaryPagination(totalRows, pageSize, currentPage) {
      const paginationElement = document.getElementById('sku-summary-pagination');
      if (!paginationElement) {
        return;
      }

      const toolbarElement = paginationElement.parentElement;
      const safePageSize = Number.isFinite(pageSize) && pageSize > 0 ? Math.floor(pageSize) : 25;

      if (!Number.isFinite(totalRows) || totalRows <= safePageSize) {
        paginationElement.textContent = '';
        paginationElement.setAttribute('aria-hidden', 'true');
        if (toolbarElement && toolbarElement.classList && toolbarElement.classList.contains('sku-card__toolbar')) {
          toolbarElement.setAttribute('data-active', 'false');
        }
        return;
      }

      const totalPages = Math.max(1, Math.ceil(totalRows / safePageSize));
      const safeCurrentPage = Math.min(Math.max(1, currentPage || 1), totalPages);
      const start = (safeCurrentPage - 1) * safePageSize + 1;
      const end = Math.min(totalRows, start + safePageSize - 1);

      const previousDisabled = safeCurrentPage <= 1 ? ' disabled' : '';
      const nextDisabled = safeCurrentPage >= totalPages ? ' disabled' : '';

      paginationElement.setAttribute('aria-hidden', 'false');
      if (toolbarElement && toolbarElement.classList && toolbarElement.classList.contains('sku-card__toolbar')) {
        toolbarElement.setAttribute('data-active', 'true');
      }
      paginationElement.innerHTML = `
        <button type="button" class="sku-card__pagination-button" data-action="previous"${previousDisabled}>Previous</button>
        <span class="sku-card__pagination-info">Showing ${start}&ndash;${end} of ${totalRows}</span>
        <button type="button" class="sku-card__pagination-button" data-action="next"${nextDisabled}>Next</button>
      `;
    }

    function renderSkuSummaryTable(pivotData, options = {}) {
      const tableElement = document.getElementById('sku-summary-table');
      if (!tableElement) {
        return;
      }
      const columns = Array.isArray(pivotData?.columns) ? pivotData.columns : [];
      const rows = Array.isArray(pivotData?.rows) ? pivotData.rows : [];
      if (!columns.length) {
        renderSkuSummaryMessage('No data available');
        return;
      }
      const pageSizeOption = Number.isFinite(options.pageSize) && options.pageSize > 0 ? Math.floor(options.pageSize) : skuSummaryPageSize;
      const safePageSize = pageSizeOption > 0 ? pageSizeOption : 25;
      const totalRows = rows.length;
      const totalPages = totalRows > 0 ? Math.ceil(totalRows / safePageSize) : 1;
      const requestedPage = Number.isFinite(options.page) ? Math.floor(options.page) : skuSummaryCurrentPage;
      const safePage = Math.min(Math.max(1, requestedPage), Math.max(1, totalPages));
      skuSummaryPageSize = safePageSize;
      skuSummaryCurrentPage = safePage;
      skuSummaryTotalRows = totalRows;
      const startIndex = (safePage - 1) * safePageSize;
      const paginatedRows = totalRows > 0 ? rows.slice(startIndex, startIndex + safePageSize) : [];

      const columnCount = columns.length;
      let headerHtml = '<thead><tr>';
      columns.forEach((column) => {
        const label = typeof column.label === 'string' ? column.label : '';
        headerHtml += `<th scope="col">${escapeHtml(label)}</th>`;
      });
      headerHtml += '</tr></thead>';

      let bodyHtml = '<tbody>';
      if (!paginatedRows.length) {
        bodyHtml += `<tr><td class="sku-table__message" colspan="${columnCount}">No data available</td></tr>`;
      } else {
        paginatedRows.forEach((row) => {
          bodyHtml += '<tr>';
          columns.forEach((column, index) => {
            const key = column.key;
            const value = row ? row[key] : null;
            if (index === 0) {
              const text = value === null || value === undefined ? '' : String(value);
              bodyHtml += `<td>${escapeHtml(text)}</td>`;
            } else {
              bodyHtml += `<td>${formatSkuSummaryValue(value, column)}</td>`;
            }
          });
          bodyHtml += '</tr>';
        });
      }
      bodyHtml += '</tbody>';

      let footerHtml = '';
      const totals = pivotData && typeof pivotData.totals === 'object' && pivotData.totals !== null
        ? pivotData.totals
        : null;
      if (totals) {
        footerHtml = '<tfoot><tr>';
        columns.forEach((column, index) => {
          const key = column.key;
          const value = totals[key];
          if (index === 0) {
            const text = value === null || value === undefined ? 'Grand Total' : String(value);
            footerHtml += `<th scope="row">${escapeHtml(text)}</th>`;
          } else {
            footerHtml += `<td>${formatSkuSummaryValue(value, column)}</td>`;
          }
        });
        footerHtml += '</tr></tfoot>';
      }

      tableElement.innerHTML = `${headerHtml}${bodyHtml}${footerHtml}`;
      renderSkuSummaryPagination(totalRows, safePageSize, safePage);
    }

    function loadSkuSummaryTable() {
      if (skuSummaryInitialised) {
        return Promise.resolve();
      }

      setTabPanelLoading('sku-summary', true, 'Preparing SKU summary…');
      renderSkuSummaryMessage('Loading data…');

      const datasetPromise = fetchRegularDataset()
        .then((dataset) => {
          if (!regularFilterInitialised) {
            const augmentedForFilters = augmentDatasetWithTotals(dataset);
            columnValueOptions = buildColumnOptions(augmentedForFilters);
            initializeRegularFilterControls(augmentedForFilters);
          }
          return dataset;
        })
        .catch((datasetError) => {
          console.error('Failed to load dataset for SKU summary:', datasetError);
          return null;
        });

      if (hasActiveColumnFilters()) {
        return datasetPromise
          .then((dataset) => {
            if (!dataset) {
              throw new Error('Dataset is unavailable');
            }
            const effectiveDataset = buildFilteredDataset(dataset, columnFilters);
            const pivotData = buildSkuSummaryPivotFromDataset(effectiveDataset);
            skuSummaryPivotCache = pivotData;
            skuSummaryCurrentPage = 1;
            skuSummaryTotalRows = Array.isArray(pivotData?.rows) ? pivotData.rows.length : 0;
            renderSkuSummaryTable(pivotData, { page: 1 });
            skuSummaryInitialised = true;
          })
          .catch((error) => {
            const message = error && error.message ? error.message : 'Unable to load SKU summary';
            renderSkuSummaryMessage(message);
          })
          .finally(() => {
            setTabPanelLoading('sku-summary', false);
          });
      }

      return fetchSkuSummaryPivot()
        .then((pivotData) => {
          if (!pivotData || !Array.isArray(pivotData.columns) || !pivotData.columns.length) {
            throw new Error('SKU summary pivot is unavailable');
          }
          skuSummaryPivotCache = pivotData;
          skuSummaryCurrentPage = 1;
          skuSummaryTotalRows = Array.isArray(pivotData?.rows) ? pivotData.rows.length : 0;
          renderSkuSummaryTable(pivotData, { page: 1 });
          skuSummaryInitialised = true;
        })
        .catch(() => {
          return datasetPromise
            .then((dataset) => {
              if (!dataset) {
                throw new Error('Dataset is unavailable');
              }
              const effectiveDataset = buildFilteredDataset(dataset, columnFilters);
              const pivotData = buildSkuSummaryPivotFromDataset(effectiveDataset);
              skuSummaryPivotCache = pivotData;
              skuSummaryCurrentPage = 1;
              skuSummaryTotalRows = Array.isArray(pivotData?.rows) ? pivotData.rows.length : 0;
              renderSkuSummaryTable(pivotData, { page: 1 });
              skuSummaryInitialised = true;
            })
            .catch((error) => {
              const message = error && error.message ? error.message : 'Unable to load SKU summary';
              renderSkuSummaryMessage(message);
            });
        })
        .finally(() => {
          setTabPanelLoading('sku-summary', false);
        });
    }

    function updateSkuSummaryPage(direction) {
      if (!skuSummaryPivotCache) {
        return;
      }
      const totalPages = Math.max(1, Math.ceil((skuSummaryTotalRows || 0) / (skuSummaryPageSize || 1)));
      if (direction === 'previous') {
        if (skuSummaryCurrentPage <= 1) {
          return;
        }
        const targetPage = skuSummaryCurrentPage - 1;
        renderSkuSummaryTable(skuSummaryPivotCache, { page: targetPage });
      } else if (direction === 'next') {
        if (skuSummaryCurrentPage >= totalPages) {
          return;
        }
        const targetPage = skuSummaryCurrentPage + 1;
        renderSkuSummaryTable(skuSummaryPivotCache, { page: targetPage });
      }
    }

    function setDashboardTableMessage(tableId, message, columnCount = 2) {
      const tableElement = document.getElementById(tableId);
      if (!tableElement) {
        return;
      }
      const span = Math.max(1, columnCount);
      tableElement.innerHTML = '';
      const tbody = tableElement.createTBody();
      const row = document.createElement('tr');
      const cell = document.createElement('td');
      cell.colSpan = span;
      cell.className = 'dashboard-table__message';
      cell.textContent = message;
      row.appendChild(cell);
      tbody.appendChild(row);
    }

    function renderDashboardPivotTable(config, pivot) {
      const tableElement = document.getElementById(config.tableId);
      if (!tableElement) {
        return;
      }
      const columns = Array.isArray(pivot?.columns) ? pivot.columns : [];
      if (!columns.length) {
        setDashboardTableMessage(config.tableId, 'No data available', (config.columns?.length || 0) + 1);
        return;
      }
      const rows = Array.isArray(pivot?.rows) ? pivot.rows : [];
      const totalRow = Array.isArray(pivot?.totalRow) ? pivot.totalRow : null;

      tableElement.innerHTML = '';
      const thead = tableElement.createTHead();
      const headRow = document.createElement('tr');
      columns.forEach((label) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = typeof label === 'string' ? label : '';
        headRow.appendChild(th);
      });
      thead.appendChild(headRow);

      const tbody = tableElement.createTBody();
      if (!rows.length) {
        const emptyRow = document.createElement('tr');
        const emptyCell = document.createElement('td');
        emptyCell.colSpan = columns.length;
        emptyCell.className = 'dashboard-table__message';
        emptyCell.textContent = 'No data available';
        emptyRow.appendChild(emptyCell);
        tbody.appendChild(emptyRow);
      } else {
        rows.forEach((row) => {
          const tr = document.createElement('tr');
          row.forEach((value, index) => {
            const cellTag = index === 0 ? 'th' : 'td';
            const cell = document.createElement(cellTag);
            if (index === 0) {
              cell.scope = 'row';
            } else if (typeof value === 'string' && value.trim().startsWith('#')) {
              cell.classList.add('dashboard-table__value--error');
            }
            cell.textContent = value === null || value === undefined ? '' : String(value);
            tr.appendChild(cell);
          });
          tbody.appendChild(tr);
        });
      }

      if (totalRow && totalRow.length === columns.length) {
        const tfoot = tableElement.createTFoot();
        const tr = document.createElement('tr');
        tr.className = 'dashboard-table__total';
        totalRow.forEach((value, index) => {
          const cellTag = index === 0 ? 'th' : 'td';
          const cell = document.createElement(cellTag);
          if (index === 0) {
            cell.scope = 'row';
          } else if (typeof value === 'string' && value.trim().startsWith('#')) {
            cell.classList.add('dashboard-table__value--error');
          }
          cell.textContent = value === null || value === undefined ? '' : String(value);
          tr.appendChild(cell);
        });
        tfoot.appendChild(tr);
      }
    }

    function buildDashboardPivot(dataset, config) {
      if (!dataset || !Array.isArray(dataset.columns) || !Array.isArray(dataset.rows)) {
        return { columns: [], rows: [], totalRow: [] };
      }
      const normalise = (value) => (typeof value === 'string' ? value.trim().toLowerCase() : '');
      const columnLookup = new Map();
      dataset.columns.forEach((column, index) => {
        const key = normalise(column);
        if (key && !columnLookup.has(key)) {
          columnLookup.set(key, index);
        }
      });
      const groupIndex = columnLookup.get(normalise(config.groupColumn));
      if (groupIndex === undefined) {
        throw new Error(`Column "${config.groupColumn}" not found in Main dataset`);
      }
      const missingColumns = [];
      const includedColumns = [];
      const columnDescriptors = [];
      config.columns.forEach((column) => {
        if (!column) {
          return;
        }
        if (column.computed && column.computed.type === 'ratio') {
          const numeratorName = column.computed.numerator;
          const denominatorName = column.computed.denominator;
          const numeratorIndex = columnLookup.get(normalise(numeratorName));
          if (numeratorIndex === undefined) {
            missingColumns.push(
              `Column "${numeratorName}" not found in Main dataset (required for computed column "${column.source || column.header}")`
            );
            return;
          }
          const denominatorIndex = columnLookup.get(normalise(denominatorName));
          if (denominatorIndex === undefined) {
            missingColumns.push(
              `Column "${denominatorName}" not found in Main dataset (required for computed column "${column.source || column.header}")`
            );
            return;
          }
          includedColumns.push(column);
          columnDescriptors.push({
            type: 'ratio',
            numeratorIndex,
            denominatorIndex,
            numeratorSource: numeratorName,
            denominatorSource: denominatorName,
          });
          return;
        }
        const index = columnLookup.get(normalise(column.source));
        if (index === undefined) {
          missingColumns.push(`Column "${column.source}" not found in Main dataset`);
          return;
        }
        includedColumns.push(column);
        columnDescriptors.push({ type: 'direct', datasetIndex: index });
      });
      if (missingColumns.length) {
        const label = config.displayLabel || config.id || 'pivot';
        console.warn(
          `Skipped ${missingColumns.length} column(s) while building ${label} pivot:\n${missingColumns.join('\n')}`
        );
      }
      if (!includedColumns.length) {
        return { columns: ['Row Labels'], rows: [], totalRow: [] };
      }
      const groups = [];
      const groupLookup = new Map();
      const normalizedTotal = TOTAL_ROW_LABEL.toLowerCase();

      dataset.rows.forEach((row) => {
        const rawLabel = row[groupIndex];
        if (isPlaceholderValue(rawLabel)) {
          return;
        }
        const label = String(rawLabel).trim();
        if (!label || label.toLowerCase() === normalizedTotal) {
          return;
        }
        const key = label.toLowerCase();
        let entry = groupLookup.get(key);
        if (!entry) {
          entry = {
            label,
            metrics: columnDescriptors.map((descriptor) => {
              if (descriptor && descriptor.type === 'ratio') {
                return {
                  numerator: 0,
                  denominator: 0,
                  numeratorHasValue: false,
                  denominatorHasValue: false,
                };
              }
              return { sum: 0, hasValue: false, hasError: false, errorValue: '', textValue: '' };
            }),
          };
          groupLookup.set(key, entry);
          groups.push(entry);
        }
        includedColumns.forEach((column, columnIndex) => {
          const descriptor = columnDescriptors[columnIndex];
          if (!descriptor) {
            return;
          }
          const metric = entry.metrics[columnIndex];
          if (!metric) {
            return;
          }
          if (descriptor.type === 'ratio') {
            const numeratorRaw = descriptor.numeratorIndex < row.length ? row[descriptor.numeratorIndex] : null;
            const denominatorRaw = descriptor.denominatorIndex < row.length ? row[descriptor.denominatorIndex] : null;
            const numeratorValue = parseNumericValue(numeratorRaw);
            if (numeratorValue !== null) {
              metric.numerator += numeratorValue;
              metric.numeratorHasValue = true;
            }
            const denominatorValue = parseNumericValue(denominatorRaw);
            if (denominatorValue !== null) {
              metric.denominator += denominatorValue;
              metric.denominatorHasValue = true;
            }
            return;
          }
          const datasetColumnIndex = descriptor.datasetIndex;
          if (datasetColumnIndex === undefined || datasetColumnIndex >= row.length) {
            return;
          }
          const rawValue = row[datasetColumnIndex];
          if (isPlaceholderValue(rawValue)) {
            return;
          }
          const numericValue = parseNumericValue(rawValue);
          if (numericValue !== null) {
            metric.sum += numericValue;
            metric.hasValue = true;
          } else if (typeof rawValue === 'string') {
            const trimmed = rawValue.trim();
            if (!trimmed) {
              return;
            }
            if (trimmed.startsWith('#')) {
              metric.hasError = true;
              metric.errorValue = trimmed;
            } else if (!metric.textValue) {
              metric.textValue = trimmed;
            }
          }
        });
      });

      const columns = ['Row Labels', ...includedColumns.map((column) => column.header)];
      const rows = groups.map((entry) => {
        const values = [entry.label];
        entry.metrics.forEach((metric, columnIndex) => {
          const descriptor = columnDescriptors[columnIndex];
          const column = includedColumns[columnIndex];
          if (descriptor && descriptor.type === 'ratio') {
            values.push(formatDashboardRatioValue(metric, column));
            return;
          }
          if (metric.hasValue) {
            values.push(formatCellValue(metric.sum, column.source));
          } else if (metric.hasError) {
            values.push(metric.errorValue || '#DIV/0!');
          } else if (metric.textValue) {
            values.push(metric.textValue);
          } else {
            values.push('');
          }
        });
        return values;
      });

      let totalRow = null;
      if (rows.length) {
        totalRow = ['Grand Total'];
        includedColumns.forEach((column, columnIndex) => {
          const descriptor = columnDescriptors[columnIndex];
          if (descriptor && descriptor.type === 'ratio') {
            let numeratorSum = 0;
            let denominatorSum = 0;
            let numeratorHasValue = false;
            let denominatorHasValue = false;
            groups.forEach((entry) => {
              const metric = entry.metrics[columnIndex];
              if (!metric) {
                return;
              }
              if (metric.numeratorHasValue) {
                numeratorHasValue = true;
                numeratorSum += metric.numerator;
              }
              if (metric.denominatorHasValue) {
                denominatorHasValue = true;
                denominatorSum += metric.denominator;
              }
            });
            const aggregateMetric = {
              numerator: numeratorSum,
              denominator: denominatorSum,
              numeratorHasValue,
              denominatorHasValue,
            };
            totalRow.push(formatDashboardRatioValue(aggregateMetric, column));
            return;
          }
          let aggregate = 0;
          let hasValue = false;
          let errorValue = '';
          let textValue = '';
          groups.forEach((entry) => {
            const metric = entry.metrics[columnIndex];
            if (!metric) {
              return;
            }
            if (metric.hasValue) {
              aggregate += metric.sum;
              hasValue = true;
              return;
            }
            if (!errorValue && metric.hasError) {
              errorValue = metric.errorValue || '#DIV/0!';
            }
            if (!textValue && metric.textValue) {
              textValue = metric.textValue;
            }
          });
          if (hasValue) {
            totalRow.push(formatCellValue(aggregate, column.source));
          } else if (errorValue) {
            totalRow.push(errorValue);
          } else if (textValue) {
            totalRow.push(textValue);
          } else {
            totalRow.push('');
          }
        });
      }

      return { columns, rows, totalRow };
    }

    function buildDashboardPivotResultsFromDataset(dataset) {
      const results = new Map();
      DASHBOARD_PIVOT_CONFIGS.forEach((config) => {
        try {
          results.set(config.id, buildDashboardPivot(dataset, config));
        } catch (error) {
          const message = error && error.message ? error.message : 'Unable to build dashboard view';
          results.set(config.id, { error: message });
        }
      });
      return results;
    }

    function renderMainDashboard(pivotMap) {
      DASHBOARD_PIVOT_CONFIGS.forEach((config) => {
        const pivot = pivotMap instanceof Map ? pivotMap.get(config.id) : null;
        if (pivot && !pivot.error) {
          renderDashboardPivotTable(config, pivot);
        } else {
          const message = pivot && pivot.error ? pivot.error : 'No data available';
          setDashboardTableMessage(config.tableId, message, (config.columns?.length || 0) + 1);
        }
      });
    }

    function loadMainDashboard() {
      const filtersInitiallyActive = hasActiveColumnFilters(mainColumnFilters);
      if (mainDashboardInitialised && mainDashboardPivotCache instanceof Map) {
        renderMainDashboard(mainDashboardPivotCache);
        setTabPanelLoading('dashboard', false);
        return;
      }
      const loadingMessage = filtersInitiallyActive ? 'Updating dashboard…' : 'Loading dashboard…';
      setTabPanelLoading('dashboard', true, loadingMessage);
      DASHBOARD_PIVOT_CONFIGS.forEach((config) => {
        setDashboardTableMessage(config.tableId, 'Loading data…', (config.columns?.length || 0) + 1);
      });

      const loadFromDataset = () => {
        const datasetPromise = mainDatasetCache ? Promise.resolve(mainDatasetCache) : fetchMainDataset();
        return datasetPromise.then((dataset) => {
          if (!dataset) {
            throw new Error('Dataset is unavailable');
          }
          ensureMainFilterSetup(dataset);
          const filtersActive = hasActiveColumnFilters(mainColumnFilters);
          const effectiveDataset = filtersActive ? buildFilteredDataset(dataset, mainColumnFilters) : dataset;
          const results = buildDashboardPivotResultsFromDataset(effectiveDataset);
          return { results, filtersActiveAtBuild: filtersActive };
        });
      };

      const sourcePromise = filtersInitiallyActive
        ? loadFromDataset()
        : fetchDashboardPivotSections().then((results) => ({ results, filtersActiveAtBuild: false }));

      return sourcePromise
        .then(({ results, filtersActiveAtBuild }) => {
          if (!(results instanceof Map)) {
            throw new Error('Dashboard data is unavailable');
          }
          if (hasActiveColumnFilters(mainColumnFilters) !== filtersActiveAtBuild) {
            return;
          }
          mainDashboardPivotCache = results;
          mainDashboardInitialised = true;
          renderMainDashboard(results);
        })
        .catch((dashboardError) => {
          console.error('Failed to build dashboard pivots from Main worksheet:', dashboardError);
          return loadFromDataset()
            .then(({ results, filtersActiveAtBuild }) => {
              if (!(results instanceof Map)) {
                throw new Error('Dashboard data is unavailable');
              }
              if (hasActiveColumnFilters(mainColumnFilters) !== filtersActiveAtBuild) {
                return;
              }
              mainDashboardPivotCache = results;
              mainDashboardInitialised = true;
              renderMainDashboard(results);
            })
            .catch((error) => {
              const message = error && error.message ? error.message : 'Unable to load data';
              DASHBOARD_PIVOT_CONFIGS.forEach((config) => {
                setDashboardTableMessage(config.tableId, message, (config.columns?.length || 0) + 1);
              });
              const mainFilterButton = document.getElementById('main-filter-button');
              if (mainFilterButton) {
                mainFilterButton.setAttribute('disabled', 'true');
                mainFilterButton.setAttribute('aria-hidden', 'true');
                mainFilterButton.setAttribute('aria-expanded', 'false');
                mainFilterButton.dataset.active = 'false';
              }
              if (dashboardFilterButtonElement) {
                dashboardFilterButtonElement.setAttribute('disabled', 'true');
                dashboardFilterButtonElement.setAttribute('aria-hidden', 'true');
                dashboardFilterButtonElement.setAttribute('aria-expanded', 'false');
                dashboardFilterButtonElement.dataset.active = 'false';
              }
            });
        })
        .finally(() => {
          setTabPanelLoading('dashboard', false);
        });
    }

    const skuSummaryPaginationElement = document.getElementById('sku-summary-pagination');
    if (skuSummaryPaginationElement) {
      skuSummaryPaginationElement.addEventListener('click', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) {
          return;
        }
        if (target.matches('button[data-action]')) {
          const action = target.getAttribute('data-action');
          if (action === 'previous' || action === 'next') {
            updateSkuSummaryPage(action);
          }
        }
      });
    }

    function renderLoMessage(message) {
      const escaped = escapeHtml(message);
      const markup = `<tbody><tr><td class="cell-date" colspan="1">${escaped}</td></tr></tbody>`;
      const salesTable = document.getElementById('lo-sales-table');
      const spendTable = document.getElementById('lo-spend-table');
      const platformSalesTable = document.getElementById('platform-sales-table');
      const platformNetTable = document.getElementById('platform-net-table');
      if (salesTable) {
        salesTable.innerHTML = markup;
      }
      if (spendTable) {
        spendTable.innerHTML = markup;
      }
      if (platformSalesTable) {
        platformSalesTable.innerHTML = markup;
      }
      if (platformNetTable) {
        platformNetTable.innerHTML = markup;
      }
      requestAnimationFrame(() => resizeLoTableContainers());
    }

    function initializePlatformTables(dataset) {
      if (!dataset || !Array.isArray(dataset.rows)) {
        updatePlatformTablesWithDataset({ columns: [], rows: [] });
        platformTablesInitialised = true;
        return;
      }
      const effectiveDataset = buildFilteredDataset(dataset, columnFilters);
      updatePlatformTablesWithDataset(effectiveDataset);
      platformTablesInitialised = true;
    }

    function initializeLoTables(dataset) {
      if (!regularFilterInitialised) {
        const augmentedForFilters = augmentDatasetWithTotals(dataset);
        columnValueOptions = buildColumnOptions(augmentedForFilters);
        initializeRegularFilterControls(augmentedForFilters);
      }
      if (loTablesInitialised) {
        const effectiveDataset = buildFilteredDataset(dataset, columnFilters);
        updateLoTablesWithDataset(effectiveDataset);
        if (platformTablesInitialised) {
          updatePlatformTablesWithDataset(effectiveDataset);
        }
        return;
      }
      const salesTable = document.getElementById('lo-sales-table');
      const spendTable = document.getElementById('lo-spend-table');
      const salesPivot = buildLoPivot(dataset, 'total revenue');
      loSalesOrderCache = Array.isArray(salesPivot.order) ? salesPivot.order.slice() : [];
      loDisplayNameOverridesCache = salesPivot.displayNames instanceof Map
        ? new Map(salesPivot.displayNames)
        : new Map();
      renderLoTable(salesTable, salesPivot);
      requestAnimationFrame(() => resizeLoTableContainers());
      if (spendTable) {
        const loadingColumns = Math.max(1, (salesPivot?.loList?.length ?? 0) + 1);
        spendTable.innerHTML = `<tbody><tr><td class="cell-date" colspan="${loadingColumns}">Loading…</td></tr></tbody>`;
      }
      const adSpendPivot = buildLoPivot(dataset, 'Ad Spend', {
        normalizedOrder: loSalesOrderCache,
        displayNameOverrides: loDisplayNameOverridesCache,
      });
      loBaselineAdSpendPivot = adSpendPivot;
      fetchSpendPivot()
        .then((pivotData) => {
          const alignedPivot = alignPivotToReference(pivotData, salesPivot);
          loBaselineSpendPivot = alignedPivot;
          loSpendScalingData = buildSpendScaling(alignedPivot, adSpendPivot);
          renderLoTable(spendTable, alignedPivot);
          requestAnimationFrame(() => resizeLoTableContainers());
        })
        .catch((error) => {
          if (!spendTable) {
            return;
          }
          loSpendScalingData = null;
          if (adSpendPivot && Array.isArray(adSpendPivot.rows) && adSpendPivot.rows.length) {
            loBaselineSpendPivot = adSpendPivot;
            renderLoTable(spendTable, adSpendPivot);
          } else {
            const baseColumnCount = Array.isArray(salesPivot?.loList) ? salesPivot.loList.length + 1 : 1;
            const message = escapeHtml(error.message || 'Unable to load spend pivot');
            spendTable.innerHTML = `<tbody><tr><td class="cell-date" colspan="${baseColumnCount}">${message}</td></tr></tbody>`;
          }
          requestAnimationFrame(() => resizeLoTableContainers());
        });
      loTablesInitialised = true;
      initializePlatformTables(dataset);
    }

    function loadRegularTable() {
      if (regularTableInitialised) {
        return Promise.resolve();
      }
      setTabPanelLoading('regular', true, 'Loading regular data…');
      return fetchRegularDataset()
        .then((dataset) => {
          updateStickyOffset();

          const augmentedDataset = augmentDatasetWithTotals(dataset);
          regularTableAugmentedDataset = augmentedDataset;
          totalColumnIndex = augmentedDataset.totalColumnIndex;
          const columns = augmentedDataset.columns.map((title) => ({ title }));
          const formattedRows = augmentedDataset.rows.map((row) => row.map((value, index) => formatCellValue(value, augmentedDataset.columns[index])));
          const productColumnIndex = augmentedDataset.columns.indexOf('Product');
          const quantityColumnIndex = augmentedDataset.columns.findIndex((column) => column && column.trim().toLowerCase() === 'qty');
          const numericColumnIndices = augmentedDataset.numericColumnIndices;

          regularTableFooterValues = SHOW_REGULAR_TOTAL_ROW
            ? buildFormattedFooterValues(augmentedDataset)
            : [];
          regularTableNumericColumnSet = SHOW_REGULAR_TOTAL_ROW
            ? new Set(numericColumnIndices)
            : new Set();

          if (SHOW_REGULAR_TOTAL_ROW) {
            const tableElement = document.getElementById('regular-table');
            if (tableElement) {
              ensureTableFooter(
                tableElement,
                augmentedDataset.columns.length,
                regularTableFooterValues,
                regularTableNumericColumnSet
              );
            }
          }

          const columnClassMap = new Map();
          const addColumnClass = (columnIndex, className) => {
            if (columnIndex < 0) {
              return;
            }
            if (!columnClassMap.has(columnIndex)) {
              columnClassMap.set(columnIndex, new Set());
            }
            columnClassMap.get(columnIndex).add(className);
          };

          addColumnClass(productColumnIndex, 'cell-product');
          addColumnClass(quantityColumnIndex, 'cell-qty');
          numericColumnIndices.forEach((columnIndex) => addColumnClass(columnIndex, 'cell-numeric'));

          const columnDefs = Array.from(columnClassMap.entries()).map(([columnIndex, classSet]) => ({
            targets: Number(columnIndex),
            className: Array.from(classSet).join(' '),
          }));

          const initialRowCount = Math.min(augmentedDataset.rows.length, REGULAR_TABLE_PAGE_LENGTH);
          const initialReservedSpace = calculateRegularTableReservedSpace();
          const initialScrollHeight = `${calculateScrollBodyHeight(initialRowCount, undefined, initialReservedSpace)}px`;
          regularTable = $('#regular-table').DataTable({
            data: formattedRows,
            columns,
            columnDefs,
            scrollX: true,
            scrollY: initialScrollHeight,
            scrollCollapse: true,
            deferRender: true,
            autoWidth: true,
            aaSorting: [],
            order: [],
            ordering: false,
            paging: true,
            pageLength: REGULAR_TABLE_PAGE_LENGTH,
            lengthChange: false,
            info: false,
            dom: 't<"regular-table__footer"p>'
          });

          moveRegularTablePagination();
          columnValueOptions = buildColumnOptions(augmentedDataset);
          initializeRegularFilterControls(augmentedDataset);
          wireHeaderEvents(regularTable, { allowSorting: false });
          applyTableHeight(regularTable);
          if (SHOW_REGULAR_TOTAL_ROW) {
            updateRegularTableFooter(regularTable);
          }
          regularTable.on('draw.dt', () => {
            wireHeaderEvents(regularTable, { allowSorting: false });
            applyTableHeight(regularTable);
            if (SHOW_REGULAR_TOTAL_ROW) {
              updateRegularTableFooter(regularTable);
            }
            moveRegularTablePagination();
          });

          regularTableInitialised = true;
          requestAnimationFrame(() => refreshRegularTableLayout());
        })
        .catch((error) => {
          const tableElement = document.getElementById('regular-table');
          if (tableElement) {
            tableElement.outerHTML = `<p style="color: var(--muted);">${error.message}</p>`;
          }
        })
        .finally(() => {
          setTabPanelLoading('regular', false);
        });
    }

    function loadMainTable() {
      if (mainTableInitialised) {
        return Promise.resolve();
      }
      setTabPanelLoading('main', true, 'Loading main data…');
      return fetchMainDataset()
        .then((dataset) => {
          updateStickyOffset();
          const augmentedDataset = augmentDatasetWithTotals(dataset);
          mainTableAugmentedDataset = augmentedDataset;
          mainTotalColumnIndex = augmentedDataset.totalColumnIndex;
          const tableElement = document.getElementById('main-table');
          applyHeaderPreambleToTable(tableElement, dataset.headerPreamble || null, augmentedDataset.columns);
          const columns = augmentedDataset.columns.map((title) => ({ title }));
          const formattedRows = augmentedDataset.rows.map((row) => row.map((value, index) => formatCellValue(value, augmentedDataset.columns[index])));
          const productColumnIndex = augmentedDataset.columns.indexOf('Product');
          const quantityColumnIndex = augmentedDataset.columns.findIndex((column) => column && column.trim().toLowerCase() === 'qty');
          const numericColumnIndices = augmentedDataset.numericColumnIndices;

          mainTableFooterValues = SHOW_REGULAR_TOTAL_ROW
            ? buildFormattedFooterValues(augmentedDataset)
            : [];
          mainTableNumericColumnSet = SHOW_REGULAR_TOTAL_ROW
            ? new Set(numericColumnIndices)
            : new Set();

          if (SHOW_REGULAR_TOTAL_ROW) {
            const tableElement = document.getElementById('main-table');
            if (tableElement) {
              ensureTableFooter(
                tableElement,
                augmentedDataset.columns.length,
                mainTableFooterValues,
                mainTableNumericColumnSet,
                mainTotalColumnIndex
              );
            }
          }

          const columnClassMap = new Map();
          const addColumnClass = (columnIndex, className) => {
            if (columnIndex < 0) {
              return;
            }
            if (!columnClassMap.has(columnIndex)) {
              columnClassMap.set(columnIndex, new Set());
            }
            columnClassMap.get(columnIndex).add(className);
          };

          addColumnClass(productColumnIndex, 'cell-product');
          addColumnClass(quantityColumnIndex, 'cell-qty');
          numericColumnIndices.forEach((columnIndex) => addColumnClass(columnIndex, 'cell-numeric'));

          const columnDefs = Array.from(columnClassMap.entries()).map(([columnIndex, classSet]) => ({
            targets: Number(columnIndex),
            className: Array.from(classSet).join(' '),
          }));

          const initialRowCount = Math.min(augmentedDataset.rows.length, REGULAR_TABLE_PAGE_LENGTH);
          const initialReservedSpace = calculateRegularTableReservedSpace();
          const initialScrollHeight = `${calculateScrollBodyHeight(initialRowCount, undefined, initialReservedSpace)}px`;
          mainTable = $('#main-table').DataTable({
            data: formattedRows,
            columns,
            columnDefs,
            scrollX: true,
            scrollY: initialScrollHeight,
            scrollCollapse: true,
            deferRender: true,
            autoWidth: true,
            order: [],
            paging: true,
            pageLength: REGULAR_TABLE_PAGE_LENGTH,
            lengthChange: false,
            info: false,
            dom: 't<"main-table__footer"p>'
          });

          moveMainTablePagination();
          mainColumnValueOptions = buildColumnOptions(augmentedDataset);
          initializeMainFilterControls(augmentedDataset);
          wireHeaderEvents(mainTable, {
            valueOptions: mainColumnValueOptions,
            filters: mainColumnFilters,
            onChange: handleMainFilterChange,
            totalIndex: mainTotalColumnIndex,
          });
          applyTableHeight(mainTable);
          if (SHOW_REGULAR_TOTAL_ROW) {
            updateMainTableFooter(mainTable);
          }
          mainTable.on('draw.dt', () => {
            wireHeaderEvents(mainTable, {
              valueOptions: mainColumnValueOptions,
              filters: mainColumnFilters,
              onChange: handleMainFilterChange,
              totalIndex: mainTotalColumnIndex,
            });
            applyTableHeight(mainTable);
            if (SHOW_REGULAR_TOTAL_ROW) {
              updateMainTableFooter(mainTable);
            }
            moveMainTablePagination();
          });

          mainTableInitialised = true;
          requestAnimationFrame(() => refreshMainTableLayout());
        })
        .catch((error) => {
          console.error('Failed to initialise Main table:', error);
          const tableElement = document.getElementById('main-table');
          if (tableElement) {
            tableElement.outerHTML = `<p style="color: var(--muted);">${error.message}</p>`;
          }
          const filterButton = document.getElementById('main-filter-button');
          if (filterButton) {
            filterButton.setAttribute('disabled', 'true');
            filterButton.setAttribute('aria-hidden', 'true');
            filterButton.setAttribute('aria-expanded', 'false');
            filterButton.dataset.active = 'false';
          }
          if (dashboardFilterButtonElement) {
            dashboardFilterButtonElement.setAttribute('disabled', 'true');
            dashboardFilterButtonElement.setAttribute('aria-hidden', 'true');
            dashboardFilterButtonElement.setAttribute('aria-expanded', 'false');
            dashboardFilterButtonElement.dataset.active = 'false';
          }
          if (mainFilterContainerElement) {
            closeMainFilter({ returnFocus: false });
            mainFilterContainerElement.setAttribute('hidden', '');
            mainFilterContainerElement.setAttribute('aria-hidden', 'true');
          }
        })
        .finally(() => {
          setTabPanelLoading('main', false);
        });
    }

  </script>
</body>
</html>
